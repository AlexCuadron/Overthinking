2025-01-17 07:41:49,641 - INFO - Building image: ghcr.io/all-hands-ai/runtime:oh_v0.20.0_90b1vhml4ui6xj01_1nhip1b65cn5t1ze
2025-01-17 07:43:23,040 - INFO - Image [ghcr.io/all-hands-ai/runtime:oh_v0.20.0_90b1vhml4ui6xj01_1nhip1b65cn5t1ze] build finished.
2025-01-17 07:43:23,048 - INFO - Re-tagged image [ghcr.io/all-hands-ai/runtime:oh_v0.20.0_90b1vhml4ui6xj01_1nhip1b65cn5t1ze] with more generic tag [oh_v0.20.0_90b1vhml4ui6xj01]
2025-01-17 07:43:23,050 - INFO - Image ghcr.io/all-hands-ai/runtime with tags [oh_v0.20.0_90b1vhml4ui6xj01_1nhip1b65cn5t1ze, oh_v0.20.0_90b1vhml4ui6xj01] built successfully
2025-01-17 07:43:23,057 - INFO - [runtime d2ed8b06-b0b0-470f-a284-6a980005cd3e-3ec544a2ffd45e92] Starting runtime with image: ghcr.io/all-hands-ai/runtime:oh_v0.20.0_90b1vhml4ui6xj01_1nhip1b65cn5t1ze
2025-01-17 07:43:23,713 - INFO - [runtime d2ed8b06-b0b0-470f-a284-6a980005cd3e-3ec544a2ffd45e92] Container started: openhands-runtime-d2ed8b06-b0b0-470f-a284-6a980005cd3e-3ec544a2ffd45e92. VSCode URL: None
2025-01-17 07:43:23,713 - INFO - [runtime d2ed8b06-b0b0-470f-a284-6a980005cd3e-3ec544a2ffd45e92] Waiting for client to become ready at http://localhost:37913...
2025-01-17 07:43:43,770 - INFO - [runtime d2ed8b06-b0b0-470f-a284-6a980005cd3e-3ec544a2ffd45e92] Runtime is ready.
2025-01-17 07:43:44,403 - INFO - ------------------------------
2025-01-17 07:43:44,403 - INFO - BEGIN Runtime Initialization Fn
2025-01-17 07:43:44,403 - INFO - ------------------------------
2025-01-17 07:43:44,403 - INFO - **CmdRunAction (source=None)**
COMMAND:
echo 'export SWE_INSTANCE_ID=sympy__sympy-20590' >> ~/.bashrc && echo 'export PIP_CACHE_DIR=~/.cache/pip' >> ~/.bashrc && echo "alias git='git --no-pager'" >> ~/.bashrc
2025-01-17 07:43:45,026 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "1967c622ecf0",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-17 07:43:45,026 - INFO - **CmdRunAction (source=None)**
COMMAND:
export USER=$(whoami); echo USER=${USER} 
2025-01-17 07:43:45,648 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "1967c622ecf0",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
USER=root
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-17 07:43:45,649 - INFO - **CmdRunAction (source=None)**
COMMAND:
mkdir -p /swe_util/eval_data/instances
2025-01-17 07:43:46,272 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "1967c622ecf0",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-17 07:43:46,278 - INFO - **CmdRunAction (source=None)**
COMMAND:
cat ~/.bashrc
2025-01-17 07:43:46,900 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "1967c622ecf0",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
source /opt/miniconda3/etc/profile.d/conda.sh && conda activate testbed
export SWE_INSTANCE_ID=sympy__sympy-20590
export PIP_CACHE_DIR=~/.cache/pip
alias git='git --no-pager'
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-17 07:43:46,900 - INFO - **CmdRunAction (source=None)**
COMMAND:
source ~/.bashrc
2025-01-17 07:43:47,522 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "1967c622ecf0",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-17 07:43:47,522 - INFO - **CmdRunAction (source=None)**
COMMAND:
source /swe_util/instance_swe_entry.sh
2025-01-17 07:43:49,152 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "1967c622ecf0",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
WORKSPACE_NAME: sympy__sympy__1.7
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-17 07:43:49,152 - INFO - **CmdRunAction (source=None)**
COMMAND:
cd /workspace/sympy__sympy__1.7
2025-01-17 07:43:49,776 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "1967c622ecf0",
  "working_dir": "/workspace/sympy__sympy__1.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/sympy__sympy__1.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-17 07:43:49,777 - INFO - **CmdRunAction (source=None)**
COMMAND:
git reset --hard
2025-01-17 07:43:50,400 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "1967c622ecf0",
  "working_dir": "/workspace/sympy__sympy__1.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
HEAD is now at cffd4e0f86 Merge pull request #20589 from oscarbenjamin/pr_17_series
[The command completed with exit code 0.]
[Current working directory: /workspace/sympy__sympy__1.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-17 07:43:50,400 - INFO - **CmdRunAction (source=None)**
COMMAND:
for remote_name in $(git remote); do git remote remove "${remote_name}"; done
2025-01-17 07:43:51,024 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "1967c622ecf0",
  "working_dir": "/workspace/sympy__sympy__1.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/sympy__sympy__1.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-17 07:43:51,025 - INFO - **CmdRunAction (source=None)**
COMMAND:
which python
2025-01-17 07:43:51,647 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "1967c622ecf0",
  "working_dir": "/workspace/sympy__sympy__1.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
/opt/miniconda3/envs/testbed/bin/python
[The command completed with exit code 0.]
[Current working directory: /workspace/sympy__sympy__1.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-17 07:43:51,647 - INFO - ------------------------------
2025-01-17 07:43:51,647 - INFO - END Runtime Initialization Fn
2025-01-17 07:43:51,647 - INFO - ------------------------------
2025-01-17 07:43:51,649 - INFO - Function calling not enabled for model hosted_vllm/Qwen/QwQ-32B-Preview. Mocking function calling via prompting.
2025-01-17 07:43:51,652 - INFO - [runtime d2ed8b06-b0b0-470f-a284-6a980005cd3e-3ec544a2ffd45e92] Selected repo: None, loading microagents from /workspace/.openhands/microagents (inside runtime)
2025-01-17 07:43:51,670 - INFO - [Agent Controller default] Setting agent(CodeActAgent) state from AgentState.LOADING to AgentState.RUNNING
2025-01-17 07:43:51,671 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 0 GLOBAL STEP 0
2025-01-17 07:46:00,026 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 1 GLOBAL STEP 1
2025-01-17 07:48:02,853 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 2 GLOBAL STEP 2
2025-01-17 07:50:39,934 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 3 GLOBAL STEP 3
2025-01-17 07:52:24,913 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 4 GLOBAL STEP 4
2025-01-17 07:55:03,798 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 5 GLOBAL STEP 5
2025-01-17 07:56:07,304 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 6 GLOBAL STEP 6
2025-01-17 07:57:13,023 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 7 GLOBAL STEP 7
2025-01-17 07:58:05,714 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 8 GLOBAL STEP 8
2025-01-17 07:58:59,747 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 9 GLOBAL STEP 9
2025-01-17 07:59:47,085 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 10 GLOBAL STEP 10
2025-01-17 08:00:43,603 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 11 GLOBAL STEP 11
2025-01-17 08:00:43,845 - INFO - [Agent Controller default] Setting agent(CodeActAgent) state from AgentState.RUNNING to AgentState.ERROR
2025-01-17 08:00:43,856 - INFO - [Agent Controller default] Setting agent(CodeActAgent) state from AgentState.ERROR to AgentState.ERROR
2025-01-17 08:00:44,633 - INFO - ------------------------------
2025-01-17 08:00:44,633 - INFO - BEGIN Runtime Completion Fn
2025-01-17 08:00:44,633 - INFO - ------------------------------
2025-01-17 08:00:44,633 - INFO - **CmdRunAction (source=None)**
COMMAND:
cd /workspace/sympy__sympy__1.7
2025-01-17 08:00:45,257 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "1967c622ecf0",
  "working_dir": "/workspace/sympy__sympy__1.7",
  "py_interpreter_path": "/workspace/sympy__sympy__1.7/sympy_env/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/sympy__sympy__1.7]
[Python interpreter: /workspace/sympy__sympy__1.7/sympy_env/bin/python]
--END AGENT OBSERVATION--
2025-01-17 08:00:45,258 - INFO - **CmdRunAction (source=None)**
COMMAND:
git config --global core.pager ""
2025-01-17 08:00:45,879 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "1967c622ecf0",
  "working_dir": "/workspace/sympy__sympy__1.7",
  "py_interpreter_path": "/workspace/sympy__sympy__1.7/sympy_env/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/sympy__sympy__1.7]
[Python interpreter: /workspace/sympy__sympy__1.7/sympy_env/bin/python]
--END AGENT OBSERVATION--
2025-01-17 08:00:45,880 - INFO - **CmdRunAction (source=None)**
COMMAND:
git add -A
2025-01-17 08:00:47,511 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "1967c622ecf0",
  "working_dir": "/workspace/sympy__sympy__1.7",
  "py_interpreter_path": "/workspace/sympy__sympy__1.7/sympy_env/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/sympy__sympy__1.7]
[Python interpreter: /workspace/sympy__sympy__1.7/sympy_env/bin/python]
--END AGENT OBSERVATION--
2025-01-17 08:00:47,512 - INFO - **CmdRunAction (source=None)**
COMMAND:
git diff --no-color --cached cffd4e0f86fefd4802349a9f9b19ed70934ea354
2025-01-17 08:00:51,527 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "1967c622ecf0",
  "working_dir": "/workspace/sympy__sympy__1.7",
  "py_interpreter_path": "/workspace/sympy__sympy__1.7/sympy_env/bin/python",
  "prefix": "[Previous command outputs are truncated. Showing the last 10216 lines of the output below.]\n",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
[Previous command outputs are truncated. Showing the last 10216 lines of the output below.]
+
+    for c in (ExtraneousFactors, ExtraneousFactors()):
+        check(c)
+
+    for c in (EvaluationFailed, EvaluationFailed()):
+        check(c)
+
+    for c in (RefinementFailed, RefinementFailed()):
+        check(c)
+
+    for c in (CoercionFailed, CoercionFailed()):
+        check(c)
+
+    for c in (NotInvertible, NotInvertible()):
+        check(c)
+
+    for c in (NotReversible, NotReversible()):
+        check(c)
+
+    for c in (NotAlgebraic, NotAlgebraic()):
+        check(c)
+
+    for c in (DomainError, DomainError()):
+        check(c)
+
+    for c in (PolynomialError, PolynomialError()):
+        check(c)
+
+    for c in (UnificationFailed, UnificationFailed()):
+        check(c)
+
+    for c in (GeneratorsError, GeneratorsError()):
+        check(c)
+
+    for c in (GeneratorsNeeded, GeneratorsNeeded()):
+        check(c)
+
+    # TODO: PicklingError: Can't pickle <function <lambda> at 0x38578c0>: it's not found as __main__.<lambda>
+    # for c in (ComputationFailed, ComputationFailed(lambda t: t, 3, None)):
+    #    check(c)
+
+    for c in (UnivariatePolynomialError, UnivariatePolynomialError()):
+        check(c)
+
+    for c in (MultivariatePolynomialError, MultivariatePolynomialError()):
+        check(c)
+
+    # TODO: TypeError: __init__() takes at least 3 arguments (1 given)
+    # for c in (PolificationFailed, PolificationFailed({}, x, x, False)):
+    #    check(c)
+
+    for c in (OptionError, OptionError()):
+        check(c)
+
+    for c in (FlagError, FlagError()):
+        check(c)
+
+#def test_pickling_polys_options():
+    #from sympy.polys.polyoptions import Options
+
+    # TODO: fix pickling of `symbols' flag
+    # for c in (Options, Options((), dict(domain='ZZ', polys=False))):
+    #    check(c)
+
+# TODO: def test_pickling_polys_rootisolation():
+#    RealInterval
+#    ComplexInterval
+
+def test_pickling_polys_rootoftools():
+    from sympy.polys.rootoftools import CRootOf, RootSum
+
+    x = Symbol('x')
+    f = x**3 + x + 3
+
+    for c in (CRootOf, CRootOf(f, 0)):
+        check(c)
+
+    for c in (RootSum, RootSum(f, exp)):
+        check(c)
+
+#================== printing ====================
+from sympy.printing.latex import LatexPrinter
+from sympy.printing.mathml import MathMLContentPrinter, MathMLPresentationPrinter
+from sympy.printing.pretty.pretty import PrettyPrinter
+from sympy.printing.pretty.stringpict import prettyForm, stringPict
+from sympy.printing.printer import Printer
+from sympy.printing.python import PythonPrinter
+
+
+def test_printing():
+    for c in (LatexPrinter, LatexPrinter(), MathMLContentPrinter,
+              MathMLPresentationPrinter, PrettyPrinter, prettyForm, stringPict,
+              stringPict("a"), Printer, Printer(), PythonPrinter,
+              PythonPrinter()):
+        check(c)
+
+
+@XFAIL
+def test_printing1():
+    check(MathMLContentPrinter())
+
+
+@XFAIL
+def test_printing2():
+    check(MathMLPresentationPrinter())
+
+
+@XFAIL
+def test_printing3():
+    check(PrettyPrinter())
+
+#================== series ======================
+from sympy.series.limits import Limit
+from sympy.series.order import Order
+
+
+def test_series():
+    e = Symbol("e")
+    x = Symbol("x")
+    for c in (Limit, Limit(e, x, 1), Order, Order(e)):
+        check(c)
+
+#================== concrete ==================
+from sympy.concrete.products import Product
+from sympy.concrete.summations import Sum
+
+
+def test_concrete():
+    x = Symbol("x")
+    for c in (Product, Product(x, (x, 2, 4)), Sum, Sum(x, (x, 2, 4))):
+        check(c)
+
+def test_deprecation_warning():
+    w = SymPyDeprecationWarning('value', 'feature', issue=12345, deprecated_since_version='1.0')
+    check(w)
+
+def test_issue_18438():
+    assert pickle.loads(pickle.dumps(S.Half)) == 1/2
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_source.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_source.py
new file mode 100644
index 0000000000..d4df63c09b
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_source.py
@@ -0,0 +1,30 @@
+import sys
+
+from sympy.utilities.source import get_mod_func, get_class, source
+from sympy.testing.pytest import warns_deprecated_sympy
+from sympy.geometry import point
+
+def test_source():
+    # Dummy stdout
+    class StdOut:
+        def write(self, x):
+            pass
+
+    # Test SymPyDeprecationWarning from source()
+    with warns_deprecated_sympy():
+        # Redirect stdout temporarily so print out is not seen
+        stdout = sys.stdout
+        try:
+            sys.stdout = StdOut()
+            source(point)
+        finally:
+            sys.stdout = stdout
+
+def test_get_mod_func():
+    assert get_mod_func(
+        'sympy.core.basic.Basic') == ('sympy.core.basic', 'Basic')
+
+
+def test_get_class():
+    _basic = get_class('sympy.core.basic.Basic')
+    assert _basic.__name__ == 'Basic'
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_timeutils.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_timeutils.py
new file mode 100644
index 0000000000..edaf66f919
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_timeutils.py
@@ -0,0 +1,10 @@
+"""Tests for simple tools for timing functions' execution. """
+
+from sympy.utilities.timeutils import timed
+
+def test_timed():
+    result = timed(lambda: 1 + 1, limit=100000)
+    assert result[0] == 100000 and result[3] == "ns"
+
+    result = timed("1 + 1", limit=100000)
+    assert result[0] == 100000 and result[3] == "ns"
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_wester.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_wester.py
new file mode 100644
index 0000000000..02b3dc6eb3
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_wester.py
@@ -0,0 +1,3043 @@
+""" Tests from Michael Wester's 1999 paper "Review of CAS mathematical
+capabilities".
+
+http://www.math.unm.edu/~wester/cas/book/Wester.pdf
+See also http://math.unm.edu/~wester/cas_review.html for detailed output of
+each tested system.
+"""
+
+from sympy import (Rational, symbols, Dummy, factorial, sqrt, log, exp, oo, zoo,
+    product, binomial, rf, pi, gamma, igcd, factorint, radsimp, combsimp,
+    npartitions, totient, primerange, factor, simplify, gcd, resultant, expand,
+    I, trigsimp, tan, sin, cos, cot, diff, nan, limit, EulerGamma, polygamma,
+    bernoulli, hyper, hyperexpand, besselj, asin, assoc_legendre, Function, re,
+    im, DiracDelta, chebyshevt, legendre_poly, polylog, series, O,
+    atan, sinh, cosh, tanh, floor, ceiling, solve, asinh, acot, csc, sec,
+    LambertW, N, apart, sqrtdenest, factorial2, powdenest, Mul, S, ZZ,
+    Poly, expand_func, E, Q, And, Lt, Min, ask, refine, AlgebraicNumber,
+    continued_fraction_iterator as cf_i, continued_fraction_periodic as cf_p,
+    continued_fraction_convergents as cf_c, continued_fraction_reduce as cf_r,
+    FiniteSet, elliptic_e, elliptic_f, powsimp, hessian, wronskian, fibonacci,
+    sign, Lambda, Piecewise, Subs, residue, Derivative, logcombine, Symbol,
+    Intersection, Union, EmptySet, Interval, idiff, ImageSet, acos, Max,
+    MatMul, conjugate)
+
+import mpmath
+from sympy.functions.combinatorial.numbers import stirling
+from sympy.functions.special.delta_functions import Heaviside
+from sympy.functions.special.error_functions import Ci, Si, erf
+from sympy.functions.special.zeta_functions import zeta
+from sympy.testing.pytest import (XFAIL, slow, SKIP, skip, ON_TRAVIS,
+    raises)
+from sympy.utilities.iterables import partitions
+from mpmath import mpi, mpc
+from sympy.matrices import Matrix, GramSchmidt, eye
+from sympy.matrices.expressions.blockmatrix import BlockMatrix, block_collapse
+from sympy.matrices.expressions import MatrixSymbol, ZeroMatrix
+from sympy.physics.quantum import Commutator
+from sympy.assumptions import assuming
+from sympy.polys.rings import PolyRing
+from sympy.polys.fields import FracField
+from sympy.polys.solvers import solve_lin_sys
+from sympy.concrete import Sum
+from sympy.concrete.products import Product
+from sympy.integrals import integrate
+from sympy.integrals.transforms import laplace_transform,\
+    inverse_laplace_transform, LaplaceTransform, fourier_transform,\
+    mellin_transform
+from sympy.solvers.recurr import rsolve
+from sympy.solvers.solveset import solveset, solveset_real, linsolve
+from sympy.solvers.ode import dsolve
+from sympy.core.relational import Equality
+from itertools import islice, takewhile
+from sympy.series.formal import fps
+from sympy.series.fourier import fourier_series
+from sympy.calculus.util import minimum
+
+
+R = Rational
+x, y, z = symbols('x y z')
+i, j, k, l, m, n = symbols('i j k l m n', integer=True)
+f = Function('f')
+g = Function('g')
+
+# A. Boolean Logic and Quantifier Elimination
+#   Not implemented.
+
+# B. Set Theory
+
+
+def test_B1():
+    assert (FiniteSet(i, j, j, k, k, k) | FiniteSet(l, k, j) |
+            FiniteSet(j, m, j)) == FiniteSet(i, j, k, l, m)
+
+
+def test_B2():
+    assert (FiniteSet(i, j, j, k, k, k) & FiniteSet(l, k, j) &
+            FiniteSet(j, m, j)) == Intersection({j, m}, {i, j, k}, {j, k, l})
+    # Previous output below. Not sure why that should be the expected output.
+    # There should probably be a way to rewrite Intersections that way but I
+    # don't see why an Intersection should evaluate like that:
+    #
+    # == Union({j}, Intersection({m}, Union({j, k}, Intersection({i}, {l}))))
+
+
+def test_B3():
+    assert (FiniteSet(i, j, k, l, m) - FiniteSet(j) ==
+            FiniteSet(i, k, l, m))
+
+
+def test_B4():
+    assert (FiniteSet(*(FiniteSet(i, j)*FiniteSet(k, l))) ==
+            FiniteSet((i, k), (i, l), (j, k), (j, l)))
+
+
+# C. Numbers
+
+
+def test_C1():
+    assert (factorial(50) ==
+        30414093201713378043612608166064768844377641568960512000000000000)
+
+
+def test_C2():
+    assert (factorint(factorial(50)) == {2: 47, 3: 22, 5: 12, 7: 8,
+        11: 4, 13: 3, 17: 2, 19: 2, 23: 2, 29: 1, 31: 1, 37: 1,
+        41: 1, 43: 1, 47: 1})
+
+
+def test_C3():
+    assert (factorial2(10), factorial2(9)) == (3840, 945)
+
+
+# Base conversions; not really implemented by sympy
+# Whatever. Take credit!
+def test_C4():
+    assert 0xABC == 2748
+
+
+def test_C5():
+    assert 123 == int('234', 7)
+
+
+def test_C6():
+    assert int('677', 8) == int('1BF', 16) == 447
+
+
+def test_C7():
+    assert log(32768, 8) == 5
+
+
+def test_C8():
+    # Modular multiplicative inverse. Would be nice if divmod could do this.
+    assert ZZ.invert(5, 7) == 3
+    assert ZZ.invert(5, 6) == 5
+
+
+def test_C9():
+    assert igcd(igcd(1776, 1554), 5698) == 74
+
+
+def test_C10():
+    x = 0
+    for n in range(2, 11):
+        x += R(1, n)
+    assert x == R(4861, 2520)
+
+
+def test_C11():
+    assert R(1, 7) == S('0.[142857]')
+
+
+def test_C12():
+    assert R(7, 11) * R(22, 7) == 2
+
+
+def test_C13():
+    test = R(10, 7) * (1 + R(29, 1000)) ** R(1, 3)
+    good = 3 ** R(1, 3)
+    assert test == good
+
+
+def test_C14():
+    assert sqrtdenest(sqrt(2*sqrt(3) + 4)) == 1 + sqrt(3)
+
+
+def test_C15():
+    test = sqrtdenest(sqrt(14 + 3*sqrt(3 + 2*sqrt(5 - 12*sqrt(3 - 2*sqrt(2))))))
+    good = sqrt(2) + 3
+    assert test == good
+
+
+def test_C16():
+    test = sqrtdenest(sqrt(10 + 2*sqrt(6) + 2*sqrt(10) + 2*sqrt(15)))
+    good = sqrt(2) + sqrt(3) + sqrt(5)
+    assert test == good
+
+
+def test_C17():
+    test = radsimp((sqrt(3) + sqrt(2)) / (sqrt(3) - sqrt(2)))
+    good = 5 + 2*sqrt(6)
+    assert test == good
+
+
+def test_C18():
+    assert simplify((sqrt(-2 + sqrt(-5)) * sqrt(-2 - sqrt(-5))).expand(complex=True)) == 3
+
+
+@XFAIL
+def test_C19():
+    assert radsimp(simplify((90 + 34*sqrt(7)) ** R(1, 3))) == 3 + sqrt(7)
+
+
+def test_C20():
+    inside = (135 + 78*sqrt(3))
+    test = AlgebraicNumber((inside**R(2, 3) + 3) * sqrt(3) / inside**R(1, 3))
+    assert simplify(test) == AlgebraicNumber(12)
+
+
+def test_C21():
+    assert simplify(AlgebraicNumber((41 + 29*sqrt(2)) ** R(1, 5))) == \
+        AlgebraicNumber(1 + sqrt(2))
+
+
+@XFAIL
+def test_C22():
+    test = simplify(((6 - 4*sqrt(2))*log(3 - 2*sqrt(2)) + (3 - 2*sqrt(2))*log(17
+        - 12*sqrt(2)) + 32 - 24*sqrt(2)) / (48*sqrt(2) - 72))
+    good = sqrt(2)/3 - log(sqrt(2) - 1)/3
+    assert test == good
+
+
+def test_C23():
+    assert 2 * oo - 3 is oo
+
+
+@XFAIL
+def test_C24():
+    raise NotImplementedError("2**aleph_null == aleph_1")
+
+# D. Numerical Analysis
+
+
+def test_D1():
+    assert 0.0 / sqrt(2) == 0.0
+
+
+def test_D2():
+    assert str(exp(-1000000).evalf()) == '3.29683147808856e-434295'
+
+
+def test_D3():
+    assert exp(pi*sqrt(163)).evalf(50).num.ae(262537412640768744)
+
+
+def test_D4():
+    assert floor(R(-5, 3)) == -2
+    assert ceiling(R(-5, 3)) == -1
+
+
+@XFAIL
+def test_D5():
+    raise NotImplementedError("cubic_spline([1, 2, 4, 5], [1, 4, 2, 3], x)(3) == 27/8")
+
+
+@XFAIL
+def test_D6():
+    raise NotImplementedError("translate sum(a[i]*x**i, (i,1,n)) to FORTRAN")
+
+
+@XFAIL
+def test_D7():
+    raise NotImplementedError("translate sum(a[i]*x**i, (i,1,n)) to C")
+
+
+@XFAIL
+def test_D8():
+    # One way is to cheat by converting the sum to a string,
+    # and replacing the '[' and ']' with ''.
+    # E.g., horner(S(str(_).replace('[','').replace(']','')))
+    raise NotImplementedError("apply Horner's rule to sum(a[i]*x**i, (i,1,5))")
+
+
+@XFAIL
+def test_D9():
+    raise NotImplementedError("translate D8 to FORTRAN")
+
+
+@XFAIL
+def test_D10():
+    raise NotImplementedError("translate D8 to C")
+
+
+@XFAIL
+def test_D11():
+    #Is there a way to use count_ops?
+    raise NotImplementedError("flops(sum(product(f[i][k], (i,1,k)), (k,1,n)))")
+
+
+@XFAIL
+def test_D12():
+    assert (mpi(-4, 2) * x + mpi(1, 3)) ** 2 == mpi(-8, 16)*x**2 + mpi(-24, 12)*x + mpi(1, 9)
+
+
+@XFAIL
+def test_D13():
+    raise NotImplementedError("discretize a PDE: diff(f(x,t),t) == diff(diff(f(x,t),x),x)")
+
+# E. Statistics
+#   See scipy; all of this is numerical.
+
+# F. Combinatorial Theory.
+
+
+def test_F1():
+    assert rf(x, 3) == x*(1 + x)*(2 + x)
+
+
+def test_F2():
+    assert expand_func(binomial(n, 3)) == n*(n - 1)*(n - 2)/6
+
+
+@XFAIL
+def test_F3():
+    assert combsimp(2**n * factorial(n) * factorial2(2*n - 1)) == factorial(2*n)
+
+
+@XFAIL
+def test_F4():
+    assert combsimp(2**n * factorial(n) * product(2*k - 1, (k, 1, n))) == factorial(2*n)
+
+
+@XFAIL
+def test_F5():
+    assert gamma(n + R(1, 2)) / sqrt(pi) / factorial(n) == factorial(2*n)/2**(2*n)/factorial(n)**2
+
+
+def test_F6():
+    partTest = [p.copy() for p in partitions(4)]
+    partDesired = [{4: 1}, {1: 1, 3: 1}, {2: 2}, {1: 2, 2:1}, {1: 4}]
+    assert partTest == partDesired
+
+
+def test_F7():
+    assert npartitions(4) == 5
+
+
+def test_F8():
+    assert stirling(5, 2, signed=True) == -50  # if signed, then kind=1
+
+
+def test_F9():
+    assert totient(1776) == 576
+
+# G. Number Theory
+
+
+def test_G1():
+    assert list(primerange(999983, 1000004)) == [999983, 1000003]
+
+
+@XFAIL
+def test_G2():
+    raise NotImplementedError("find the primitive root of 191 == 19")
+
+
+@XFAIL
+def test_G3():
+    raise NotImplementedError("(a+b)**p mod p == a**p + b**p mod p; p prime")
+
+# ... G14 Modular equations are not implemented.
+
+def test_G15():
+    assert Rational(sqrt(3).evalf()).limit_denominator(15) == R(26, 15)
+    assert list(takewhile(lambda x: x.q <= 15, cf_c(cf_i(sqrt(3)))))[-1] == \
+        R(26, 15)
+
+
+def test_G16():
+    assert list(islice(cf_i(pi),10)) == [3, 7, 15, 1, 292, 1, 1, 1, 2, 1]
+
+
+def test_G17():
+    assert cf_p(0, 1, 23) == [4, [1, 3, 1, 8]]
+
+
+def test_G18():
+    assert cf_p(1, 2, 5) == [[1]]
+    assert cf_r([[1]]).expand() == S.Half + sqrt(5)/2
+
+
+@XFAIL
+def test_G19():
+    s = symbols('s', integer=True, positive=True)
+    it = cf_i((exp(1/s) - 1)/(exp(1/s) + 1))
+    assert list(islice(it, 5)) == [0, 2*s, 6*s, 10*s, 14*s]
+
+
+def test_G20():
+    s = symbols('s', integer=True, positive=True)
+    # Wester erroneously has this as -s + sqrt(s**2 + 1)
+    assert cf_r([[2*s]]) == s + sqrt(s**2 + 1)
+
+
+@XFAIL
+def test_G20b():
+    s = symbols('s', integer=True, positive=True)
+    assert cf_p(s, 1, s**2 + 1) == [[2*s]]
+
+
+# H. Algebra
+
+
+def test_H1():
+    assert simplify(2*2**n) == simplify(2**(n + 1))
+    assert powdenest(2*2**n) == simplify(2**(n + 1))
+
+
+def test_H2():
+    assert powsimp(4 * 2**n) == 2**(n + 2)
+
+
+def test_H3():
+    assert (-1)**(n*(n + 1)) == 1
+
+
+def test_H4():
+    expr = factor(6*x - 10)
+    assert type(expr) is Mul
+    assert expr.args[0] == 2
+    assert expr.args[1] == 3*x - 5
+
+p1 = 64*x**34 - 21*x**47 - 126*x**8 - 46*x**5 - 16*x**60 - 81
+p2 = 72*x**60 - 25*x**25 - 19*x**23 - 22*x**39 - 83*x**52 + 54*x**10 + 81
+q = 34*x**19 - 25*x**16 + 70*x**7 + 20*x**3 - 91*x - 86
+
+
+def test_H5():
+    assert gcd(p1, p2, x) == 1
+
+
+def test_H6():
+    assert gcd(expand(p1 * q), expand(p2 * q)) == q
+
+
+def test_H7():
+    p1 = 24*x*y**19*z**8 - 47*x**17*y**5*z**8 + 6*x**15*y**9*z**2 - 3*x**22 + 5
+    p2 = 34*x**5*y**8*z**13 + 20*x**7*y**7*z**7 + 12*x**9*y**16*z**4 + 80*y**14*z
+    assert gcd(p1, p2, x, y, z) == 1
+
+
+def test_H8():
+    p1 = 24*x*y**19*z**8 - 47*x**17*y**5*z**8 + 6*x**15*y**9*z**2 - 3*x**22 + 5
+    p2 = 34*x**5*y**8*z**13 + 20*x**7*y**7*z**7 + 12*x**9*y**16*z**4 + 80*y**14*z
+    q = 11*x**12*y**7*z**13 - 23*x**2*y**8*z**10 + 47*x**17*y**5*z**8
+    assert gcd(p1 * q, p2 * q, x, y, z) == q
+
+
+def test_H9():
+    p1 = 2*x**(n + 4) - x**(n + 2)
+    p2 = 4*x**(n + 1) + 3*x**n
+    assert gcd(p1, p2) == x**n
+
+
+def test_H10():
+    p1 = 3*x**4 + 3*x**3 + x**2 - x - 2
+    p2 = x**3 - 3*x**2 + x + 5
+    assert resultant(p1, p2, x) == 0
+
+
+def test_H11():
+    assert resultant(p1 * q, p2 * q, x) == 0
+
+
+def test_H12():
+    num = x**2 - 4
+    den = x**2 + 4*x + 4
+    assert simplify(num/den) == (x - 2)/(x + 2)
+
+
+@XFAIL
+def test_H13():
+    assert simplify((exp(x) - 1) / (exp(x/2) + 1)) == exp(x/2) - 1
+
+
+def test_H14():
+    p = (x + 1) ** 20
+    ep = expand(p)
+    assert ep == (1 + 20*x + 190*x**2 + 1140*x**3 + 4845*x**4 + 15504*x**5
+        + 38760*x**6 + 77520*x**7 + 125970*x**8 + 167960*x**9 + 184756*x**10
+        + 167960*x**11 + 125970*x**12 + 77520*x**13 + 38760*x**14 + 15504*x**15
+        + 4845*x**16 + 1140*x**17 + 190*x**18 + 20*x**19 + x**20)
+    dep = diff(ep, x)
+    assert dep == (20 + 380*x + 3420*x**2 + 19380*x**3 + 77520*x**4
+        + 232560*x**5 + 542640*x**6 + 1007760*x**7 + 1511640*x**8 + 1847560*x**9
+        + 1847560*x**10 + 1511640*x**11 + 1007760*x**12 + 542640*x**13
+        + 232560*x**14 + 77520*x**15 + 19380*x**16 + 3420*x**17 + 380*x**18
+        + 20*x**19)
+    assert factor(dep) == 20*(1 + x)**19
+
+
+def test_H15():
+    assert simplify(Mul(*[x - r for r in solveset(x**3 + x**2 - 7)])) == x**3 + x**2 - 7
+
+
+def test_H16():
+    assert factor(x**100 - 1) == ((x - 1)*(x + 1)*(x**2 + 1)*(x**4 - x**3
+        + x**2 - x + 1)*(x**4 + x**3 + x**2 + x + 1)*(x**8 - x**6 + x**4
+        - x**2 + 1)*(x**20 - x**15 + x**10 - x**5 + 1)*(x**20 + x**15 + x**10
+        + x**5 + 1)*(x**40 - x**30 + x**20 - x**10 + 1))
+
+
+def test_H17():
+    assert simplify(factor(expand(p1 * p2)) - p1*p2) == 0
+
+
+@XFAIL
+def test_H18():
+    # Factor over complex rationals.
+    test = factor(4*x**4 + 8*x**3 + 77*x**2 + 18*x + 153)
+    good = (2*x + 3*I)*(2*x - 3*I)*(x + 1 - 4*I)*(x + 1 + 4*I)
+    assert test == good
+
+
+def test_H19():
+    a = symbols('a')
+    # The idea is to let a**2 == 2, then solve 1/(a-1). Answer is a+1")
+    assert Poly(a - 1).invert(Poly(a**2 - 2)) == a + 1
+
+
+@XFAIL
+def test_H20():
+    raise NotImplementedError("let a**2==2; (x**3 + (a-2)*x**2 - "
+        + "(2*a+3)*x - 3*a) / (x**2-2) = (x**2 - 2*x - 3) / (x-a)")
+
+
+@XFAIL
+def test_H21():
+    raise NotImplementedError("evaluate (b+c)**4 assuming b**3==2, c**2==3. \
+                              Answer is 2*b + 8*c + 18*b**2 + 12*b*c + 9")
+
+
+def test_H22():
+    assert factor(x**4 - 3*x**2 + 1, modulus=5) == (x - 2)**2 * (x + 2)**2
+
+
+def test_H23():
+    f = x**11 + x + 1
+    g = (x**2 + x + 1) * (x**9 - x**8 + x**6 - x**5 + x**3 - x**2 + 1)
+    assert factor(f, modulus=65537) == g
+
+
+def test_H24():
+    phi = AlgebraicNumber(S.GoldenRatio.expand(func=True), alias='phi')
+    assert factor(x**4 - 3*x**2 + 1, extension=phi) == \
+        (x - phi)*(x + 1 - phi)*(x - 1 + phi)*(x + phi)
+
+
+def test_H25():
+    e = (x - 2*y**2 + 3*z**3) ** 20
+    assert factor(expand(e)) == e
+
+
+def test_H26():
+    g = expand((sin(x) - 2*cos(y)**2 + 3*tan(z)**3)**20)
+    assert factor(g, expand=False) == (-sin(x) + 2*cos(y)**2 - 3*tan(z)**3)**20
+
+
+def test_H27():
+    f = 24*x*y**19*z**8 - 47*x**17*y**5*z**8 + 6*x**15*y**9*z**2 - 3*x**22 + 5
+    g = 34*x**5*y**8*z**13 + 20*x**7*y**7*z**7 + 12*x**9*y**16*z**4 + 80*y**14*z
+    h = -2*z*y**7 \
+        *(6*x**9*y**9*z**3 + 10*x**7*z**6 + 17*y*x**5*z**12 + 40*y**7) \
+        *(3*x**22 + 47*x**17*y**5*z**8 - 6*x**15*y**9*z**2 - 24*x*y**19*z**8 - 5)
+    assert factor(expand(f*g)) == h
+
+
+@XFAIL
+def test_H28():
+    raise NotImplementedError("expand ((1 - c**2)**5 * (1 - s**2)**5 * "
+        + "(c**2 + s**2)**10) with c**2 + s**2 = 1. Answer is c**10*s**10.")
+
+
+@XFAIL
+def test_H29():
+    assert factor(4*x**2 - 21*x*y + 20*y**2, modulus=3) == (x + y)*(x - y)
+
+
+def test_H30():
+    test = factor(x**3 + y**3, extension=sqrt(-3))
+    answer = (x + y)*(x + y*(-R(1, 2) - sqrt(3)/2*I))*(x + y*(-R(1, 2) + sqrt(3)/2*I))
+    assert answer == test
+
+
+def test_H31():
+    f = (x**2 + 2*x + 3)/(x**3 + 4*x**2 + 5*x + 2)
+    g = 2 / (x + 1)**2 - 2 / (x + 1) + 3 / (x + 2)
+    assert apart(f) == g
+
+
+@XFAIL
+def test_H32():  # issue 6558
+    raise NotImplementedError("[A*B*C - (A*B*C)**(-1)]*A*C*B (product \
+                              of a non-commuting product and its inverse)")
+
+
+def test_H33():
+    A, B, C = symbols('A, B, C', commutative=False)
+    assert (Commutator(A, Commutator(B, C))
+        + Commutator(B, Commutator(C, A))
+        + Commutator(C, Commutator(A, B))).doit().expand() == 0
+
+
+# I. Trigonometry
+
+def test_I1():
+    assert tan(pi*R(7, 10)) == -sqrt(1 + 2/sqrt(5))
+
+
+@XFAIL
+def test_I2():
+    assert sqrt((1 + cos(6))/2) == -cos(3)
+
+
+def test_I3():
+    assert cos(n*pi) + sin((4*n - 1)*pi/2) == (-1)**n - 1
+
+
+def test_I4():
+    assert refine(cos(pi*cos(n*pi)) + sin(pi/2*cos(n*pi)), Q.integer(n)) == (-1)**n - 1
+
+
+@XFAIL
+def test_I5():
+    assert sin((n**5/5 + n**4/2 + n**3/3 - n/30) * pi) == 0
+
+
+@XFAIL
+def test_I6():
+    raise NotImplementedError("assuming -3*pi<x<-5*pi/2, abs(cos(x)) == -cos(x), abs(sin(x)) == -sin(x)")
+
+
+@XFAIL
+def test_I7():
+    assert cos(3*x)/cos(x) == cos(x)**2 - 3*sin(x)**2
+
+
+@XFAIL
+def test_I8():
+    assert cos(3*x)/cos(x) == 2*cos(2*x) - 1
+
+
+@XFAIL
+def test_I9():
+    # Supposed to do this with rewrite rules.
+    assert cos(3*x)/cos(x) == cos(x)**2 - 3*sin(x)**2
+
+
+def test_I10():
+    assert trigsimp((tan(x)**2 + 1 - cos(x)**-2) / (sin(x)**2 + cos(x)**2 - 1)) is nan
+
+
+@SKIP("hangs")
+@XFAIL
+def test_I11():
+    assert limit((tan(x)**2 + 1 - cos(x)**-2) / (sin(x)**2 + cos(x)**2 - 1), x, 0) != 0
+
+
+@XFAIL
+def test_I12():
+    # This should fail or return nan or something.
+    res = diff((tan(x)**2 + 1 - cos(x)**-2) / (sin(x)**2 + cos(x)**2 - 1), x)
+    assert res is nan # trigsimp(res) gives nan
+
+# J. Special functions.
+
+
+def test_J1():
+    assert bernoulli(16) == R(-3617, 510)
+
+
+def test_J2():
+    assert diff(elliptic_e(x, y**2), y) == (elliptic_e(x, y**2) - elliptic_f(x, y**2))/y
+
+
+@XFAIL
+def test_J3():
+    raise NotImplementedError("Jacobi elliptic functions: diff(dn(u,k), u) == -k**2*sn(u,k)*cn(u,k)")
+
+
+def test_J4():
+    assert gamma(R(-1, 2)) == -2*sqrt(pi)
+
+
+def test_J5():
+    assert polygamma(0, R(1, 3)) == -log(3) - sqrt(3)*pi/6 - EulerGamma - log(sqrt(3))
+
+
+def test_J6():
+    assert mpmath.besselj(2, 1 + 1j).ae(mpc('0.04157988694396212', '0.24739764151330632'))
+
+
+def test_J7():
+    assert simplify(besselj(R(-5,2), pi/2)) == 12/(pi**2)
+
+
+def test_J8():
+    p = besselj(R(3,2), z)
+    q = (sin(z)/z - cos(z))/sqrt(pi*z/2)
+    assert simplify(expand_func(p) -q) == 0
+
+
+def test_J9():
+    assert besselj(0, z).diff(z) == - besselj(1, z)
+
+
+def test_J10():
+    mu, nu = symbols('mu, nu', integer=True)
+    assert assoc_legendre(nu, mu, 0) == 2**mu*sqrt(pi)/gamma((nu - mu)/2 + 1)/gamma((-nu - mu + 1)/2)
+
+
+def test_J11():
+    assert simplify(assoc_legendre(3, 1, x)) == simplify(-R(3, 2)*sqrt(1 - x**2)*(5*x**2 - 1))
+
+
+@slow
+def test_J12():
+    assert simplify(chebyshevt(1008, x) - 2*x*chebyshevt(1007, x) + chebyshevt(1006, x)) == 0
+
+
+def test_J13():
+    a = symbols('a', integer=True, negative=False)
+    assert chebyshevt(a, -1) == (-1)**a
+
+
+def test_J14():
+    p = hyper([S.Half, S.Half], [R(3, 2)], z**2)
+    assert hyperexpand(p) == asin(z)/z
+
+
+@XFAIL
+def test_J15():
+    raise NotImplementedError("F((n+2)/2,-(n-2)/2,R(3,2),sin(z)**2) == sin(n*z)/(n*sin(z)*cos(z)); F(.) is hypergeometric function")
+
+
+@XFAIL
+def test_J16():
+    raise NotImplementedError("diff(zeta(x), x) @ x=0 == -log(2*pi)/2")
+
+
+def test_J17():
+    assert integrate(f((x + 2)/5)*DiracDelta((x - 2)/3) - g(x)*diff(DiracDelta(x - 1), x), (x, 0, 3)) == 3*f(R(4, 5)) + Subs(Derivative(g(x), x), x, 1)
+
+
+@XFAIL
+def test_J18():
+    raise NotImplementedError("define an antisymmetric function")
+
+
+# K. The Complex Domain
+
+def test_K1():
+    z1, z2 = symbols('z1, z2', complex=True)
+    assert re(z1 + I*z2) == -im(z2) + re(z1)
+    assert im(z1 + I*z2) == im(z1) + re(z2)
+
+
+def test_K2():
+    assert abs(3 - sqrt(7) + I*sqrt(6*sqrt(7) - 15)) == 1
+
+
+@XFAIL
+def test_K3():
+    a, b = symbols('a, b', real=True)
+    assert simplify(abs(1/(a + I/a + I*b))) == 1/sqrt(a**2 + (I/a + b)**2)
+
+
+def test_K4():
+    assert log(3 + 4*I).expand(complex=True) == log(5) + I*atan(R(4, 3))
+
+
+def test_K5():
+    x, y = symbols('x, y', real=True)
+    assert tan(x + I*y).expand(complex=True) == (sin(2*x)/(cos(2*x) +
+        cosh(2*y)) + I*sinh(2*y)/(cos(2*x) + cosh(2*y)))
+
+
+def test_K6():
+    assert sqrt(x*y*abs(z)**2)/(sqrt(x)*abs(z)) == sqrt(x*y)/sqrt(x)
+    assert sqrt(x*y*abs(z)**2)/(sqrt(x)*abs(z)) != sqrt(y)
+
+
+def test_K7():
+    y = symbols('y', real=True, negative=False)
+    expr = sqrt(x*y*abs(z)**2)/(sqrt(x)*abs(z))
+    sexpr = simplify(expr)
+    assert sexpr == sqrt(y)
+
+
+def test_K8():
+    z = symbols('z', complex=True)
+    assert simplify(sqrt(1/z) - 1/sqrt(z)) != 0  # Passes
+    z = symbols('z', complex=True, negative=False)
+    assert simplify(sqrt(1/z) - 1/sqrt(z)) == 0  # Fails
+
+
+def test_K9():
+    z = symbols('z', real=True, positive=True)
+    assert simplify(sqrt(1/z) - 1/sqrt(z)) == 0
+
+
+def test_K10():
+    z = symbols('z', real=True, negative=True)
+    assert simplify(sqrt(1/z) + 1/sqrt(z)) == 0
+
+# This goes up to K25
+
+# L. Determining Zero Equivalence
+
+
+def test_L1():
+    assert sqrt(997) - (997**3)**R(1, 6) == 0
+
+
+def test_L2():
+    assert sqrt(999983) - (999983**3)**R(1, 6) == 0
+
+
+def test_L3():
+    assert simplify((2**R(1, 3) + 4**R(1, 3))**3 - 6*(2**R(1, 3) + 4**R(1, 3)) - 6) == 0
+
+
+def test_L4():
+    assert trigsimp(cos(x)**3 + cos(x)*sin(x)**2 - cos(x)) == 0
+
+
+@XFAIL
+def test_L5():
+    assert log(tan(R(1, 2)*x + pi/4)) - asinh(tan(x)) == 0
+
+
+def test_L6():
+    assert (log(tan(x/2 + pi/4)) - asinh(tan(x))).diff(x).subs({x: 0}) == 0
+
+
+@XFAIL
+def test_L7():
+    assert simplify(log((2*sqrt(x) + 1)/(sqrt(4*x + 4*sqrt(x) + 1)))) == 0
+
+
+@XFAIL
+def test_L8():
+    assert simplify((4*x + 4*sqrt(x) + 1)**(sqrt(x)/(2*sqrt(x) + 1)) \
+        *(2*sqrt(x) + 1)**(1/(2*sqrt(x) + 1)) - 2*sqrt(x) - 1) == 0
+
+
+@XFAIL
+def test_L9():
+    z = symbols('z', complex=True)
+    assert simplify(2**(1 - z)*gamma(z)*zeta(z)*cos(z*pi/2) - pi**2*zeta(1 - z)) == 0
+
+# M. Equations
+
+
+@XFAIL
+def test_M1():
+    assert Equality(x, 2)/2 + Equality(1, 1) == Equality(x/2 + 1, 2)
+
+
+def test_M2():
+    # The roots of this equation should all be real. Note that this
+    # doesn't test that they are correct.
+    sol = solveset(3*x**3 - 18*x**2 + 33*x - 19, x)
+    assert all(s.expand(complex=True).is_real for s in sol)
+
+
+@XFAIL
+def test_M5():
+    assert solveset(x**6 - 9*x**4 - 4*x**3 + 27*x**2 - 36*x - 23, x) == FiniteSet(2**(1/3) + sqrt(3), 2**(1/3) - sqrt(3), +sqrt(3) - 1/2**(2/3) + I*sqrt(3)/2**(2/3), +sqrt(3) - 1/2**(2/3) - I*sqrt(3)/2**(2/3), -sqrt(3) - 1/2**(2/3) + I*sqrt(3)/2**(2/3), -sqrt(3) - 1/2**(2/3) - I*sqrt(3)/2**(2/3))
+
+
+def test_M6():
+    assert set(solveset(x**7 - 1, x)) == \
+        {cos(n*pi*R(2, 7)) + I*sin(n*pi*R(2, 7)) for n in range(0, 7)}
+    # The paper asks for exp terms, but sin's and cos's may be acceptable;
+    # if the results are simplified, exp terms appear for all but
+    # -sin(pi/14) - I*cos(pi/14) and -sin(pi/14) + I*cos(pi/14) which
+    # will simplify if you apply the transformation foo.rewrite(exp).expand()
+
+
+def test_M7():
+    # TODO: Replace solve with solveset, as of now test fails for solveset
+    sol = solve(x**8 - 8*x**7 + 34*x**6 - 92*x**5 + 175*x**4 - 236*x**3 +
+        226*x**2 - 140*x + 46, x)
+    assert [s.simplify() for s in sol] == [
+        1 - sqrt(-6 - 2*I*sqrt(3 + 4*sqrt(3)))/2,
+        1 + sqrt(-6 - 2*I*sqrt(3 + 4*sqrt(3)))/2,
+        1 - sqrt(-6 + 2*I*sqrt(3 + 4*sqrt(3)))/2,
+        1 + sqrt(-6 + 2*I*sqrt(3 + 4*sqrt (3)))/2,
+        1 - sqrt(-6 + 2*sqrt(-3 + 4*sqrt(3)))/2,
+        1 + sqrt(-6 + 2*sqrt(-3 + 4*sqrt(3)))/2,
+        1 - sqrt(-6 - 2*sqrt(-3 + 4*sqrt(3)))/2,
+        1 + sqrt(-6 - 2*sqrt(-3 + 4*sqrt(3)))/2]
+
+
+@XFAIL  # There are an infinite number of solutions.
+def test_M8():
+    x = Symbol('x')
+    z = symbols('z', complex=True)
+    assert solveset(exp(2*x) + 2*exp(x) + 1 - z, x, S.Reals) == \
+        FiniteSet(log(1 + z - 2*sqrt(z))/2, log(1 + z + 2*sqrt(z))/2)
+    # This one could be simplified better (the 1/2 could be pulled into the log
+    # as a sqrt, and the function inside the log can be factored as a square,
+    # giving [log(sqrt(z) - 1), log(sqrt(z) + 1)]). Also, there should be an
+    # infinite number of solutions.
+    # x = {log(sqrt(z) - 1), log(sqrt(z) + 1) + i pi} [+ n 2 pi i, + n 2 pi i]
+    # where n is an arbitrary integer.  See url of detailed output above.
+
+
+@XFAIL
+def test_M9():
+    # x = symbols('x')
+    raise NotImplementedError("solveset(exp(2-x**2)-exp(-x),x) has complex solutions.")
+
+
+def test_M10():
+    # TODO: Replace solve with solveset, as of now test fails for solveset
+    assert solve(exp(x) - x, x) == [-LambertW(-1)]
+
+
+@XFAIL
+def test_M11():
+    assert solveset(x**x - x, x) == FiniteSet(-1, 1)
+
+
+def test_M12():
+    # TODO: x = [-1, 2*(+/-asinh(1)*I + n*pi}, 3*(pi/6 + n*pi/3)]
+    # TODO: Replace solve with solveset, as of now test fails for solveset
+    assert solve((x + 1)*(sin(x)**2 + 1)**2*cos(3*x)**3, x) == [
+        -1, pi/6, pi/2,
+           - I*log(1 + sqrt(2)),      I*log(1 + sqrt(2)),
+        pi - I*log(1 + sqrt(2)), pi + I*log(1 + sqrt(2)),
+    ]
+
+
+@XFAIL
+def test_M13():
+    n = Dummy('n')
+    assert solveset_real(sin(x) - cos(x), x) == ImageSet(Lambda(n, n*pi - pi*R(7, 4)), S.Integers)
+
+
+@XFAIL
+def test_M14():
+    n = Dummy('n')
+    assert solveset_real(tan(x) - 1, x) == ImageSet(Lambda(n, n*pi + pi/4), S.Integers)
+
+
+def test_M15():
+    n = Dummy('n')
+    got = solveset(sin(x) - S.Half)
+    assert any(got.dummy_eq(i) for i in (
+        Union(ImageSet(Lambda(n, 2*n*pi + pi/6), S.Integers),
+        ImageSet(Lambda(n, 2*n*pi + pi*R(5, 6)), S.Integers)),
+        Union(ImageSet(Lambda(n, 2*n*pi + pi*R(5, 6)), S.Integers),
+        ImageSet(Lambda(n, 2*n*pi + pi/6), S.Integers))))
+
+
+@XFAIL
+def test_M16():
+    n = Dummy('n')
+    assert solveset(sin(x) - tan(x), x) == ImageSet(Lambda(n, n*pi), S.Integers)
+
+
+@XFAIL
+def test_M17():
+    assert solveset_real(asin(x) - atan(x), x) == FiniteSet(0)
+
+
+@XFAIL
+def test_M18():
+    assert solveset_real(acos(x) - atan(x), x) == FiniteSet(sqrt((sqrt(5) - 1)/2))
+
+
+def test_M19():
+    # TODO: Replace solve with solveset, as of now test fails for solveset
+    assert solve((x - 2)/x**R(1, 3), x) == [2]
+
+
+def test_M20():
+    assert solveset(sqrt(x**2 + 1) - x + 2, x) == EmptySet
+
+
+def test_M21():
+    assert solveset(x + sqrt(x) - 2) == FiniteSet(1)
+
+
+def test_M22():
+    assert solveset(2*sqrt(x) + 3*x**R(1, 4) - 2) == FiniteSet(R(1, 16))
+
+
+def test_M23():
+    x = symbols('x', complex=True)
+    # TODO: Replace solve with solveset, as of now test fails for solveset
+    assert solve(x - 1/sqrt(1 + x**2)) == [
+        -I*sqrt(S.Half + sqrt(5)/2), sqrt(Rational(-1, 2) + sqrt(5)/2)]
+
+
+def test_M24():
+    # TODO: Replace solve with solveset, as of now test fails for solveset
+    solution = solve(1 - binomial(m, 2)*2**k, k)
+    answer = log(2/(m*(m - 1)), 2)
+    assert solution[0].expand() == answer.expand()
+
+
+def test_M25():
+    a, b, c, d = symbols(':d', positive=True)
+    x = symbols('x')
+    # TODO: Replace solve with solveset, as of now test fails for solveset
+    assert solve(a*b**x - c*d**x, x)[0].expand() == (log(c/a)/log(b/d)).expand()
+
+
+def test_M26():
+    # TODO: Replace solve with solveset, as of now test fails for solveset
+    assert solve(sqrt(log(x)) - log(sqrt(x))) == [1, exp(4)]
+
+
+def test_M27():
+    x = symbols('x', real=True)
+    b = symbols('b', real=True)
+    with assuming(Q.is_true(sin(cos(1/E**2) + 1) + b > 0)):
+        # TODO: Replace solve with solveset
+        solve(log(acos(asin(x**R(2, 3) - b) - 1)) + 2, x) == [-b - sin(1 + cos(1/E**2))**R(3/2), b + sin(1 + cos(1/E**2))**R(3/2)]
+
+
+@XFAIL
+def test_M28():
+    assert solveset_real(5*x + exp((x - 5)/2) - 8*x**3, x, assume=Q.real(x)) == [-0.784966, -0.016291, 0.802557]
+
+
+def test_M29():
+    x = symbols('x')
+    assert solveset(abs(x - 1) - 2, domain=S.Reals) == FiniteSet(-1, 3)
+
+
+def test_M30():
+    # TODO: Replace solve with solveset, as of now
+    # solveset doesn't supports assumptions
+    # assert solve(abs(2*x + 5) - abs(x - 2),x, assume=Q.real(x)) == [-1, -7]
+    assert solveset_real(abs(2*x + 5) - abs(x - 2), x) == FiniteSet(-1, -7)
+
+
+def test_M31():
+    # TODO: Replace solve with solveset, as of now
+    # solveset doesn't supports assumptions
+    # assert solve(1 - abs(x) - max(-x - 2, x - 2),x, assume=Q.real(x)) == [-3/2, 3/2]
+    assert solveset_real(1 - abs(x) - Max(-x - 2, x - 2), x) == FiniteSet(R(-3, 2), R(3, 2))
+
+
+@XFAIL
+def test_M32():
+    # TODO: Replace solve with solveset, as of now
+    # solveset doesn't supports assumptions
+    assert solveset_real(Max(2 - x**2, x)- Max(-x, (x**3)/9), x) == FiniteSet(-1, 3)
+
+
+@XFAIL
+def test_M33():
+    # TODO: Replace solve with solveset, as of now
+    # solveset doesn't supports assumptions
+
+    # Second answer can be written in another form. The second answer is the root of x**3 + 9*x**2 - 18 = 0 in the interval (-2, -1).
+    assert solveset_real(Max(2 - x**2, x) - x**3/9, x) == FiniteSet(-3, -1.554894, 3)
+
+
+@XFAIL
+def test_M34():
+    z = symbols('z', complex=True)
+    assert solveset((1 + I) * z + (2 - I) * conjugate(z) + 3*I, z) == FiniteSet(2 + 3*I)
+
+
+def test_M35():
+    x, y = symbols('x y', real=True)
+    assert linsolve((3*x - 2*y - I*y + 3*I).as_real_imag(), y, x) == FiniteSet((3, 2))
+
+
+def test_M36():
+    # TODO: Replace solve with solveset, as of now
+    # solveset doesn't supports solving for function
+    # assert solve(f**2 + f - 2, x) == [Eq(f(x), 1), Eq(f(x), -2)]
+    assert solveset(f(x)**2 + f(x) - 2, f(x)) == FiniteSet(-2, 1)
+
+
+def test_M37():
+    assert linsolve([x + y + z - 6, 2*x + y + 2*z - 10, x + 3*y + z - 10 ], x, y, z) == \
+        FiniteSet((-z + 4, 2, z))
+
+
+def test_M38():
+    a, b, c = symbols('a, b, c')
+    domain = FracField([a, b, c], ZZ).to_domain()
+    ring = PolyRing('k1:50', domain)
+    (k1, k2, k3, k4, k5, k6, k7, k8, k9, k10,
+    k11, k12, k13, k14, k15, k16, k17, k18, k19, k20,
+    k21, k22, k23, k24, k25, k26, k27, k28, k29, k30,
+    k31, k32, k33, k34, k35, k36, k37, k38, k39, k40,
+    k41, k42, k43, k44, k45, k46, k47, k48, k49) = ring.gens
+
+    system = [
+        -b*k8/a + c*k8/a, -b*k11/a + c*k11/a, -b*k10/a + c*k10/a + k2, -k3 - b*k9/a + c*k9/a,
+        -b*k14/a + c*k14/a, -b*k15/a + c*k15/a, -b*k18/a + c*k18/a - k2, -b*k17/a + c*k17/a,
+        -b*k16/a + c*k16/a + k4, -b*k13/a + c*k13/a - b*k21/a + c*k21/a + b*k5/a - c*k5/a,
+        b*k44/a - c*k44/a, -b*k45/a + c*k45/a, -b*k20/a + c*k20/a, -b*k44/a + c*k44/a,
+        b*k46/a - c*k46/a, b**2*k47/a**2 - 2*b*c*k47/a**2 + c**2*k47/a**2, k3, -k4,
+        -b*k12/a + c*k12/a - a*k6/b + c*k6/b, -b*k19/a + c*k19/a + a*k7/c - b*k7/c,
+        b*k45/a - c*k45/a, -b*k46/a + c*k46/a, -k48 + c*k48/a + c*k48/b - c**2*k48/(a*b),
+        -k49 + b*k49/a + b*k49/c - b**2*k49/(a*c), a*k1/b - c*k1/b, a*k4/b - c*k4/b,
+        a*k3/b - c*k3/b + k9, -k10 + a*k2/b - c*k2/b, a*k7/b - c*k7/b, -k9, k11,
+        b*k12/a - c*k12/a + a*k6/b - c*k6/b, a*k15/b - c*k15/b, k10 + a*k18/b - c*k18/b,
+        -k11 + a*k17/b - c*k17/b, a*k16/b - c*k16/b, -a*k13/b + c*k13/b + a*k21/b - c*k21/b + a*k5/b - c*k5/b,
+        -a*k44/b + c*k44/b, a*k45/b - c*k45/b, a*k14/c - b*k14/c + a*k20/b - c*k20/b,
+        a*k44/b - c*k44/b, -a*k46/b + c*k46/b, -k47 + c*k47/a + c*k47/b - c**2*k47/(a*b),
+        a*k19/b - c*k19/b, -a*k45/b + c*k45/b, a*k46/b - c*k46/b, a**2*k48/b**2 - 2*a*c*k48/b**2 + c**2*k48/b**2,
+        -k49 + a*k49/b + a*k49/c - a**2*k49/(b*c), k16, -k17, -a*k1/c + b*k1/c,
+        -k16 - a*k4/c + b*k4/c, -a*k3/c + b*k3/c, k18 - a*k2/c + b*k2/c, b*k19/a - c*k19/a - a*k7/c + b*k7/c,
+        -a*k6/c + b*k6/c, -a*k8/c + b*k8/c, -a*k11/c + b*k11/c + k17, -a*k10/c + b*k10/c - k18,
+        -a*k9/c + b*k9/c, -a*k14/c + b*k14/c - a*k20/b + c*k20/b, -a*k13/c + b*k13/c + a*k21/c - b*k21/c - a*k5/c + b*k5/c,
+        a*k44/c - b*k44/c, -a*k45/c + b*k45/c, -a*k44/c + b*k44/c, a*k46/c - b*k46/c,
+        -k47 + b*k47/a + b*k47/c - b**2*k47/(a*c), -a*k12/c + b*k12/c, a*k45/c - b*k45/c,
+        -a*k46/c + b*k46/c, -k48 + a*k48/b + a*k48/c - a**2*k48/(b*c),
+        a**2*k49/c**2 - 2*a*b*k49/c**2 + b**2*k49/c**2, k8, k11, -k15, k10 - k18,
+        -k17, k9, -k16, -k29, k14 - k32, -k21 + k23 - k31, -k24 - k30, -k35, k44,
+        -k45, k36, k13 - k23 + k39, -k20 + k38, k25 + k37, b*k26/a - c*k26/a - k34 + k42,
+        -2*k44, k45, k46, b*k47/a - c*k47/a, k41, k44, -k46, -b*k47/a + c*k47/a,
+        k12 + k24, -k19 - k25, -a*k27/b + c*k27/b - k33, k45, -k46, -a*k48/b + c*k48/b,
+        a*k28/c - b*k28/c + k40, -k45, k46, a*k48/b - c*k48/b, a*k49/c - b*k49/c,
+        -a*k49/c + b*k49/c, -k1, -k4, -k3, k15, k18 - k2, k17, k16, k22, k25 - k7,
+        k24 + k30, k21 + k23 - k31, k28, -k44, k45, -k30 - k6, k20 + k32, k27 + b*k33/a - c*k33/a,
+        k44, -k46, -b*k47/a + c*k47/a, -k36, k31 - k39 - k5, -k32 - k38, k19 - k37,
+        k26 - a*k34/b + c*k34/b - k42, k44, -2*k45, k46, a*k48/b - c*k48/b,
+        a*k35/c - b*k35/c - k41, -k44, k46, b*k47/a - c*k47/a, -a*k49/c + b*k49/c,
+        -k40, k45, -k46, -a*k48/b + c*k48/b, a*k49/c - b*k49/c, k1, k4, k3, -k8,
+        -k11, -k10 + k2, -k9, k37 + k7, -k14 - k38, -k22, -k25 - k37, -k24 + k6,
+        -k13 - k23 + k39, -k28 + b*k40/a - c*k40/a, k44, -k45, -k27, -k44, k46,
+        b*k47/a - c*k47/a, k29, k32 + k38, k31 - k39 + k5, -k12 + k30, k35 - a*k41/b + c*k41/b,
+        -k44, k45, -k26 + k34 + a*k42/c - b*k42/c, k44, k45, -2*k46, -b*k47/a + c*k47/a,
+        -a*k48/b + c*k48/b, a*k49/c - b*k49/c, k33, -k45, k46, a*k48/b - c*k48/b,
+        -a*k49/c + b*k49/c
+        ]
+    solution = {
+        k49: 0, k48: 0, k47: 0, k46: 0, k45: 0, k44: 0, k41: 0, k40: 0,
+        k38: 0, k37: 0, k36: 0, k35: 0, k33: 0, k32: 0, k30: 0, k29: 0,
+        k28: 0, k27: 0, k25: 0, k24: 0, k22: 0, k21: 0, k20: 0, k19: 0,
+        k18: 0, k17: 0, k16: 0, k15: 0, k14: 0, k13: 0, k12: 0, k11: 0,
+        k10: 0, k9:  0, k8:  0, k7:  0, k6:  0, k5:  0, k4:  0, k3:  0,
+        k2:  0, k1:  0,
+        k34: b/c*k42, k31: k39, k26: a/c*k42, k23: k39
+    }
+    assert solve_lin_sys(system, ring) == solution
+
+
+def test_M39():
+    x, y, z = symbols('x y z', complex=True)
+    # TODO: Replace solve with solveset, as of now
+    # solveset doesn't supports non-linear multivariate
+    assert solve([x**2*y + 3*y*z - 4, -3*x**2*z + 2*y**2 + 1, 2*y*z**2 - z**2 - 1 ]) ==\
+            [{y: 1, z: 1, x: -1}, {y: 1, z: 1, x: 1},\
+             {y: sqrt(2)*I, z: R(1,3) - sqrt(2)*I/3, x: -sqrt(-1 - sqrt(2)*I)},\
+             {y: sqrt(2)*I, z: R(1,3) - sqrt(2)*I/3, x: sqrt(-1 - sqrt(2)*I)},\
+             {y: -sqrt(2)*I, z: R(1,3) + sqrt(2)*I/3, x: -sqrt(-1 + sqrt(2)*I)},\
+             {y: -sqrt(2)*I, z: R(1,3) + sqrt(2)*I/3, x: sqrt(-1 + sqrt(2)*I)}]
+
+# N. Inequalities
+
+
+def test_N1():
+    assert ask(Q.is_true(E**pi > pi**E))
+
+
+@XFAIL
+def test_N2():
+    x = symbols('x', real=True)
+    assert ask(Q.is_true(x**4 - x + 1 > 0)) is True
+    assert ask(Q.is_true(x**4 - x + 1 > 1)) is False
+
+
+@XFAIL
+def test_N3():
+    x = symbols('x', real=True)
+    assert ask(Q.is_true(And(Lt(-1, x), Lt(x, 1))), Q.is_true(abs(x) < 1 ))
+
+@XFAIL
+def test_N4():
+    x, y = symbols('x y', real=True)
+    assert ask(Q.is_true(2*x**2 > 2*y**2), Q.is_true((x > y) & (y > 0))) is True
+
+
+@XFAIL
+def test_N5():
+    x, y, k = symbols('x y k', real=True)
+    assert ask(Q.is_true(k*x**2 > k*y**2), Q.is_true((x > y) & (y > 0) & (k > 0))) is True
+
+
+@XFAIL
+def test_N6():
+    x, y, k, n = symbols('x y k n', real=True)
+    assert ask(Q.is_true(k*x**n > k*y**n), Q.is_true((x > y) & (y > 0) & (k > 0) & (n > 0))) is True
+
+
+@XFAIL
+def test_N7():
+    x, y = symbols('x y', real=True)
+    assert ask(Q.is_true(y > 0), Q.is_true((x > 1) & (y >= x - 1))) is True
+
+
+@XFAIL
+def test_N8():
+    x, y, z = symbols('x y z', real=True)
+    assert ask(Q.is_true((x == y) & (y == z)),
+               Q.is_true((x >= y) & (y >= z) & (z >= x)))
+
+
+def test_N9():
+    x = Symbol('x')
+    assert solveset(abs(x - 1) > 2, domain=S.Reals) == Union(Interval(-oo, -1, False, True),
+                                             Interval(3, oo, True))
+
+
+def test_N10():
+    x = Symbol('x')
+    p = (x - 1)*(x - 2)*(x - 3)*(x - 4)*(x - 5)
+    assert solveset(expand(p) < 0, domain=S.Reals) == Union(Interval(-oo, 1, True, True),
+                                            Interval(2, 3, True, True),
+                                            Interval(4, 5, True, True))
+
+
+def test_N11():
+    x = Symbol('x')
+    assert solveset(6/(x - 3) <= 3, domain=S.Reals) == Union(Interval(-oo, 3, True, True), Interval(5, oo))
+
+
+def test_N12():
+    x = Symbol('x')
+    assert solveset(sqrt(x) < 2, domain=S.Reals) == Interval(0, 4, False, True)
+
+
+def test_N13():
+    x = Symbol('x')
+    assert solveset(sin(x) < 2, domain=S.Reals) == S.Reals
+
+
+@XFAIL
+def test_N14():
+    x = Symbol('x')
+    # Gives 'Union(Interval(Integer(0), Mul(Rational(1, 2), pi), false, true),
+    #        Interval(Mul(Rational(1, 2), pi), Mul(Integer(2), pi), true, false))'
+    # which is not the correct answer, but the provided also seems wrong.
+    assert solveset(sin(x) < 1, x, domain=S.Reals) == Union(Interval(-oo, pi/2, True, True),
+                                         Interval(pi/2, oo, True, True))
+
+
+def test_N15():
+    r, t = symbols('r t')
+    # raises NotImplementedError: only univariate inequalities are supported
+    solveset(abs(2*r*(cos(t) - 1) + 1) <= 1, r, S.Reals)
+
+
+def test_N16():
+    r, t = symbols('r t')
+    solveset((r**2)*((cos(t) - 4)**2)*sin(t)**2 < 9, r, S.Reals)
+
+
+@XFAIL
+def test_N17():
+    # currently only univariate inequalities are supported
+    assert solveset((x + y > 0, x - y < 0), (x, y)) == (abs(x) < y)
+
+
+def test_O1():
+    M = Matrix((1 + I, -2, 3*I))
+    assert sqrt(expand(M.dot(M.H))) == sqrt(15)
+
+
+def test_O2():
+    assert Matrix((2, 2, -3)).cross(Matrix((1, 3, 1))) == Matrix([[11],
+                                                                  [-5],
+                                                                  [4]])
+
+# The vector module has no way of representing vectors symbolically (without
+# respect to a basis)
+@XFAIL
+def test_O3():
+    # assert (va ^ vb) | (vc ^ vd) == -(va | vc)*(vb | vd) + (va | vd)*(vb | vc)
+    raise NotImplementedError("""The vector module has no way of representing
+        vectors symbolically (without respect to a basis)""")
+
+def test_O4():
+    from sympy.vector import CoordSys3D, Del
+    N = CoordSys3D("N")
+    delop = Del()
+    i, j, k = N.base_vectors()
+    x, y, z = N.base_scalars()
+    F = i*(x*y*z) + j*((x*y*z)**2) + k*((y**2)*(z**3))
+    assert delop.cross(F).doit() == (-2*x**2*y**2*z + 2*y*z**3)*i + x*y*j + (2*x*y**2*z**2 - x*z)*k
+
+@XFAIL
+def test_O5():
+    #assert grad|(f^g)-g|(grad^f)+f|(grad^g)  == 0
+    raise NotImplementedError("""The vector module has no way of representing
+        vectors symbolically (without respect to a basis)""")
+
+#testO8-O9 MISSING!!
+
+
+def test_O10():
+    L = [Matrix([2, 3, 5]), Matrix([3, 6, 2]), Matrix([8, 3, 6])]
+    assert GramSchmidt(L) == [Matrix([
+                              [2],
+                              [3],
+                              [5]]),
+                              Matrix([
+                              [R(23, 19)],
+                              [R(63, 19)],
+                              [R(-47, 19)]]),
+                              Matrix([
+                              [R(1692, 353)],
+                              [R(-1551, 706)],
+                              [R(-423, 706)]])]
+
+
+def test_P1():
+    assert Matrix(3, 3, lambda i, j: j - i).diagonal(-1) == Matrix(
+        1, 2, [-1, -1])
+
+
+def test_P2():
+    M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
+    M.row_del(1)
+    M.col_del(2)
+    assert M == Matrix([[1, 2],
+                        [7, 8]])
+
+
+def test_P3():
+    A = Matrix([
+        [11, 12, 13, 14],
+        [21, 22, 23, 24],
+        [31, 32, 33, 34],
+        [41, 42, 43, 44]])
+
+    A11 = A[0:3, 1:4]
+    A12 = A[(0, 1, 3), (2, 0, 3)]
+    A21 = A
+    A221 = -A[0:2, 2:4]
+    A222 = -A[(3, 0), (2, 1)]
+    A22 = BlockMatrix([[A221, A222]]).T
+    rows = [[-A11, A12], [A21, A22]]
+    raises(ValueError, lambda: BlockMatrix(rows))
+    B = Matrix(rows)
+    assert B == Matrix([
+        [-12, -13, -14, 13, 11, 14],
+        [-22, -23, -24, 23, 21, 24],
+        [-32, -33, -34, 43, 41, 44],
+        [11, 12, 13, 14, -13, -23],
+        [21, 22, 23, 24, -14, -24],
+        [31, 32, 33, 34, -43, -13],
+        [41, 42, 43, 44, -42, -12]])
+
+
+@XFAIL
+def test_P4():
+    raise NotImplementedError("Block matrix diagonalization not supported")
+
+
+def test_P5():
+    M = Matrix([[7, 11],
+                [3, 8]])
+    assert  M % 2 == Matrix([[1, 1],
+                             [1, 0]])
+
+
+def test_P6():
+    M = Matrix([[cos(x), sin(x)],
+                [-sin(x), cos(x)]])
+    assert M.diff(x, 2) == Matrix([[-cos(x), -sin(x)],
+                                   [sin(x), -cos(x)]])
+
+
+def test_P7():
+    M = Matrix([[x, y]])*(
+        z*Matrix([[1, 3, 5],
+                  [2, 4, 6]]) + Matrix([[7, -9, 11],
+                                        [-8, 10, -12]]))
+    assert M == Matrix([[x*(z + 7) + y*(2*z - 8), x*(3*z - 9) + y*(4*z + 10),
+                         x*(5*z + 11) + y*(6*z - 12)]])
+
+
+def test_P8():
+    M = Matrix([[1, -2*I],
+                [-3*I, 4]])
+    assert M.norm(ord=S.Infinity) == 7
+
+
+def test_P9():
+    a, b, c = symbols('a b c', nonzero=True)
+    M = Matrix([[a/(b*c), 1/c, 1/b],
+                [1/c, b/(a*c), 1/a],
+                [1/b, 1/a, c/(a*b)]])
+    assert factor(M.norm('fro')) == (a**2 + b**2 + c**2)/(abs(a)*abs(b)*abs(c))
+
+
+@XFAIL
+def test_P10():
+    M = Matrix([[1, 2 + 3*I],
+                [f(4 - 5*I), 6]])
+    # conjugate(f(4 - 5*i)) is not simplified to f(4+5*I)
+    assert M.H == Matrix([[1, f(4 + 5*I)],
+                          [2 + 3*I, 6]])
+
+
+@XFAIL
+def test_P11():
+    # raises NotImplementedError("Matrix([[x,y],[1,x*y]]).inv()
+    #   not simplifying to extract common factor")
+    assert Matrix([[x, y],
+                   [1, x*y]]).inv() == (1/(x**2 - 1))*Matrix([[x, -1],
+                                                              [-1/y, x/y]])
+
+
+def test_P11_workaround():
+    # This test was changed to inverse method ADJ because it depended on the
+    # specific form of inverse returned from the 'GE' method which has changed.
+    M = Matrix([[x, y], [1, x*y]]).inv('ADJ')
+    c = gcd(tuple(M))
+    assert MatMul(c, M/c, evaluate=False) == MatMul(c, Matrix([
+        [x*y, -y],
+        [ -1,  x]]), evaluate=False)
+
+
+def test_P12():
+    A11 = MatrixSymbol('A11', n, n)
+    A12 = MatrixSymbol('A12', n, n)
+    A22 = MatrixSymbol('A22', n, n)
+    B = BlockMatrix([[A11, A12],
+                     [ZeroMatrix(n, n), A22]])
+    assert block_collapse(B.I) == BlockMatrix([[A11.I, (-1)*A11.I*A12*A22.I],
+                                               [ZeroMatrix(n, n), A22.I]])
+
+
+def test_P13():
+    M = Matrix([[1,     x - 2,                         x - 3],
+                [x - 1, x**2 - 3*x + 6,       x**2 - 3*x - 2],
+                [x - 2, x**2 - 8,       2*(x**2) - 12*x + 14]])
+    L, U, _ = M.LUdecomposition()
+    assert simplify(L) == Matrix([[1,     0,     0],
+                                  [x - 1, 1,     0],
+                                  [x - 2, x - 3, 1]])
+    assert simplify(U) == Matrix([[1, x - 2, x - 3],
+                                  [0,     4, x - 5],
+                                  [0,     0, x - 7]])
+
+
+def test_P14():
+    M = Matrix([[1, 2, 3, 1, 3],
+                [3, 2, 1, 1, 7],
+                [0, 2, 4, 1, 1],
+                [1, 1, 1, 1, 4]])
+    R, _ = M.rref()
+    assert R == Matrix([[1, 0, -1, 0,  2],
+                        [0, 1,  2, 0, -1],
+                        [0, 0,  0, 1,  3],
+                        [0, 0,  0, 0,  0]])
+
+
+def test_P15():
+    M = Matrix([[-1, 3,  7, -5],
+                [4, -2,  1,  3],
+                [2,  4, 15, -7]])
+    assert M.rank() == 2
+
+
+def test_P16():
+    M = Matrix([[2*sqrt(2), 8],
+                [6*sqrt(6), 24*sqrt(3)]])
+    assert M.rank() == 1
+
+
+def test_P17():
+    t = symbols('t', real=True)
+    M=Matrix([
+        [sin(2*t), cos(2*t)],
+        [2*(1 - (cos(t)**2))*cos(t), (1 - 2*(sin(t)**2))*sin(t)]])
+    assert M.rank() == 1
+
+
+def test_P18():
+    M = Matrix([[1,  0, -2, 0],
+                [-2, 1,  0, 3],
+                [-1, 2, -6, 6]])
+    assert M.nullspace() == [Matrix([[2],
+                                     [4],
+                                     [1],
+                                     [0]]),
+                             Matrix([[0],
+                                     [-3],
+                                     [0],
+                                     [1]])]
+
+
+def test_P19():
+    w = symbols('w')
+    M = Matrix([[1,    1,    1,    1],
+                [w,    x,    y,    z],
+                [w**2, x**2, y**2, z**2],
+                [w**3, x**3, y**3, z**3]])
+    assert M.det() == (w**3*x**2*y   - w**3*x**2*z - w**3*x*y**2 + w**3*x*z**2
+                       + w**3*y**2*z - w**3*y*z**2 - w**2*x**3*y + w**2*x**3*z
+                       + w**2*x*y**3 - w**2*x*z**3 - w**2*y**3*z + w**2*y*z**3
+                       + w*x**3*y**2 - w*x**3*z**2 - w*x**2*y**3 + w*x**2*z**3
+                       + w*y**3*z**2 - w*y**2*z**3 - x**3*y**2*z + x**3*y*z**2
+                       + x**2*y**3*z - x**2*y*z**3 - x*y**3*z**2 + x*y**2*z**3
+                       )
+
+
+@XFAIL
+def test_P20():
+    raise NotImplementedError("Matrix minimal polynomial not supported")
+
+
+def test_P21():
+    M = Matrix([[5, -3, -7],
+                [-2, 1,  2],
+                [2, -3, -4]])
+    assert M.charpoly(x).as_expr() == x**3 - 2*x**2 - 5*x + 6
+
+
+def test_P22():
+    d = 100
+    M = (2 - x)*eye(d)
+    assert M.eigenvals() == {-x + 2: d}
+
+
+def test_P23():
+    M = Matrix([
+        [2, 1, 0, 0, 0],
+        [1, 2, 1, 0, 0],
+        [0, 1, 2, 1, 0],
+        [0, 0, 1, 2, 1],
+        [0, 0, 0, 1, 2]])
+    assert M.eigenvals() == {
+        S('1'): 1,
+        S('2'): 1,
+        S('3'): 1,
+        S('sqrt(3) + 2'): 1,
+        S('-sqrt(3) + 2'): 1}
+
+
+def test_P24():
+    M = Matrix([[611,  196, -192,  407,   -8,  -52,  -49,   29],
+                [196,  899,  113, -192,  -71,  -43,   -8,  -44],
+                [-192,  113,  899,  196,   61,   49,    8,   52],
+                [ 407, -192,  196,  611,    8,   44,   59,  -23],
+                [  -8,  -71,   61,    8,  411, -599,  208,  208],
+                [ -52,  -43,   49,   44, -599,  411,  208,  208],
+                [ -49,   -8,    8,   59,  208,  208,   99, -911],
+                [  29,  -44,   52,  -23,  208,  208, -911,   99]])
+    assert M.eigenvals() == {
+        S('0'): 1,
+        S('10*sqrt(10405)'): 1,
+        S('100*sqrt(26) + 510'): 1,
+        S('1000'): 2,
+        S('-100*sqrt(26) + 510'): 1,
+        S('-10*sqrt(10405)'): 1,
+        S('1020'): 1}
+
+
+def test_P25():
+    MF = N(Matrix([[ 611,  196, -192,  407,   -8,  -52,  -49,   29],
+                   [ 196,  899,  113, -192,  -71,  -43,   -8,  -44],
+                   [-192,  113,  899,  196,   61,   49,    8,   52],
+                   [ 407, -192,  196,  611,    8,   44,   59,  -23],
+                   [  -8,  -71,   61,    8,  411, -599,  208,  208],
+                   [ -52,  -43,   49,   44, -599,  411,  208,  208],
+                   [ -49,   -8,    8,   59,  208,  208,   99, -911],
+                   [  29,  -44,   52,  -23,  208,  208, -911,   99]]))
+
+    ev_1 = sorted(MF.eigenvals(multiple=True))
+    ev_2 = sorted(
+        [-1020.0490184299969, 0.0, 0.09804864072151699, 1000.0, 1000.0,
+        1019.9019513592784, 1020.0, 1020.0490184299969])
+
+    for x, y in zip(ev_1, ev_2):
+        assert abs(x - y) < 1e-12
+
+
+def test_P26():
+    a0, a1, a2, a3, a4 = symbols('a0 a1 a2 a3 a4')
+    M = Matrix([[-a4, -a3, -a2, -a1, -a0,  0,  0,  0,  0],
+                [  1,   0,   0,   0,   0,  0,  0,  0,  0],
+                [  0,   1,   0,   0,   0,  0,  0,  0,  0],
+                [  0,   0,   1,   0,   0,  0,  0,  0,  0],
+                [  0,   0,   0,   1,   0,  0,  0,  0,  0],
+                [  0,   0,   0,   0,   0, -1, -1,  0,  0],
+                [  0,   0,   0,   0,   0,  1,  0,  0,  0],
+                [  0,   0,   0,   0,   0,  0,  1, -1, -1],
+                [  0,   0,   0,   0,   0,  0,  0,  1,  0]])
+    assert M.eigenvals(error_when_incomplete=False) == {
+        S('-1/2 - sqrt(3)*I/2'): 2,
+        S('-1/2 + sqrt(3)*I/2'): 2}
+
+
+def test_P27():
+    a = symbols('a')
+    M = Matrix([[a,  0, 0, 0, 0],
+                [0,  0, 0, 0, 1],
+                [0,  0, a, 0, 0],
+                [0,  0, 0, a, 0],
+                [0, -2, 0, 0, 2]])
+
+    assert M.eigenvects() == [
+        (a, 3, [
+            Matrix([1, 0, 0, 0, 0]),
+            Matrix([0, 0, 1, 0, 0]),
+            Matrix([0, 0, 0, 1, 0])
+        ]),
+        (1 - I, 1, [
+            Matrix([0, (1 + I)/2, 0, 0, 1])
+        ]),
+        (1 + I, 1, [
+            Matrix([0, (1 - I)/2, 0, 0, 1])
+        ]),
+    ]
+
+
+@XFAIL
+def test_P28():
+    raise NotImplementedError("Generalized eigenvectors not supported \
+https://github.com/sympy/sympy/issues/5293")
+
+
+@XFAIL
+def test_P29():
+    raise NotImplementedError("Generalized eigenvectors not supported \
+https://github.com/sympy/sympy/issues/5293")
+
+
+def test_P30():
+    M = Matrix([[1,  0,  0,  1, -1],
+                [0,  1, -2,  3, -3],
+                [0,  0, -1,  2, -2],
+                [1, -1,  1,  0,  1],
+                [1, -1,  1, -1,  2]])
+    _, J = M.jordan_form()
+    assert J == Matrix([[-1, 0, 0, 0, 0],
+                        [0,  1, 1, 0, 0],
+                        [0,  0, 1, 0, 0],
+                        [0,  0, 0, 1, 1],
+                        [0,  0, 0, 0, 1]])
+
+
+@XFAIL
+def test_P31():
+    raise NotImplementedError("Smith normal form not implemented")
+
+
+def test_P32():
+    M = Matrix([[1, -2],
+                [2, 1]])
+    assert exp(M).rewrite(cos).simplify() == Matrix([[E*cos(2), -E*sin(2)],
+                                                     [E*sin(2),  E*cos(2)]])
+
+
+def test_P33():
+    w, t = symbols('w t')
+    M = Matrix([[0,    1,      0,   0],
+                [0,    0,      0, 2*w],
+                [0,    0,      0,   1],
+                [0, -2*w, 3*w**2,   0]])
+    assert exp(M*t).rewrite(cos).expand() == Matrix([
+        [1, -3*t + 4*sin(t*w)/w,  6*t*w - 6*sin(t*w), -2*cos(t*w)/w + 2/w],
+        [0,      4*cos(t*w) - 3, -6*w*cos(t*w) + 6*w,          2*sin(t*w)],
+        [0,  2*cos(t*w)/w - 2/w,     -3*cos(t*w) + 4,          sin(t*w)/w],
+        [0,         -2*sin(t*w),        3*w*sin(t*w),            cos(t*w)]])
+
+
+@XFAIL
+def test_P34():
+    a, b, c = symbols('a b c', real=True)
+    M = Matrix([[a, 1, 0, 0, 0, 0],
+                [0, a, 0, 0, 0, 0],
+                [0, 0, b, 0, 0, 0],
+                [0, 0, 0, c, 1, 0],
+                [0, 0, 0, 0, c, 1],
+                [0, 0, 0, 0, 0, c]])
+    # raises exception, sin(M) not supported. exp(M*I) also not supported
+    # https://github.com/sympy/sympy/issues/6218
+    assert sin(M) == Matrix([[sin(a), cos(a), 0, 0, 0, 0],
+                             [0, sin(a), 0, 0, 0, 0],
+                             [0, 0, sin(b), 0, 0, 0],
+                             [0, 0, 0, sin(c), cos(c), -sin(c)/2],
+                             [0, 0, 0, 0, sin(c), cos(c)],
+                             [0, 0, 0, 0, 0, sin(c)]])
+
+
+@XFAIL
+def test_P35():
+    M = pi/2*Matrix([[2, 1, 1],
+                     [2, 3, 2],
+                     [1, 1, 2]])
+    # raises exception, sin(M) not supported. exp(M*I) also not supported
+    # https://github.com/sympy/sympy/issues/6218
+    assert sin(M) == eye(3)
+
+
+@XFAIL
+def test_P36():
+    M = Matrix([[10, 7],
+                [7, 17]])
+    assert sqrt(M) == Matrix([[3, 1],
+                              [1, 4]])
+
+
+def test_P37():
+    M = Matrix([[1, 1, 0],
+                [0, 1, 0],
+                [0, 0, 1]])
+    assert M**S.Half == Matrix([[1, R(1, 2), 0],
+                                        [0, 1,       0],
+                                        [0, 0,       1]])
+
+
+@XFAIL
+def test_P38():
+    M=Matrix([[0, 1, 0],
+              [0, 0, 0],
+              [0, 0, 0]])
+    #raises ValueError: Matrix det == 0; not invertible
+    M**S.Half
+
+
+@XFAIL
+def test_P39():
+    """
+    M=Matrix([
+        [1, 1],
+        [2, 2],
+        [3, 3]])
+    M.SVD()
+    """
+    raise NotImplementedError("Singular value decomposition not implemented")
+
+
+def test_P40():
+    r, t = symbols('r t', real=True)
+    M = Matrix([r*cos(t), r*sin(t)])
+    assert M.jacobian(Matrix([r, t])) == Matrix([[cos(t), -r*sin(t)],
+                                                 [sin(t),  r*cos(t)]])
+
+
+def test_P41():
+    r, t = symbols('r t', real=True)
+    assert hessian(r**2*sin(t),(r,t)) == Matrix([[  2*sin(t),   2*r*cos(t)],
+                                                 [2*r*cos(t), -r**2*sin(t)]])
+
+
+def test_P42():
+    assert wronskian([cos(x), sin(x)], x).simplify() == 1
+
+
+def test_P43():
+    def __my_jacobian(M, Y):
+        return Matrix([M.diff(v).T for v in Y]).T
+    r, t = symbols('r t', real=True)
+    M = Matrix([r*cos(t), r*sin(t)])
+    assert __my_jacobian(M,[r,t]) == Matrix([[cos(t), -r*sin(t)],
+                                             [sin(t),  r*cos(t)]])
+
+
+def test_P44():
+    def __my_hessian(f, Y):
+        V = Matrix([diff(f, v) for v in Y])
+        return  Matrix([V.T.diff(v) for v in Y])
+    r, t = symbols('r t', real=True)
+    assert __my_hessian(r**2*sin(t), (r, t)) == Matrix([
+                                            [  2*sin(t),   2*r*cos(t)],
+                                            [2*r*cos(t), -r**2*sin(t)]])
+
+
+def test_P45():
+    def __my_wronskian(Y, v):
+        M = Matrix([Matrix(Y).T.diff(x, n) for n in range(0, len(Y))])
+        return  M.det()
+    assert __my_wronskian([cos(x), sin(x)], x).simplify() == 1
+
+# Q1-Q6  Tensor tests missing
+
+
+@XFAIL
+def test_R1():
+    i, j, n = symbols('i j n', integer=True, positive=True)
+    xn = MatrixSymbol('xn', n, 1)
+    Sm = Sum((xn[i, 0] - Sum(xn[j, 0], (j, 0, n - 1))/n)**2, (i, 0, n - 1))
+    # sum does not calculate
+    # Unknown result
+    Sm.doit()
+    raise NotImplementedError('Unknown result')
+
+@XFAIL
+def test_R2():
+    m, b = symbols('m b')
+    i, n = symbols('i n', integer=True, positive=True)
+    xn = MatrixSymbol('xn', n, 1)
+    yn = MatrixSymbol('yn', n, 1)
+    f = Sum((yn[i, 0] - m*xn[i, 0] - b)**2, (i, 0, n - 1))
+    f1 = diff(f, m)
+    f2 = diff(f, b)
+    # raises TypeError: solveset() takes at most 2 arguments (3 given)
+    solveset((f1, f2), (m, b), domain=S.Reals)
+
+
+@XFAIL
+def test_R3():
+    n, k = symbols('n k', integer=True, positive=True)
+    sk = ((-1)**k) * (binomial(2*n, k))**2
+    Sm = Sum(sk, (k, 1, oo))
+    T = Sm.doit()
+    T2 = T.combsimp()
+    # returns -((-1)**n*factorial(2*n)
+    #           - (factorial(n))**2)*exp_polar(-I*pi)/(factorial(n))**2
+    assert T2 == (-1)**n*binomial(2*n, n)
+
+
+@XFAIL
+def test_R4():
+# Macsyma indefinite sum test case:
+#(c15) /* Check whether the full Gosper algorithm is implemented
+#   => 1/2^(n + 1) binomial(n, k - 1) */
+#closedform(indefsum(binomial(n, k)/2^n - binomial(n + 1, k)/2^(n + 1), k));
+#Time= 2690 msecs
+#                      (- n + k - 1) binomial(n + 1, k)
+#(d15)               - --------------------------------
+#                                     n
+#                                   2 2  (n + 1)
+#
+#(c16) factcomb(makefact(%));
+#Time= 220 msecs
+#                                 n!
+#(d16)                     ----------------
+#                                n
+#                          2 k! 2  (n - k)!
+# Might be possible after fixing https://github.com/sympy/sympy/pull/1879
+    raise NotImplementedError("Indefinite sum not supported")
+
+
+@XFAIL
+def test_R5():
+    a, b, c, n, k = symbols('a b c n k', integer=True, positive=True)
+    sk = ((-1)**k)*(binomial(a + b, a + k)
+                    *binomial(b + c, b + k)*binomial(c + a, c + k))
+    Sm = Sum(sk, (k, 1, oo))
+    T = Sm.doit()  # hypergeometric series not calculated
+    assert T == factorial(a+b+c)/(factorial(a)*factorial(b)*factorial(c))
+
+
+def test_R6():
+    n, k = symbols('n k', integer=True, positive=True)
+    gn = MatrixSymbol('gn', n + 2, 1)
+    Sm = Sum(gn[k, 0] - gn[k - 1, 0], (k, 1, n + 1))
+    assert Sm.doit() == -gn[0, 0] + gn[n + 1, 0]
+
+
+def test_R7():
+    n, k = symbols('n k', integer=True, positive=True)
+    T = Sum(k**3,(k,1,n)).doit()
+    assert T.factor() == n**2*(n + 1)**2/4
+
+@XFAIL
+def test_R8():
+    n, k = symbols('n k', integer=True, positive=True)
+    Sm = Sum(k**2*binomial(n, k), (k, 1, n))
+    T = Sm.doit() #returns Piecewise function
+    assert T.combsimp() == n*(n + 1)*2**(n - 2)
+
+
+def test_R9():
+    n, k = symbols('n k', integer=True, positive=True)
+    Sm = Sum(binomial(n, k - 1)/k, (k, 1, n + 1))
+    assert Sm.doit().simplify() == (2**(n + 1) - 1)/(n + 1)
+
+
+@XFAIL
+def test_R10():
+    n, m, r, k = symbols('n m r k', integer=True, positive=True)
+    Sm = Sum(binomial(n, k)*binomial(m, r - k), (k, 0, r))
+    T = Sm.doit()
+    T2 = T.combsimp().rewrite(factorial)
+    assert T2 == factorial(m + n)/(factorial(r)*factorial(m + n - r))
+    assert T2 == binomial(m + n, r).rewrite(factorial)
+    # rewrite(binomial) is not working.
+    # https://github.com/sympy/sympy/issues/7135
+    T3 = T2.rewrite(binomial)
+    assert T3 == binomial(m + n, r)
+
+
+@XFAIL
+def test_R11():
+    n, k = symbols('n k', integer=True, positive=True)
+    sk = binomial(n, k)*fibonacci(k)
+    Sm = Sum(sk, (k, 0, n))
+    T = Sm.doit()
+    # Fibonacci simplification not implemented
+    # https://github.com/sympy/sympy/issues/7134
+    assert T == fibonacci(2*n)
+
+
+@XFAIL
+def test_R12():
+    n, k = symbols('n k', integer=True, positive=True)
+    Sm = Sum(fibonacci(k)**2, (k, 0, n))
+    T = Sm.doit()
+    assert T == fibonacci(n)*fibonacci(n + 1)
+
+
+@XFAIL
+def test_R13():
+    n, k = symbols('n k', integer=True, positive=True)
+    Sm = Sum(sin(k*x), (k, 1, n))
+    T = Sm.doit()  # Sum is not calculated
+    assert T.simplify() == cot(x/2)/2 - cos(x*(2*n + 1)/2)/(2*sin(x/2))
+
+
+@XFAIL
+def test_R14():
+    n, k = symbols('n k', integer=True, positive=True)
+    Sm = Sum(sin((2*k - 1)*x), (k, 1, n))
+    T = Sm.doit()  # Sum is not calculated
+    assert T.simplify() == sin(n*x)**2/sin(x)
+
+
+@XFAIL
+def test_R15():
+    n, k = symbols('n k', integer=True, positive=True)
+    Sm = Sum(binomial(n - k, k), (k, 0, floor(n/2)))
+    T = Sm.doit()  # Sum is not calculated
+    assert T.simplify() == fibonacci(n + 1)
+
+
+def test_R16():
+    k = symbols('k', integer=True, positive=True)
+    Sm = Sum(1/k**2 + 1/k**3, (k, 1, oo))
+    assert Sm.doit() == zeta(3) + pi**2/6
+
+
+def test_R17():
+    k = symbols('k', integer=True, positive=True)
+    assert abs(float(Sum(1/k**2 + 1/k**3, (k, 1, oo)))
+               - 2.8469909700078206) < 1e-15
+
+
+def test_R18():
+    k = symbols('k', integer=True, positive=True)
+    Sm = Sum(1/(2**k*k**2), (k, 1, oo))
+    T = Sm.doit()
+    assert T.simplify() == -log(2)**2/2 + pi**2/12
+
+
+@slow
+@XFAIL
+def test_R19():
+    k = symbols('k', integer=True, positive=True)
+    Sm = Sum(1/((3*k + 1)*(3*k + 2)*(3*k + 3)), (k, 0, oo))
+    T = Sm.doit()
+    # assert fails, T not  simplified
+    assert T.simplify() == -log(3)/4 + sqrt(3)*pi/12
+
+
+@XFAIL
+def test_R20():
+    n, k = symbols('n k', integer=True, positive=True)
+    Sm = Sum(binomial(n, 4*k), (k, 0, oo))
+    T = Sm.doit()
+    # assert fails, T not  simplified
+    assert T.simplify() == 2**(n/2)*cos(pi*n/4)/2 + 2**(n - 1)/2
+
+
+@XFAIL
+def test_R21():
+    k = symbols('k', integer=True, positive=True)
+    Sm = Sum(1/(sqrt(k*(k + 1)) * (sqrt(k) + sqrt(k + 1))), (k, 1, oo))
+    T = Sm.doit()  # Sum not calculated
+    assert T.simplify() == 1
+
+
+# test_R22 answer not available in Wester samples
+# Sum(Sum(binomial(n, k)*binomial(n - k, n - 2*k)*x**n*y**(n - 2*k),
+#                 (k, 0, floor(n/2))), (n, 0, oo)) with abs(x*y)<1?
+
+
+@XFAIL
+def test_R23():
+    n, k = symbols('n k', integer=True, positive=True)
+    Sm = Sum(Sum((factorial(n)/(factorial(k)**2*factorial(n - 2*k)))*
+                 (x/y)**k*(x*y)**(n - k), (n, 2*k, oo)), (k, 0, oo))
+    # Missing how to express constraint abs(x*y)<1?
+    T = Sm.doit()  # Sum not calculated
+    assert T == -1/sqrt(x**2*y**2 - 4*x**2 - 2*x*y + 1)
+
+
+def test_R24():
+    m, k = symbols('m k', integer=True, positive=True)
+    Sm = Sum(Product(k/(2*k - 1), (k, 1, m)), (m, 2, oo))
+    assert Sm.doit() == pi/2
+
+
+def test_S1():
+    k = symbols('k', integer=True, positive=True)
+    Pr = Product(gamma(k/3), (k, 1, 8))
+    assert Pr.doit().simplify() == 640*sqrt(3)*pi**3/6561
+
+
+def test_S2():
+    n, k = symbols('n k', integer=True, positive=True)
+    assert Product(k, (k, 1, n)).doit() == factorial(n)
+
+
+def test_S3():
+    n, k = symbols('n k', integer=True, positive=True)
+    assert Product(x**k, (k, 1, n)).doit().simplify() == x**(n*(n + 1)/2)
+
+
+def test_S4():
+    n, k = symbols('n k', integer=True, positive=True)
+    assert Product(1 + 1/k, (k, 1, n -1)).doit().simplify() == n
+
+
+def test_S5():
+    n, k = symbols('n k', integer=True, positive=True)
+    assert (Product((2*k - 1)/(2*k), (k, 1, n)).doit().gammasimp() ==
+            gamma(n + S.Half)/(sqrt(pi)*gamma(n + 1)))
+
+
+@XFAIL
+def test_S6():
+    n, k = symbols('n k', integer=True, positive=True)
+    # Product does not evaluate
+    assert (Product(x**2 -2*x*cos(k*pi/n) + 1, (k, 1, n - 1)).doit().simplify()
+            == (x**(2*n) - 1)/(x**2 - 1))
+
+
+@XFAIL
+def test_S7():
+    k = symbols('k', integer=True, positive=True)
+    Pr = Product((k**3 - 1)/(k**3 + 1), (k, 2, oo))
+    T = Pr.doit()     # Product does not evaluate
+    assert T.simplify() == R(2, 3)
+
+
+@XFAIL
+def test_S8():
+    k = symbols('k', integer=True, positive=True)
+    Pr = Product(1 - 1/(2*k)**2, (k, 1, oo))
+    T = Pr.doit()
+    # Product does not evaluate
+    assert T.simplify() == 2/pi
+
+
+@XFAIL
+def test_S9():
+    k = symbols('k', integer=True, positive=True)
+    Pr = Product(1 + (-1)**(k + 1)/(2*k - 1), (k, 1, oo))
+    T = Pr.doit()
+    # Product produces 0
+    # https://github.com/sympy/sympy/issues/7133
+    assert T.simplify() == sqrt(2)
+
+
+@XFAIL
+def test_S10():
+    k = symbols('k', integer=True, positive=True)
+    Pr = Product((k*(k + 1) + 1 + I)/(k*(k + 1) + 1 - I), (k, 0, oo))
+    T = Pr.doit()
+    # Product does not evaluate
+    assert T.simplify() == -1
+
+
+def test_T1():
+    assert limit((1 + 1/n)**n, n, oo) == E
+    assert limit((1 - cos(x))/x**2, x, 0) == S.Half
+
+
+def test_T2():
+    assert limit((3**x + 5**x)**(1/x), x, oo) == 5
+
+
+def test_T3():
+    assert limit(log(x)/(log(x) + sin(x)), x, oo) == 1
+
+
+def test_T4():
+    assert limit((exp(x*exp(-x)/(exp(-x) + exp(-2*x**2/(x + 1))))
+                 - exp(x))/x, x, oo) == -exp(2)
+
+
+def test_T5():
+    assert  limit(x*log(x)*log(x*exp(x) - x**2)**2/log(log(x**2
+                  + 2*exp(exp(3*x**3*log(x))))), x, oo) == R(1, 3)
+
+
+def test_T6():
+    assert limit(1/n * factorial(n)**(1/n), n, oo) == exp(-1)
+
+
+def test_T7():
+    limit(1/n * gamma(n + 1)**(1/n), n, oo)
+
+
+def test_T8():
+    a, z = symbols('a z', real=True, positive=True)
+    assert limit(gamma(z + a)/gamma(z)*exp(-a*log(z)), z, oo) == 1
+
+
+@XFAIL
+def test_T9():
+    z, k = symbols('z k', real=True, positive=True)
+    # raises NotImplementedError:
+    #           Don't know how to calculate the mrv of '(1, k)'
+    assert limit(hyper((1, k), (1,), z/k), k, oo) == exp(z)
+
+
+@XFAIL
+def test_T10():
+    # No longer raises PoleError, but should return euler-mascheroni constant
+    assert limit(zeta(x) - 1/(x - 1), x, 1) == integrate(-1/x + 1/floor(x), (x, 1, oo))
+
+@XFAIL
+def test_T11():
+    n, k = symbols('n k', integer=True, positive=True)
+    # evaluates to 0
+    assert limit(n**x/(x*product((1 + x/k), (k, 1, n))), n, oo) == gamma(x)
+
+
+def test_T12():
+    x, t = symbols('x t', real=True)
+    # Does not evaluate the limit but returns an expression with erf
+    assert limit(x * integrate(exp(-t**2), (t, 0, x))/(1 - exp(-x**2)),
+                 x, 0) == 1
+
+
+def test_T13():
+    x = symbols('x', real=True)
+    assert [limit(x/abs(x), x, 0, dir='-'),
+            limit(x/abs(x), x, 0, dir='+')] == [-1, 1]
+
+
+def test_T14():
+    x = symbols('x', real=True)
+    assert limit(atan(-log(x)), x, 0, dir='+') == pi/2
+
+
+def test_U1():
+    x = symbols('x', real=True)
+    assert diff(abs(x), x) == sign(x)
+
+
+def test_U2():
+    f = Lambda(x, Piecewise((-x, x < 0), (x, x >= 0)))
+    assert diff(f(x), x) == Piecewise((-1, x < 0), (1, x >= 0))
+
+
+def test_U3():
+    f = Lambda(x, Piecewise((x**2 - 1, x == 1), (x**3, x != 1)))
+    f1 = Lambda(x, diff(f(x), x))
+    assert f1(x) == 3*x**2
+    assert f1(1) == 3
+
+
+@XFAIL
+def test_U4():
+    n = symbols('n', integer=True, positive=True)
+    x = symbols('x', real=True)
+    d = diff(x**n, x, n)
+    assert d.rewrite(factorial) == factorial(n)
+
+
+def test_U5():
+    # issue 6681
+    t = symbols('t')
+    ans = (
+        Derivative(f(g(t)), g(t))*Derivative(g(t), (t, 2)) +
+        Derivative(f(g(t)), (g(t), 2))*Derivative(g(t), t)**2)
+    assert f(g(t)).diff(t, 2) == ans
+    assert ans.doit() == ans
+
+
+def test_U6():
+    h = Function('h')
+    T = integrate(f(y), (y, h(x), g(x)))
+    assert T.diff(x) == (
+        f(g(x))*Derivative(g(x), x) - f(h(x))*Derivative(h(x), x))
+
+
+@XFAIL
+def test_U7():
+    p, t = symbols('p t', real=True)
+    # Exact differential => d(V(P, T)) => dV/dP DP + dV/dT DT
+    # raises ValueError:  Since there is more than one variable in the
+    # expression, the variable(s) of differentiation must be supplied to
+    # differentiate f(p,t)
+    diff(f(p, t))
+
+
+def test_U8():
+    x, y = symbols('x y', real=True)
+    eq = cos(x*y) + x
+    #  If SymPy had implicit_diff() function this hack could be avoided
+    # TODO: Replace solve with solveset, current test fails for solveset
+    assert idiff(y - eq, y, x) == (-y*sin(x*y) + 1)/(x*sin(x*y) + 1)
+
+
+def test_U9():
+    # Wester sample case for Maple:
+    # O29 := diff(f(x, y), x) + diff(f(x, y), y);
+    #                      /d         \   /d         \
+    #                      |-- f(x, y)| + |-- f(x, y)|
+    #                      \dx        /   \dy        /
+    #
+    # O30 := factor(subs(f(x, y) = g(x^2 + y^2), %));
+    #                                2    2
+    #                        2 D(g)(x  + y ) (x + y)
+    x, y = symbols('x y', real=True)
+    su = diff(f(x, y), x) + diff(f(x, y), y)
+    s2 = su.subs(f(x, y), g(x**2 + y**2))
+    s3 = s2.doit().factor()
+    # Subs not performed, s3 = 2*(x + y)*Subs(Derivative(
+    #   g(_xi_1), _xi_1), _xi_1, x**2 + y**2)
+    # Derivative(g(x*2 + y**2), x**2 + y**2) is not valid in SymPy,
+    # and probably will remain that way. You can take derivatives with respect
+    # to other expressions only if they are atomic, like a symbol or a
+    # function.
+    # D operator should be added to SymPy
+    # See https://github.com/sympy/sympy/issues/4719.
+    assert s3 == (x + y)*Subs(Derivative(g(x), x), x, x**2 + y**2)*2
+
+
+def test_U10():
+    # see issue 2519:
+    assert residue((z**3 + 5)/((z**4 - 1)*(z + 1)), z, -1) == R(-9, 4)
+
+@XFAIL
+def test_U11():
+    # assert (2*dx + dz) ^ (3*dx + dy + dz) ^ (dx + dy + 4*dz) == 8*dx ^ dy ^dz
+    raise NotImplementedError
+
+
+@XFAIL
+def test_U12():
+    # Wester sample case:
+    # (c41) /* d(3 x^5 dy /\ dz + 5 x y^2 dz /\ dx + 8 z dx /\ dy)
+    #    => (15 x^4 + 10 x y + 8) dx /\ dy /\ dz */
+    # factor(ext_diff(3*x^5 * dy ~ dz + 5*x*y^2 * dz ~ dx + 8*z * dx ~ dy));
+    #                      4
+    # (d41)              (10 x y + 15 x  + 8) dx dy dz
+    raise NotImplementedError(
+        "External diff of differential form not supported")
+
+
+def test_U13():
+    assert minimum(x**4 - x + 1, x) == -3*2**R(1,3)/8 + 1
+
+
+@XFAIL
+def test_U14():
+    #f = 1/(x**2 + y**2 + 1)
+    #assert [minimize(f), maximize(f)] == [0,1]
+    raise NotImplementedError("minimize(), maximize() not supported")
+
+
+@XFAIL
+def test_U15():
+    raise NotImplementedError("minimize() not supported and also solve does \
+not support multivariate inequalities")
+
+
+@XFAIL
+def test_U16():
+    raise NotImplementedError("minimize() not supported in SymPy and also \
+solve does not support multivariate inequalities")
+
+
+@XFAIL
+def test_U17():
+    raise NotImplementedError("Linear programming, symbolic simplex not \
+supported in SymPy")
+
+
+def test_V1():
+    x = symbols('x', real=True)
+    assert integrate(abs(x), x) == Piecewise((-x**2/2, x <= 0), (x**2/2, True))
+
+
+def test_V2():
+    assert integrate(Piecewise((-x, x < 0), (x, x >= 0)), x
+        ) == Piecewise((-x**2/2, x < 0), (x**2/2, True))
+
+
+def test_V3():
+    assert integrate(1/(x**3 + 2),x).diff().simplify() == 1/(x**3 + 2)
+
+
+def test_V4():
+    assert integrate(2**x/sqrt(1 + 4**x), x) == asinh(2**x)/log(2)
+
+
+@XFAIL
+def test_V5():
+    # Returns (-45*x**2 + 80*x - 41)/(5*sqrt(2*x - 1)*(4*x**2 - 4*x + 1))
+    assert (integrate((3*x - 5)**2/(2*x - 1)**R(7, 2), x).simplify() ==
+            (-41 + 80*x - 45*x**2)/(5*(2*x - 1)**R(5, 2)))
+
+
+@XFAIL
+def test_V6():
+    # returns RootSum(40*_z**2 - 1, Lambda(_i, _i*log(-4*_i + exp(-m*x))))/m
+    assert (integrate(1/(2*exp(m*x) - 5*exp(-m*x)), x) == sqrt(10)*(
+            log(2*exp(m*x) - sqrt(10)) - log(2*exp(m*x) + sqrt(10)))/(20*m))
+
+
+def test_V7():
+    r1 = integrate(sinh(x)**4/cosh(x)**2)
+    assert r1.simplify() == x*R(-3, 2) + sinh(x)**3/(2*cosh(x)) + 3*tanh(x)/2
+
+
+@XFAIL
+def test_V8_V9():
+#Macsyma test case:
+#(c27) /* This example involves several symbolic parameters
+#   => 1/sqrt(b^2 - a^2) log([sqrt(b^2 - a^2) tan(x/2) + a + b]/
+#                            [sqrt(b^2 - a^2) tan(x/2) - a - b])   (a^2 < b^2)
+#      [Gradshteyn and Ryzhik 2.553(3)] */
+#assume(b^2 > a^2)$
+#(c28) integrate(1/(a + b*cos(x)), x);
+#(c29) trigsimp(ratsimp(diff(%, x)));
+#                        1
+#(d29)             ------------
+#                  b cos(x) + a
+    raise NotImplementedError(
+        "Integrate with assumption not supported")
+
+
+def test_V10():
+    assert integrate(1/(3 + 3*cos(x) + 4*sin(x)), x) == log(tan(x/2) + R(3, 4))/4
+
+
+def test_V11():
+    r1 = integrate(1/(4 + 3*cos(x) + 4*sin(x)), x)
+    r2 = factor(r1)
+    assert (logcombine(r2, force=True) ==
+            log(((tan(x/2) + 1)/(tan(x/2) + 7))**R(1, 3)))
+
+
+def test_V12():
+    r1 = integrate(1/(5 + 3*cos(x) + 4*sin(x)), x)
+    assert r1 == -1/(tan(x/2) + 2)
+
+
+@XFAIL
+def test_V13():
+    r1 = integrate(1/(6 + 3*cos(x) + 4*sin(x)), x)
+    # expression not simplified, returns: -sqrt(11)*I*log(tan(x/2) + 4/3
+    #   - sqrt(11)*I/3)/11 + sqrt(11)*I*log(tan(x/2) + 4/3 + sqrt(11)*I/3)/11
+    assert r1.simplify() == 2*sqrt(11)*atan(sqrt(11)*(3*tan(x/2) + 4)/11)/11
+
+
+@slow
+@XFAIL
+def test_V14():
+    r1 = integrate(log(abs(x**2 - y**2)), x)
+    # Piecewise result does not simplify to the desired result.
+    assert (r1.simplify() == x*log(abs(x**2  - y**2))
+                            + y*log(x + y) - y*log(x - y) - 2*x)
+
+
+def test_V15():
+    r1 = integrate(x*acot(x/y), x)
+    assert simplify(r1 - (x*y + (x**2 + y**2)*acot(x/y))/2) == 0
+
+
+@XFAIL
+def test_V16():
+    # Integral not calculated
+    assert integrate(cos(5*x)*Ci(2*x), x) == Ci(2*x)*sin(5*x)/5 - (Si(3*x) + Si(7*x))/10
+
+@XFAIL
+def test_V17():
+    r1 = integrate((diff(f(x), x)*g(x)
+                   - f(x)*diff(g(x), x))/(f(x)**2 - g(x)**2), x)
+    # integral not calculated
+    assert simplify(r1 - (f(x) - g(x))/(f(x) + g(x))/2) == 0
+
+
+@XFAIL
+def test_W1():
+    # The function has a pole at y.
+    # The integral has a Cauchy principal value of zero but SymPy returns -I*pi
+    # https://github.com/sympy/sympy/issues/7159
+    assert integrate(1/(x - y), (x, y - 1, y + 1)) == 0
+
+
+@XFAIL
+def test_W2():
+    # The function has a pole at y.
+    # The integral is divergent but SymPy returns -2
+    # https://github.com/sympy/sympy/issues/7160
+    # Test case in Macsyma:
+    # (c6) errcatch(integrate(1/(x - a)^2, x, a - 1, a + 1));
+    # Integral is divergent
+    assert integrate(1/(x - y)**2, (x, y - 1, y + 1)) is zoo
+
+
+@XFAIL
+@slow
+def test_W3():
+    # integral is not  calculated
+    # https://github.com/sympy/sympy/issues/7161
+    assert integrate(sqrt(x + 1/x - 2), (x, 0, 1)) == R(4, 3)
+
+
+@XFAIL
+@slow
+def test_W4():
+    # integral is not  calculated
+    assert integrate(sqrt(x + 1/x - 2), (x, 1, 2)) == -2*sqrt(2)/3 + R(4, 3)
+
+
+@XFAIL
+@slow
+def test_W5():
+    # integral is not  calculated
+    assert integrate(sqrt(x + 1/x - 2), (x, 0, 2)) == -2*sqrt(2)/3 + R(8, 3)
+
+
+@XFAIL
+@slow
+def test_W6():
+    # integral is not  calculated
+    assert integrate(sqrt(2 - 2*cos(2*x))/2, (x, pi*R(-3, 4), -pi/4)) == sqrt(2)
+
+
+def test_W7():
+    a = symbols('a', real=True, positive=True)
+    r1 = integrate(cos(x)/(x**2 + a**2), (x, -oo, oo))
+    assert r1.simplify() == pi*exp(-a)/a
+
+
+@XFAIL
+def test_W8():
+    # Test case in Mathematica:
+    # In[19]:= Integrate[t^(a - 1)/(1 + t), {t, 0, Infinity},
+    #                    Assumptions -> 0 < a < 1]
+    # Out[19]= Pi Csc[a Pi]
+    raise NotImplementedError(
+        "Integrate with assumption 0 < a < 1 not supported")
+
+
+@XFAIL
+def test_W9():
+    # Integrand with a residue at infinity => -2 pi [sin(pi/5) + sin(2pi/5)]
+    # (principal value)   [Levinson and Redheffer, p. 234] *)
+    r1 = integrate(5*x**3/(1 + x + x**2 + x**3 + x**4), (x, -oo, oo))
+    r2 = r1.doit()
+    assert r2 == -2*pi*(sqrt(-sqrt(5)/8 + 5/8) + sqrt(sqrt(5)/8 + 5/8))
+
+
+@XFAIL
+def test_W10():
+    # integrate(1/[1 + x + x^2 + ... + x^(2 n)], x = -infinity..infinity) =
+    #        2 pi/(2 n + 1) [1 + cos(pi/[2 n + 1])] csc(2 pi/[2 n + 1])
+    # [Levinson and Redheffer, p. 255] => 2 pi/5 [1 + cos(pi/5)] csc(2 pi/5) */
+    r1 = integrate(x/(1 + x + x**2 + x**4), (x, -oo, oo))
+    r2 = r1.doit()
+    assert r2 == 2*pi*(sqrt(5)/4 + 5/4)*csc(pi*R(2, 5))/5
+
+
+@XFAIL
+def test_W11():
+    # integral not calculated
+    assert (integrate(sqrt(1 - x**2)/(1 + x**2), (x, -1, 1)) ==
+            pi*(-1 + sqrt(2)))
+
+
+def test_W12():
+    p = symbols('p', real=True, positive=True)
+    q = symbols('q', real=True)
+    r1 = integrate(x*exp(-p*x**2 + 2*q*x), (x, -oo, oo))
+    assert r1.simplify() == sqrt(pi)*q*exp(q**2/p)/p**R(3, 2)
+
+
+@XFAIL
+def test_W13():
+    # Integral not calculated. Expected result is 2*(Euler_mascheroni_constant)
+    r1 = integrate(1/log(x) + 1/(1 - x) - log(log(1/x)), (x, 0, 1))
+    assert r1 == 2*EulerGamma
+
+
+def test_W14():
+    assert integrate(sin(x)/x*exp(2*I*x), (x, -oo, oo)) == 0
+
+
+@XFAIL
+def test_W15():
+    # integral not calculated
+    assert integrate(log(gamma(x))*cos(6*pi*x), (x, 0, 1)) == R(1, 12)
+
+
+def test_W16():
+    assert integrate((1 + x)**3*legendre_poly(1, x)*legendre_poly(2, x),
+                     (x, -1, 1)) == R(36, 35)
+
+
+def test_W17():
+    a, b = symbols('a b', real=True, positive=True)
+    assert integrate(exp(-a*x)*besselj(0, b*x),
+                 (x, 0, oo)) == 1/(b*sqrt(a**2/b**2 + 1))
+
+
+def test_W18():
+    assert integrate((besselj(1, x)/x)**2, (x, 0, oo)) == 4/(3*pi)
+
+
+@XFAIL
+def test_W19():
+    # Integral not calculated
+    # Expected result is (cos 7 - 1)/7   [Gradshteyn and Ryzhik 6.782(3)]
+    assert integrate(Ci(x)*besselj(0, 2*sqrt(7*x)), (x, 0, oo)) == (cos(7) - 1)/7
+
+
+@XFAIL
+def test_W20():
+    # integral not calculated
+    assert (integrate(x**2*polylog(3, 1/(x + 1)), (x, 0, 1)) ==
+            -pi**2/36 - R(17, 108) + zeta(3)/4 +
+            (-pi**2/2 - 4*log(2) + log(2)**2 + 35/3)*log(2)/9)
+
+
+def test_W21():
+    assert abs(N(integrate(x**2*polylog(3, 1/(x + 1)), (x, 0, 1)))
+        - 0.210882859565594) < 1e-15
+
+
+def test_W22():
+    t, u = symbols('t u', real=True)
+    s = Lambda(x, Piecewise((1, And(x >= 1, x <= 2)), (0, True)))
+    assert integrate(s(t)*cos(t), (t, 0, u)) == Piecewise(
+        (0, u < 0),
+        (-sin(Min(1, u)) + sin(Min(2, u)), True))
+
+
+@slow
+def test_W23():
+    a, b = symbols('a b', real=True, positive=True)
+    r1 = integrate(integrate(x/(x**2 + y**2), (x, a, b)), (y, -oo, oo))
+    assert r1.collect(pi) == pi*(-a + b)
+
+
+def test_W23b():
+    # like W23 but limits are reversed
+    a, b = symbols('a b', real=True, positive=True)
+    r2 = integrate(integrate(x/(x**2 + y**2), (y, -oo, oo)), (x, a, b))
+    assert r2.collect(pi) == pi*(-a + b)
+
+
+@XFAIL
+@slow
+def test_W24():
+    if ON_TRAVIS:
+        skip("Too slow for travis.")
+    # Not that slow, but does not fully evaluate so simplify is slow.
+    # Maybe also require doit()
+    x, y = symbols('x y', real=True)
+    r1 = integrate(integrate(sqrt(x**2 + y**2), (x, 0, 1)), (y, 0, 1))
+    assert (r1 - (sqrt(2) + asinh(1))/3).simplify() == 0
+
+
+@XFAIL
+@slow
+def test_W25():
+    if ON_TRAVIS:
+        skip("Too slow for travis.")
+    a, x, y = symbols('a x y', real=True)
+    i1 = integrate(
+        sin(a)*sin(y)/sqrt(1 - sin(a)**2*sin(x)**2*sin(y)**2),
+        (x, 0, pi/2))
+    i2 = integrate(i1, (y, 0, pi/2))
+    assert (i2 - pi*a/2).simplify() == 0
+
+
+
+def test_W26():
+    x, y = symbols('x y', real=True)
+    assert integrate(integrate(abs(y - x**2), (y, 0, 2)),
+                     (x, -1, 1)) == R(46, 15)
+
+
+def test_W27():
+    a, b, c = symbols('a b c')
+    assert integrate(integrate(integrate(1, (z, 0, c*(1 - x/a - y/b))),
+                               (y, 0, b*(1 - x/a))),
+                     (x, 0, a)) == a*b*c/6
+
+
+def test_X1():
+    v, c = symbols('v c', real=True)
+    assert (series(1/sqrt(1 - (v/c)**2), v, x0=0, n=8) ==
+            5*v**6/(16*c**6) + 3*v**4/(8*c**4) + v**2/(2*c**2) + 1 + O(v**8))
+
+
+def test_X2():
+    v, c = symbols('v c', real=True)
+    s1 = series(1/sqrt(1 - (v/c)**2), v, x0=0, n=8)
+    assert (1/s1**2).series(v, x0=0, n=8) == -v**2/c**2 + 1 + O(v**8)
+
+
+def test_X3():
+    s1 = (sin(x).series()/cos(x).series()).series()
+    s2 = tan(x).series()
+    assert s2 == x + x**3/3 + 2*x**5/15 + O(x**6)
+    assert s1 == s2
+
+
+def test_X4():
+    s1 = log(sin(x)/x).series()
+    assert s1 == -x**2/6 - x**4/180 + O(x**6)
+    assert log(series(sin(x)/x)).series() == s1
+
+
+@XFAIL
+def test_X5():
+    # test case in Mathematica syntax:
+    # In[21]:= (* => [a f'(a d) + g(b d) + integrate(h(c y), y = 0..d)]
+    #       + [a^2 f''(a d) + b g'(b d) + h(c d)] (x - d) *)
+    # In[22]:= D[f[a*x], x] + g[b*x] + Integrate[h[c*y], {y, 0, x}]
+    # Out[22]= g[b x] + Integrate[h[c y], {y, 0, x}] + a f'[a x]
+    # In[23]:= Series[%, {x, d, 1}]
+    # Out[23]= (g[b d] + Integrate[h[c y], {y, 0, d}] + a f'[a d]) +
+    #                                    2                               2
+    #             (h[c d] + b g'[b d] + a  f''[a d]) (-d + x) + O[-d + x]
+    h = Function('h')
+    a, b, c, d = symbols('a b c d', real=True)
+    # series() raises NotImplementedError:
+    # The _eval_nseries method should be added to <class
+    # 'sympy.core.function.Subs'> to give terms up to O(x**n) at x=0
+    series(diff(f(a*x), x) + g(b*x) + integrate(h(c*y), (y, 0, x)),
+           x, x0=d, n=2)
+    # assert missing, until exception is removed
+
+
+def test_X6():
+    # Taylor series of nonscalar objects (noncommutative multiplication)
+    # expected result => (B A - A B) t^2/2 + O(t^3)   [Stanly Steinberg]
+    a, b = symbols('a b', commutative=False, scalar=False)
+    assert (series(exp((a + b)*x) - exp(a*x) * exp(b*x), x, x0=0, n=3) ==
+              x**2*(-a*b/2 + b*a/2) + O(x**3))
+
+
+def test_X7():
+    # => sum( Bernoulli[k]/k! x^(k - 2), k = 1..infinity )
+    #    = 1/x^2 - 1/(2 x) + 1/12 - x^2/720 + x^4/30240 + O(x^6)
+    #    [Levinson and Redheffer, p. 173]
+    assert (series(1/(x*(exp(x) - 1)), x, 0, 7) == x**(-2) - 1/(2*x) +
+            R(1, 12) - x**2/720 + x**4/30240 - x**6/1209600 + O(x**7))
+
+
+def test_X8():
+    # Puiseux series (terms with fractional degree):
+    # => 1/sqrt(x - 3/2 pi) + (x - 3/2 pi)^(3/2) / 12 + O([x - 3/2 pi]^(7/2))
+
+    # see issue 7167:
+    x = symbols('x', real=True)
+    assert (series(sqrt(sec(x)), x, x0=pi*3/2, n=4) ==
+            1/sqrt(x - pi*R(3, 2)) + (x - pi*R(3, 2))**R(3, 2)/12 +
+            (x - pi*R(3, 2))**R(7, 2)/160 + O((x - pi*R(3, 2))**4, (x, pi*R(3, 2))))
+
+
+def test_X9():
+    assert (series(x**x, x, x0=0, n=4) == 1 + x*log(x) + x**2*log(x)**2/2 +
+            x**3*log(x)**3/6 + O(x**4*log(x)**4))
+
+
+def test_X10():
+    z, w = symbols('z w')
+    assert (series(log(sinh(z)) + log(cosh(z + w)), z, x0=0, n=2) ==
+            log(cosh(w)) + log(z) + z*sinh(w)/cosh(w) + O(z**2))
+
+
+def test_X11():
+    z, w = symbols('z w')
+    assert (series(log(sinh(z) * cosh(z + w)), z, x0=0, n=2) ==
+            log(cosh(w)) + log(z) + z*sinh(w)/cosh(w) + O(z**2))
+
+
+@XFAIL
+def test_X12():
+    # Look at the generalized Taylor series around x = 1
+    # Result => (x - 1)^a/e^b [1 - (a + 2 b) (x - 1) / 2 + O((x - 1)^2)]
+    a, b, x = symbols('a b x', real=True)
+    # series returns O(log(x-1)**2)
+    # https://github.com/sympy/sympy/issues/7168
+    assert (series(log(x)**a*exp(-b*x), x, x0=1, n=2) ==
+            (x - 1)**a/exp(b)*(1 - (a + 2*b)*(x - 1)/2 + O((x - 1)**2)))
+
+
+def test_X13():
+    assert series(sqrt(2*x**2 + 1), x, x0=oo, n=1) == sqrt(2)*x + O(1/x, (x, oo))
+
+
+@XFAIL
+def test_X14():
+    # Wallis' product => 1/sqrt(pi n) + ...   [Knopp, p. 385]
+    assert series(1/2**(2*n)*binomial(2*n, n),
+                  n, x==oo, n=1) == 1/(sqrt(pi)*sqrt(n)) + O(1/x, (x, oo))
+
+
+@SKIP("https://github.com/sympy/sympy/issues/7164")
+def test_X15():
+    # => 0!/x - 1!/x^2 + 2!/x^3 - 3!/x^4 + O(1/x^5)   [Knopp, p. 544]
+    x, t = symbols('x t', real=True)
+    # raises RuntimeError: maximum recursion depth exceeded
+    # https://github.com/sympy/sympy/issues/7164
+    # 2019-02-17: Raises
+    # PoleError:
+    # Asymptotic expansion of Ei around [-oo] is not implemented.
+    e1 = integrate(exp(-t)/t, (t, x, oo))
+    assert (series(e1, x, x0=oo, n=5) ==
+            6/x**4 + 2/x**3 - 1/x**2 + 1/x + O(x**(-5), (x, oo)))
+
+
+def test_X16():
+    # Multivariate Taylor series expansion => 1 - (x^2 + 2 x y + y^2)/2 + O(x^4)
+    assert (series(cos(x + y), x + y, x0=0, n=4) == 1 - (x + y)**2/2 +
+            O(x**4 + x**3*y + x**2*y**2 + x*y**3 + y**4, x, y))
+
+
+@XFAIL
+def test_X17():
+    # Power series (compute the general formula)
+    # (c41) powerseries(log(sin(x)/x), x, 0);
+    # /aquarius/data2/opt/local/macsyma_422/library1/trgred.so being loaded.
+    #              inf
+    #              ====     i1  2 i1          2 i1
+    #              \        (- 1)   2      bern(2 i1) x
+    # (d41)         >        ------------------------------
+    #              /             2 i1 (2 i1)!
+    #              ====
+    #              i1 = 1
+    # fps does not calculate
+    assert fps(log(sin(x)/x)) == \
+        Sum((-1)**k*2**(2*k - 1)*bernoulli(2*k)*x**(2*k)/(k*factorial(2*k)), (k, 1, oo))
+
+
+@XFAIL
+def test_X18():
+    # Power series (compute the general formula). Maple FPS:
+    # > FormalPowerSeries(exp(-x)*sin(x), x = 0);
+    #                        infinity
+    #                         -----    (1/2 k)                k
+    #                          \      2        sin(3/4 k Pi) x
+    #                           )     -------------------------
+    #                          /                 k!
+    #                         -----
+    #
+    # Now, sympy returns
+    #      oo
+    #    _____
+    #    \    `
+    #     \        /          k             k\
+    #      \     k |I*(-1 - I)    I*(-1 + I) |
+    #       \   x *|----------- - -----------|
+    #       /      \     2             2     /
+    #      /    ------------------------------
+    #     /                   k!
+    #    /____,
+    #    k = 0
+    k = Dummy('k')
+    assert fps(exp(-x)*sin(x)) == \
+        Sum(2**(S.Half*k)*sin(R(3, 4)*k*pi)*x**k/factorial(k), (k, 0, oo))
+
+
+@XFAIL
+def test_X19():
+    # (c45) /* Derive an explicit Taylor series solution of y as a function of
+    # x from the following implicit relation:
+    #    y = x - 1 + (x - 1)^2/2 + 2/3 (x - 1)^3 + (x - 1)^4 +
+    #        17/10 (x - 1)^5 + ...
+    #    */
+    # x = sin(y) + cos(y);
+    # Time= 0 msecs
+    # (d45)                   x = sin(y) + cos(y)
+    #
+    # (c46) taylor_revert(%, y, 7);
+    raise NotImplementedError("Solve using series not supported. \
+Inverse Taylor series expansion also not supported")
+
+
+@XFAIL
+def test_X20():
+    # Pade (rational function) approximation => (2 - x)/(2 + x)
+    # > numapprox[pade](exp(-x), x = 0, [1, 1]);
+    # bytes used=9019816, alloc=3669344, time=13.12
+    #                                    1 - 1/2 x
+    #                                    ---------
+    #                                    1 + 1/2 x
+    # mpmath support numeric Pade approximant but there is
+    # no symbolic implementation in SymPy
+    # https://en.wikipedia.org/wiki/Pad%C3%A9_approximant
+    raise NotImplementedError("Symbolic Pade approximant not supported")
+
+
+def test_X21():
+    """
+    Test whether `fourier_series` of x periodical on the [-p, p] interval equals
+    `- (2 p / pi) sum( (-1)^n / n sin(n pi x / p), n = 1..infinity )`.
+    """
+    p = symbols('p', positive=True)
+    n = symbols('n', positive=True, integer=True)
+    s = fourier_series(x, (x, -p, p))
+
+    # All cosine coefficients are equal to 0
+    assert s.an.formula == 0
+
+    # Check for sine coefficients
+    assert s.bn.formula.subs(s.bn.variables[0], 0) == 0
+    assert s.bn.formula.subs(s.bn.variables[0], n) == \
+        -2*p/pi * (-1)**n / n * sin(n*pi*x/p)
+
+
+@XFAIL
+def test_X22():
+    # (c52) /* => p / 2
+    #    - (2 p / pi^2) sum( [1 - (-1)^n] cos(n pi x / p) / n^2,
+    #                        n = 1..infinity ) */
+    # fourier_series(abs(x), x, p);
+    #                       p
+    # (e52)                      a  = -
+    #                       0      2
+    #
+    #                       %nn
+    #                   (2 (- 1)    - 2) p
+    # (e53)                a    = ------------------
+    #                 %nn         2    2
+    #                       %pi  %nn
+    #
+    # (e54)                     b    = 0
+    #                      %nn
+    #
+    # Time= 5290 msecs
+    #            inf           %nn            %pi %nn x
+    #            ====       (2 (- 1)    - 2) cos(---------)
+    #            \                    p
+    #          p  >       -------------------------------
+    #            /               2
+    #            ====                %nn
+    #            %nn = 1                     p
+    # (d54)          ----------------------------------------- + -
+    #                       2                 2
+    #                    %pi
+    raise NotImplementedError("Fourier series not supported")
+
+
+def test_Y1():
+    t = symbols('t', real=True, positive=True)
+    w = symbols('w', real=True)
+    s = symbols('s')
+    F, _, _ = laplace_transform(cos((w - 1)*t), t, s)
+    assert F == s/(s**2 + (w - 1)**2)
+
+
+def test_Y2():
+    t = symbols('t', real=True, positive=True)
+    w = symbols('w', real=True)
+    s = symbols('s')
+    f = inverse_laplace_transform(s/(s**2 + (w - 1)**2), s, t)
+    assert f == cos(t*w - t)
+
+
+def test_Y3():
+    t = symbols('t', real=True, positive=True)
+    w = symbols('w', real=True)
+    s = symbols('s')
+    F, _, _ = laplace_transform(sinh(w*t)*cosh(w*t), t, s)
+    assert F == w/(s**2 - 4*w**2)
+
+
+def test_Y4():
+    t = symbols('t', real=True, positive=True)
+    s = symbols('s')
+    F, _, _ = laplace_transform(erf(3/sqrt(t)), t, s)
+    assert F == (1 - exp(-6*sqrt(s)))/s
+
+
+@XFAIL
+def test_Y5_Y6():
+# Solve y'' + y = 4 [H(t - 1) - H(t - 2)], y(0) = 1, y'(0) = 0 where H is the
+# Heaviside (unit step) function (the RHS describes a pulse of magnitude 4 and
+# duration 1).  See David A. Sanchez, Richard C. Allen, Jr. and Walter T.
+# Kyner, _Differential Equations: An Introduction_, Addison-Wesley Publishing
+# Company, 1983, p. 211.  First, take the Laplace transform of the ODE
+# => s^2 Y(s) - s + Y(s) = 4/s [e^(-s) - e^(-2 s)]
+# where Y(s) is the Laplace transform of y(t)
+    t = symbols('t', real=True, positive=True)
+    s = symbols('s')
+    y = Function('y')
+    F, _, _ = laplace_transform(diff(y(t), t, 2)
+                                + y(t)
+                                - 4*(Heaviside(t - 1)
+                                - Heaviside(t - 2)), t, s)
+    # Laplace transform for diff() not calculated
+    # https://github.com/sympy/sympy/issues/7176
+    assert (F == s**2*LaplaceTransform(y(t), t, s) - s
+            + LaplaceTransform(y(t), t, s) - 4*exp(-s)/s + 4*exp(-2*s)/s)
+# TODO implement second part of test case
+# Now, solve for Y(s) and then take the inverse Laplace transform
+#   => Y(s) = s/(s^2 + 1) + 4 [1/s - s/(s^2 + 1)] [e^(-s) - e^(-2 s)]
+#   => y(t) = cos t + 4 {[1 - cos(t - 1)] H(t - 1) - [1 - cos(t - 2)] H(t - 2)}
+
+
+@XFAIL
+def test_Y7():
+    # What is the Laplace transform of an infinite square wave?
+    # => 1/s + 2 sum( (-1)^n e^(- s n a)/s, n = 1..infinity )
+    #    [Sanchez, Allen and Kyner, p. 213]
+    t = symbols('t', real=True, positive=True)
+    a = symbols('a', real=True)
+    s = symbols('s')
+    F, _, _ = laplace_transform(1 + 2*Sum((-1)**n*Heaviside(t - n*a),
+                                          (n, 1, oo)), t, s)
+    # returns 2*LaplaceTransform(Sum((-1)**n*Heaviside(-a*n + t),
+    #                                (n, 1, oo)), t, s) + 1/s
+    # https://github.com/sympy/sympy/issues/7177
+    assert F == 2*Sum((-1)**n*exp(-a*n*s)/s, (n, 1, oo)) + 1/s
+
+
+@XFAIL
+def test_Y8():
+    assert fourier_transform(1, x, z) == DiracDelta(z)
+
+
+def test_Y9():
+    assert (fourier_transform(exp(-9*x**2), x, z) ==
+            sqrt(pi)*exp(-pi**2*z**2/9)/3)
+
+
+def test_Y10():
+    assert (fourier_transform(abs(x)*exp(-3*abs(x)), x, z).cancel() ==
+            (-8*pi**2*z**2 + 18)/(16*pi**4*z**4 + 72*pi**2*z**2 + 81))
+
+
+@SKIP("https://github.com/sympy/sympy/issues/7181")
+@slow
+def test_Y11():
+    # => pi cot(pi s)   (0 < Re s < 1)   [Gradshteyn and Ryzhik 17.43(5)]
+    x, s = symbols('x s')
+    # raises RuntimeError: maximum recursion depth exceeded
+    # https://github.com/sympy/sympy/issues/7181
+    # Update 2019-02-17 raises:
+    # TypeError: cannot unpack non-iterable MellinTransform object
+    F, _, _ =  mellin_transform(1/(1 - x), x, s)
+    assert F == pi*cot(pi*s)
+
+
+@XFAIL
+def test_Y12():
+    # => 2^(s - 4) gamma(s/2)/gamma(4 - s/2)   (0 < Re s < 1)
+    # [Gradshteyn and Ryzhik 17.43(16)]
+    x, s = symbols('x s')
+    # returns Wrong value -2**(s - 4)*gamma(s/2 - 3)/gamma(-s/2 + 1)
+    # https://github.com/sympy/sympy/issues/7182
+    F, _, _ = mellin_transform(besselj(3, x)/x**3, x, s)
+    assert F == -2**(s - 4)*gamma(s/2)/gamma(-s/2 + 4)
+
+
+@XFAIL
+def test_Y13():
+# Z[H(t - m T)] => z/[z^m (z - 1)]   (H is the Heaviside (unit step) function)                                                 z
+    raise NotImplementedError("z-transform not supported")
+
+
+@XFAIL
+def test_Y14():
+# Z[H(t - m T)] => z/[z^m (z - 1)]   (H is the Heaviside (unit step) function)
+    raise NotImplementedError("z-transform not supported")
+
+
+def test_Z1():
+    r = Function('r')
+    assert (rsolve(r(n + 2) - 2*r(n + 1) + r(n) - 2, r(n),
+                   {r(0): 1, r(1): m}).simplify() == n**2 + n*(m - 2) + 1)
+
+
+def test_Z2():
+    r = Function('r')
+    assert (rsolve(r(n) - (5*r(n - 1) - 6*r(n - 2)), r(n), {r(0): 0, r(1): 1})
+            == -2**n + 3**n)
+
+
+def test_Z3():
+    # => r(n) = Fibonacci[n + 1]   [Cohen, p. 83]
+    r = Function('r')
+    # recurrence solution is correct, Wester expects it to be simplified to
+    # fibonacci(n+1), but that is quite hard
+    expected = ((S(1)/2 - sqrt(5)/2)**n*(S(1)/2 - sqrt(5)/10)
+              + (S(1)/2 + sqrt(5)/2)**n*(sqrt(5)/10 + S(1)/2))
+    sol = rsolve(r(n) - (r(n - 1) + r(n - 2)), r(n), {r(1): 1, r(2): 2})
+    assert sol == expected
+
+
+@XFAIL
+def test_Z4():
+# => [c^(n+1) [c^(n+1) - 2 c - 2] + (n+1) c^2 + 2 c - n] / [(c-1)^3 (c+1)]
+#    [Joan Z. Yu and Robert Israel in sci.math.symbolic]
+    r = Function('r')
+    c = symbols('c')
+    # raises ValueError: Polynomial or rational function expected,
+    #     got '(c**2 - c**n)/(c - c**n)
+    s = rsolve(r(n) - ((1 + c - c**(n-1) - c**(n+1))/(1 - c**n)*r(n - 1)
+                   - c*(1 - c**(n-2))/(1 - c**(n-1))*r(n - 2) + 1),
+           r(n), {r(1): 1, r(2): (2 + 2*c + c**2)/(1 + c)})
+    assert (s - (c*(n + 1)*(c*(n + 1) - 2*c - 2) +
+             (n + 1)*c**2 + 2*c - n)/((c-1)**3*(c+1)) == 0)
+
+
+@XFAIL
+def test_Z5():
+    # Second order ODE with initial conditions---solve directly
+    # transform: f(t) = sin(2 t)/8 - t cos(2 t)/4
+    C1, C2 = symbols('C1 C2')
+    # initial conditions not supported, this is a manual workaround
+    # https://github.com/sympy/sympy/issues/4720
+    eq = Derivative(f(x), x, 2) + 4*f(x) - sin(2*x)
+    sol = dsolve(eq, f(x))
+    f0 = Lambda(x, sol.rhs)
+    assert f0(x) == C2*sin(2*x) + (C1 - x/4)*cos(2*x)
+    f1 = Lambda(x, diff(f0(x), x))
+    # TODO: Replace solve with solveset, when it works for solveset
+    const_dict = solve((f0(0), f1(0)))
+    result = f0(x).subs(C1, const_dict[C1]).subs(C2, const_dict[C2])
+    assert result == -x*cos(2*x)/4 + sin(2*x)/8
+    # Result is OK, but ODE solving with initial conditions should be
+    # supported without all this manual work
+    raise NotImplementedError('ODE solving with initial conditions \
+not supported')
+
+
+@XFAIL
+def test_Z6():
+    # Second order ODE with initial conditions---solve  using Laplace
+    # transform: f(t) = sin(2 t)/8 - t cos(2 t)/4
+    t = symbols('t', real=True, positive=True)
+    s = symbols('s')
+    eq = Derivative(f(t), t, 2) + 4*f(t) - sin(2*t)
+    F, _, _ = laplace_transform(eq, t, s)
+    # Laplace transform for diff() not calculated
+    # https://github.com/sympy/sympy/issues/7176
+    assert (F == s**2*LaplaceTransform(f(t), t, s) +
+            4*LaplaceTransform(f(t), t, s) - 2/(s**2 + 4))
+    # rest of test case not implemented
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/timeutils.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/timeutils.py
new file mode 100644
index 0000000000..cef6de95ba
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/timeutils.py
@@ -0,0 +1,76 @@
+"""Simple tools for timing functions' execution, when IPython is not available. """
+
+
+import timeit
+import math
+
+
+_scales = [1e0, 1e3, 1e6, 1e9]
+_units = ['s', 'ms', '\N{GREEK SMALL LETTER MU}s', 'ns']
+
+
+def timed(func, setup="pass", limit=None):
+    """Adaptively measure execution time of a function. """
+    timer = timeit.Timer(func, setup=setup)
+    repeat, number = 3, 1
+
+    for i in range(1, 10):
+        if timer.timeit(number) >= 0.2:
+            break
+        elif limit is not None and number >= limit:
+            break
+        else:
+            number *= 10
+
+    time = min(timer.repeat(repeat, number)) / number
+
+    if time > 0.0:
+        order = min(-int(math.floor(math.log10(time)) // 3), 3)
+    else:
+        order = 3
+
+    return (number, time, time*_scales[order], _units[order])
+
+
+# Code for doing inline timings of recursive algorithms.
+
+def __do_timings():
+    import os
+    res = os.getenv('SYMPY_TIMINGS', '')
+    res = [x.strip() for x in res.split(',')]
+    return set(res)
+
+_do_timings = __do_timings()
+_timestack = None
+
+
+def _print_timestack(stack, level=1):
+    print('-'*level, '%.2f %s%s' % (stack[2], stack[0], stack[3]))
+    for s in stack[1]:
+        _print_timestack(s, level + 1)
+
+
+def timethis(name):
+    def decorator(func):
+        global _do_timings
+        if not name in _do_timings:
+            return func
+
+        def wrapper(*args, **kwargs):
+            from time import time
+            global _timestack
+            oldtimestack = _timestack
+            _timestack = [func.func_name, [], 0, args]
+            t1 = time()
+            r = func(*args, **kwargs)
+            t2 = time()
+            _timestack[2] = t2 - t1
+            if oldtimestack is not None:
+                oldtimestack[1].append(_timestack)
+                _timestack = oldtimestack
+            else:
+                _print_timestack(_timestack)
+                _timestack = None
+            return r
+        return wrapper
+    return decorator
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tmpfiles.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tmpfiles.py
new file mode 100644
index 0000000000..09a406deaa
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tmpfiles.py
@@ -0,0 +1,9 @@
+from sympy.utilities.exceptions import SymPyDeprecationWarning
+
+SymPyDeprecationWarning(
+    feature="Import sympy.utilities.tmpfiles",
+    useinstead="Import from sympy.testing.tmpfiles",
+    issue=18095,
+    deprecated_since_version="1.6").warn()
+
+from sympy.testing.tmpfiles import *  # noqa:F401
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/__init__.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/__init__.py
new file mode 100644
index 0000000000..bdf9e615c7
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/__init__.py
@@ -0,0 +1,47 @@
+from sympy.vector.coordsysrect import CoordSys3D, CoordSysCartesian
+from sympy.vector.vector import (Vector, VectorAdd, VectorMul,
+                                 BaseVector, VectorZero, Cross, Dot, cross, dot)
+from sympy.vector.dyadic import (Dyadic, DyadicAdd, DyadicMul,
+                                 BaseDyadic, DyadicZero)
+from sympy.vector.scalar import BaseScalar
+from sympy.vector.deloperator import Del
+from sympy.vector.functions import (express, matrix_to_vector,
+                                    laplacian, is_conservative,
+                                    is_solenoidal, scalar_potential,
+                                    directional_derivative,
+                                    scalar_potential_difference)
+from sympy.vector.point import Point
+from sympy.vector.orienters import (AxisOrienter, BodyOrienter,
+                                    SpaceOrienter, QuaternionOrienter)
+from sympy.vector.operators import Gradient, Divergence, Curl, Laplacian, gradient, curl, divergence
+from sympy.vector.implicitregion import ImplicitRegion
+from sympy.vector.parametricregion import (ParametricRegion, parametric_region_list)
+from sympy.vector.integrals import (ParametricIntegral, vector_integrate)
+
+__all__ = [
+    'Vector', 'VectorAdd', 'VectorMul', 'BaseVector', 'VectorZero', 'Cross',
+    'Dot', 'cross', 'dot',
+
+    'Dyadic', 'DyadicAdd', 'DyadicMul', 'BaseDyadic', 'DyadicZero',
+
+    'BaseScalar',
+
+    'Del',
+
+    'CoordSys3D', 'CoordSysCartesian',
+
+    'express', 'matrix_to_vector', 'laplacian', 'is_conservative',
+    'is_solenoidal', 'scalar_potential', 'directional_derivative',
+    'scalar_potential_difference',
+
+    'Point',
+
+    'AxisOrienter', 'BodyOrienter', 'SpaceOrienter', 'QuaternionOrienter',
+
+    'Gradient', 'Divergence', 'Curl', 'Laplacian', 'gradient', 'curl',
+    'divergence',
+
+    'ParametricRegion', 'parametric_region_list', 'ImplicitRegion',
+
+    'ParametricIntegral', 'vector_integrate',
+]
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/basisdependent.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/basisdependent.py
new file mode 100644
index 0000000000..4b18188a79
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/basisdependent.py
@@ -0,0 +1,358 @@
+from typing import Any, Dict
+
+from sympy.simplify import simplify as simp, trigsimp as tsimp
+from sympy.core.decorators import call_highest_priority, _sympifyit
+from sympy.core.assumptions import StdFactKB
+from sympy import factor as fctr, diff as df, Integral
+from sympy.core import S, Add, Mul
+from sympy.core.expr import Expr
+
+
+class BasisDependent(Expr):
+    """
+    Super class containing functionality common to vectors and
+    dyadics.
+    Named so because the representation of these quantities in
+    sympy.vector is dependent on the basis they are expressed in.
+    """
+
+    @call_highest_priority('__radd__')
+    def __add__(self, other):
+        return self._add_func(self, other)
+
+    @call_highest_priority('__add__')
+    def __radd__(self, other):
+        return self._add_func(other, self)
+
+    @call_highest_priority('__rsub__')
+    def __sub__(self, other):
+        return self._add_func(self, -other)
+
+    @call_highest_priority('__sub__')
+    def __rsub__(self, other):
+        return self._add_func(other, -self)
+
+    @_sympifyit('other', NotImplemented)
+    @call_highest_priority('__rmul__')
+    def __mul__(self, other):
+        return self._mul_func(self, other)
+
+    @_sympifyit('other', NotImplemented)
+    @call_highest_priority('__mul__')
+    def __rmul__(self, other):
+        return self._mul_func(other, self)
+
+    def __neg__(self):
+        return self._mul_func(S.NegativeOne, self)
+
+    @_sympifyit('other', NotImplemented)
+    @call_highest_priority('__rtruediv__')
+    def __truediv__(self, other):
+        return self._div_helper(other)
+
+    @call_highest_priority('__truediv__')
+    def __rtruediv__(self, other):
+        return TypeError("Invalid divisor for division")
+
+    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
+        """
+        Implements the SymPy evalf routine for this quantity.
+
+        evalf's documentation
+        =====================
+
+        """
+        options = {'subs':subs, 'maxn':maxn, 'chop':chop, 'strict':strict,
+                'quad':quad, 'verbose':verbose}
+        vec = self.zero
+        for k, v in self.components.items():
+            vec += v.evalf(n, **options) * k
+        return vec
+
+    evalf.__doc__ += Expr.evalf.__doc__  # type: ignore
+
+    n = evalf
+
+    def simplify(self, **kwargs):
+        """
+        Implements the SymPy simplify routine for this quantity.
+
+        simplify's documentation
+        ========================
+
+        """
+        simp_components = [simp(v, **kwargs) * k for
+                           k, v in self.components.items()]
+        return self._add_func(*simp_components)
+
+    simplify.__doc__ += simp.__doc__  # type: ignore
+
+    def trigsimp(self, **opts):
+        """
+        Implements the SymPy trigsimp routine, for this quantity.
+
+        trigsimp's documentation
+        ========================
+
+        """
+        trig_components = [tsimp(v, **opts) * k for
+                           k, v in self.components.items()]
+        return self._add_func(*trig_components)
+
+    trigsimp.__doc__ += tsimp.__doc__  # type: ignore
+
+    def _eval_simplify(self, **kwargs):
+        return self.simplify(**kwargs)
+
+    def _eval_trigsimp(self, **opts):
+        return self.trigsimp(**opts)
+
+    def _eval_derivative(self, wrt):
+        return self.diff(wrt)
+
+    def _eval_Integral(self, *symbols, **assumptions):
+        integral_components = [Integral(v, *symbols, **assumptions) * k
+                               for k, v in self.components.items()]
+        return self._add_func(*integral_components)
+
+    def as_numer_denom(self):
+        """
+        Returns the expression as a tuple wrt the following
+        transformation -
+
+        expression -> a/b -> a, b
+
+        """
+        return self, S.One
+
+    def factor(self, *args, **kwargs):
+        """
+        Implements the SymPy factor routine, on the scalar parts
+        of a basis-dependent expression.
+
+        factor's documentation
+        ========================
+
+        """
+        fctr_components = [fctr(v, *args, **kwargs) * k for
+                           k, v in self.components.items()]
+        return self._add_func(*fctr_components)
+
+    factor.__doc__ += fctr.__doc__  # type: ignore
+
+    def as_coeff_Mul(self, rational=False):
+        """Efficiently extract the coefficient of a product. """
+        return (S.One, self)
+
+    def as_coeff_add(self, *deps):
+        """Efficiently extract the coefficient of a summation. """
+        l = [x * self.components[x] for x in self.components]
+        return 0, tuple(l)
+
+    def diff(self, *args, **kwargs):
+        """
+        Implements the SymPy diff routine, for vectors.
+
+        diff's documentation
+        ========================
+
+        """
+        for x in args:
+            if isinstance(x, BasisDependent):
+                raise TypeError("Invalid arg for differentiation")
+        diff_components = [df(v, *args, **kwargs) * k for
+                           k, v in self.components.items()]
+        return self._add_func(*diff_components)
+
+    diff.__doc__ += df.__doc__  # type: ignore
+
+    def doit(self, **hints):
+        """Calls .doit() on each term in the Dyadic"""
+        doit_components = [self.components[x].doit(**hints) * x
+                           for x in self.components]
+        return self._add_func(*doit_components)
+
+
+class BasisDependentAdd(BasisDependent, Add):
+    """
+    Denotes sum of basis dependent quantities such that they cannot
+    be expressed as base or Mul instances.
+    """
+
+    def __new__(cls, *args, **options):
+        components = {}
+
+        # Check each arg and simultaneously learn the components
+        for i, arg in enumerate(args):
+            if not isinstance(arg, cls._expr_type):
+                if isinstance(arg, Mul):
+                    arg = cls._mul_func(*(arg.args))
+                elif isinstance(arg, Add):
+                    arg = cls._add_func(*(arg.args))
+                else:
+                    raise TypeError(str(arg) +
+                                    " cannot be interpreted correctly")
+            # If argument is zero, ignore
+            if arg == cls.zero:
+                continue
+            # Else, update components accordingly
+            if hasattr(arg, "components"):
+                for x in arg.components:
+                    components[x] = components.get(x, 0) + arg.components[x]
+
+        temp = list(components.keys())
+        for x in temp:
+            if components[x] == 0:
+                del components[x]
+
+        # Handle case of zero vector
+        if len(components) == 0:
+            return cls.zero
+
+        # Build object
+        newargs = [x * components[x] for x in components]
+        obj = super().__new__(cls, *newargs, **options)
+        if isinstance(obj, Mul):
+            return cls._mul_func(*obj.args)
+        assumptions = {'commutative': True}
+        obj._assumptions = StdFactKB(assumptions)
+        obj._components = components
+        obj._sys = (list(components.keys()))[0]._sys
+
+        return obj
+
+
+class BasisDependentMul(BasisDependent, Mul):
+    """
+    Denotes product of base- basis dependent quantity with a scalar.
+    """
+
+    def __new__(cls, *args, **options):
+        from sympy.vector import Cross, Dot, Curl, Gradient
+        count = 0
+        measure_number = S.One
+        zeroflag = False
+        extra_args = []
+
+        # Determine the component and check arguments
+        # Also keep a count to ensure two vectors aren't
+        # being multiplied
+        for arg in args:
+            if isinstance(arg, cls._zero_func):
+                count += 1
+                zeroflag = True
+            elif arg == S.Zero:
+                zeroflag = True
+            elif isinstance(arg, (cls._base_func, cls._mul_func)):
+                count += 1
+                expr = arg._base_instance
+                measure_number *= arg._measure_number
+            elif isinstance(arg, cls._add_func):
+                count += 1
+                expr = arg
+            elif isinstance(arg, (Cross, Dot, Curl, Gradient)):
+                extra_args.append(arg)
+            else:
+                measure_number *= arg
+        # Make sure incompatible types weren't multiplied
+        if count > 1:
+            raise ValueError("Invalid multiplication")
+        elif count == 0:
+            return Mul(*args, **options)
+        # Handle zero vector case
+        if zeroflag:
+            return cls.zero
+
+        # If one of the args was a VectorAdd, return an
+        # appropriate VectorAdd instance
+        if isinstance(expr, cls._add_func):
+            newargs = [cls._mul_func(measure_number, x) for
+                       x in expr.args]
+            return cls._add_func(*newargs)
+
+        obj = super().__new__(cls, measure_number,
+                              expr._base_instance,
+                              *extra_args,
+                              **options)
+        if isinstance(obj, Add):
+            return cls._add_func(*obj.args)
+        obj._base_instance = expr._base_instance
+        obj._measure_number = measure_number
+        assumptions = {'commutative': True}
+        obj._assumptions = StdFactKB(assumptions)
+        obj._components = {expr._base_instance: measure_number}
+        obj._sys = expr._base_instance._sys
+
+        return obj
+
+    def _sympystr(self, printer):
+        measure_str = printer._print(self._measure_number)
+        if ('(' in measure_str or '-' in measure_str or
+                '+' in measure_str):
+            measure_str = '(' + measure_str + ')'
+        return measure_str + '*' + printer._print(self._base_instance)
+
+
+class BasisDependentZero(BasisDependent):
+    """
+    Class to denote a zero basis dependent instance.
+    """
+    # XXX: Can't type the keys as BaseVector because of cyclic import
+    # problems.
+    components = {}  # type: Dict[Any, Expr]
+
+    def __new__(cls):
+        obj = super().__new__(cls)
+        # Pre-compute a specific hash value for the zero vector
+        # Use the same one always
+        obj._hash = tuple([S.Zero, cls]).__hash__()
+        return obj
+
+    def __hash__(self):
+        return self._hash
+
+    @call_highest_priority('__req__')
+    def __eq__(self, other):
+        return isinstance(other, self._zero_func)
+
+    __req__ = __eq__
+
+    @call_highest_priority('__radd__')
+    def __add__(self, other):
+        if isinstance(other, self._expr_type):
+            return other
+        else:
+            raise TypeError("Invalid argument types for addition")
+
+    @call_highest_priority('__add__')
+    def __radd__(self, other):
+        if isinstance(other, self._expr_type):
+            return other
+        else:
+            raise TypeError("Invalid argument types for addition")
+
+    @call_highest_priority('__rsub__')
+    def __sub__(self, other):
+        if isinstance(other, self._expr_type):
+            return -other
+        else:
+            raise TypeError("Invalid argument types for subtraction")
+
+    @call_highest_priority('__sub__')
+    def __rsub__(self, other):
+        if isinstance(other, self._expr_type):
+            return other
+        else:
+            raise TypeError("Invalid argument types for subtraction")
+
+    def __neg__(self):
+        return self
+
+    def normalize(self):
+        """
+        Returns the normalized version of this vector.
+        """
+        return self
+
+    def _sympystr(self, printer):
+        return '0'
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/coordsysrect.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/coordsysrect.py
new file mode 100644
index 0000000000..7040110642
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/coordsysrect.py
@@ -0,0 +1,1050 @@
+from sympy.utilities.exceptions import SymPyDeprecationWarning
+from sympy.core.basic import Basic
+from sympy.core.compatibility import Callable
+from sympy.core.cache import cacheit
+from sympy.core import S, Dummy, Lambda
+from sympy.core.symbol import Str
+from sympy import symbols, MatrixBase, ImmutableDenseMatrix
+from sympy.solvers import solve
+from sympy.vector.scalar import BaseScalar
+from sympy import eye, trigsimp, ImmutableMatrix as Matrix, sin, cos,\
+    sqrt, diff, Tuple, acos, atan2, simplify
+import sympy.vector
+from sympy.vector.orienters import (Orienter, AxisOrienter, BodyOrienter,
+                                    SpaceOrienter, QuaternionOrienter)
+
+
+def CoordSysCartesian(*args, **kwargs):
+    SymPyDeprecationWarning(
+        feature="CoordSysCartesian",
+        useinstead="CoordSys3D",
+        issue=12865,
+        deprecated_since_version="1.1"
+    ).warn()
+    return CoordSys3D(*args, **kwargs)
+
+
+class CoordSys3D(Basic):
+    """
+    Represents a coordinate system in 3-D space.
+    """
+
+    def __new__(cls, name, transformation=None, parent=None, location=None,
+                rotation_matrix=None, vector_names=None, variable_names=None):
+        """
+        The orientation/location parameters are necessary if this system
+        is being defined at a certain orientation or location wrt another.
+
+        Parameters
+        ==========
+
+        name : str
+            The name of the new CoordSys3D instance.
+
+        transformation : Lambda, Tuple, str
+            Transformation defined by transformation equations or chosen
+            from predefined ones.
+
+        location : Vector
+            The position vector of the new system's origin wrt the parent
+            instance.
+
+        rotation_matrix : SymPy ImmutableMatrix
+            The rotation matrix of the new coordinate system with respect
+            to the parent. In other words, the output of
+            new_system.rotation_matrix(parent).
+
+        parent : CoordSys3D
+            The coordinate system wrt which the orientation/location
+            (or both) is being defined.
+
+        vector_names, variable_names : iterable(optional)
+            Iterables of 3 strings each, with custom names for base
+            vectors and base scalars of the new system respectively.
+            Used for simple str printing.
+
+        """
+
+        name = str(name)
+        Vector = sympy.vector.Vector
+        Point = sympy.vector.Point
+
+        if not isinstance(name, str):
+            raise TypeError("name should be a string")
+
+        if transformation is not None:
+            if (location is not None) or (rotation_matrix is not None):
+                raise ValueError("specify either `transformation` or "
+                                 "`location`/`rotation_matrix`")
+            if isinstance(transformation, (Tuple, tuple, list)):
+                if isinstance(transformation[0], MatrixBase):
+                    rotation_matrix = transformation[0]
+                    location = transformation[1]
+                else:
+                    transformation = Lambda(transformation[0],
+                                            transformation[1])
+            elif isinstance(transformation, Callable):
+                x1, x2, x3 = symbols('x1 x2 x3', cls=Dummy)
+                transformation = Lambda((x1, x2, x3),
+                                        transformation(x1, x2, x3))
+            elif isinstance(transformation, str):
+                transformation = Str(transformation)
+            elif isinstance(transformation, (Str, Lambda)):
+                pass
+            else:
+                raise TypeError("transformation: "
+                                "wrong type {}".format(type(transformation)))
+
+        # If orientation information has been provided, store
+        # the rotation matrix accordingly
+        if rotation_matrix is None:
+            rotation_matrix = ImmutableDenseMatrix(eye(3))
+        else:
+            if not isinstance(rotation_matrix, MatrixBase):
+                raise TypeError("rotation_matrix should be an Immutable" +
+                                "Matrix instance")
+            rotation_matrix = rotation_matrix.as_immutable()
+
+        # If location information is not given, adjust the default
+        # location as Vector.zero
+        if parent is not None:
+            if not isinstance(parent, CoordSys3D):
+                raise TypeError("parent should be a " +
+                                "CoordSys3D/None")
+            if location is None:
+                location = Vector.zero
+            else:
+                if not isinstance(location, Vector):
+                    raise TypeError("location should be a Vector")
+                # Check that location does not contain base
+                # scalars
+                for x in location.free_symbols:
+                    if isinstance(x, BaseScalar):
+                        raise ValueError("location should not contain" +
+                                         " BaseScalars")
+            origin = parent.origin.locate_new(name + '.origin',
+                                              location)
+        else:
+            location = Vector.zero
+            origin = Point(name + '.origin')
+
+        if transformation is None:
+            transformation = Tuple(rotation_matrix, location)
+
+        if isinstance(transformation, Tuple):
+            lambda_transformation = CoordSys3D._compose_rotation_and_translation(
+                transformation[0],
+                transformation[1],
+                parent
+            )
+            r, l = transformation
+            l = l._projections
+            lambda_lame = CoordSys3D._get_lame_coeff('cartesian')
+            lambda_inverse = lambda x, y, z: r.inv()*Matrix(
+                [x-l[0], y-l[1], z-l[2]])
+        elif isinstance(transformation, Str):
+            trname = transformation.name
+            lambda_transformation = CoordSys3D._get_transformation_lambdas(trname)
+            if parent is not None:
+                if parent.lame_coefficients() != (S.One, S.One, S.One):
+                    raise ValueError('Parent for pre-defined coordinate '
+                                 'system should be Cartesian.')
+            lambda_lame = CoordSys3D._get_lame_coeff(trname)
+            lambda_inverse = CoordSys3D._set_inv_trans_equations(trname)
+        elif isinstance(transformation, Lambda):
+            if not CoordSys3D._check_orthogonality(transformation):
+                raise ValueError("The transformation equation does not "
+                                 "create orthogonal coordinate system")
+            lambda_transformation = transformation
+            lambda_lame = CoordSys3D._calculate_lame_coeff(lambda_transformation)
+            lambda_inverse = None
+        else:
+            lambda_transformation = lambda x, y, z: transformation(x, y, z)
+            lambda_lame = CoordSys3D._get_lame_coeff(transformation)
+            lambda_inverse = None
+
+        if variable_names is None:
+            if isinstance(transformation, Lambda):
+                variable_names = ["x1", "x2", "x3"]
+            elif isinstance(transformation, Str):
+                if transformation.name == 'spherical':
+                    variable_names = ["r", "theta", "phi"]
+                elif transformation.name == 'cylindrical':
+                    variable_names = ["r", "theta", "z"]
+                else:
+                    variable_names = ["x", "y", "z"]
+            else:
+                variable_names = ["x", "y", "z"]
+        if vector_names is None:
+            vector_names = ["i", "j", "k"]
+
+        # All systems that are defined as 'roots' are unequal, unless
+        # they have the same name.
+        # Systems defined at same orientation/position wrt the same
+        # 'parent' are equal, irrespective of the name.
+        # This is true even if the same orientation is provided via
+        # different methods like Axis/Body/Space/Quaternion.
+        # However, coincident systems may be seen as unequal if
+        # positioned/oriented wrt different parents, even though
+        # they may actually be 'coincident' wrt the root system.
+        if parent is not None:
+            obj = super().__new__(
+                cls, Str(name), transformation, parent)
+        else:
+            obj = super().__new__(
+                cls, Str(name), transformation)
+        obj._name = name
+        # Initialize the base vectors
+
+        _check_strings('vector_names', vector_names)
+        vector_names = list(vector_names)
+        latex_vects = [(r'\mathbf{\hat{%s}_{%s}}' % (x, name)) for
+                           x in vector_names]
+        pretty_vects = ['%s_%s' % (x, name) for x in vector_names]
+
+        obj._vector_names = vector_names
+
+        v1 = BaseVector(0, obj, pretty_vects[0], latex_vects[0])
+        v2 = BaseVector(1, obj, pretty_vects[1], latex_vects[1])
+        v3 = BaseVector(2, obj, pretty_vects[2], latex_vects[2])
+
+        obj._base_vectors = (v1, v2, v3)
+
+        # Initialize the base scalars
+
+        _check_strings('variable_names', vector_names)
+        variable_names = list(variable_names)
+        latex_scalars = [(r"\mathbf{{%s}_{%s}}" % (x, name)) for
+                         x in variable_names]
+        pretty_scalars = ['%s_%s' % (x, name) for x in variable_names]
+
+        obj._variable_names = variable_names
+        obj._vector_names = vector_names
+
+        x1 = BaseScalar(0, obj, pretty_scalars[0], latex_scalars[0])
+        x2 = BaseScalar(1, obj, pretty_scalars[1], latex_scalars[1])
+        x3 = BaseScalar(2, obj, pretty_scalars[2], latex_scalars[2])
+
+        obj._base_scalars = (x1, x2, x3)
+
+        obj._transformation = transformation
+        obj._transformation_lambda = lambda_transformation
+        obj._lame_coefficients = lambda_lame(x1, x2, x3)
+        obj._transformation_from_parent_lambda = lambda_inverse
+
+        setattr(obj, variable_names[0], x1)
+        setattr(obj, variable_names[1], x2)
+        setattr(obj, variable_names[2], x3)
+
+        setattr(obj, vector_names[0], v1)
+        setattr(obj, vector_names[1], v2)
+        setattr(obj, vector_names[2], v3)
+
+        # Assign params
+        obj._parent = parent
+        if obj._parent is not None:
+            obj._root = obj._parent._root
+        else:
+            obj._root = obj
+
+        obj._parent_rotation_matrix = rotation_matrix
+        obj._origin = origin
+
+        # Return the instance
+        return obj
+
+    def _sympystr(self, printer):
+        return self._name
+
+    def __iter__(self):
+        return iter(self.base_vectors())
+
+    @staticmethod
+    def _check_orthogonality(equations):
+        """
+        Helper method for _connect_to_cartesian. It checks if
+        set of transformation equations create orthogonal curvilinear
+        coordinate system
+
+        Parameters
+        ==========
+
+        equations : Lambda
+            Lambda of transformation equations
+
+        """
+
+        x1, x2, x3 = symbols("x1, x2, x3", cls=Dummy)
+        equations = equations(x1, x2, x3)
+        v1 = Matrix([diff(equations[0], x1),
+                     diff(equations[1], x1), diff(equations[2], x1)])
+
+        v2 = Matrix([diff(equations[0], x2),
+                     diff(equations[1], x2), diff(equations[2], x2)])
+
+        v3 = Matrix([diff(equations[0], x3),
+                     diff(equations[1], x3), diff(equations[2], x3)])
+
+        if any(simplify(i[0] + i[1] + i[2]) == 0 for i in (v1, v2, v3)):
+            return False
+        else:
+            if simplify(v1.dot(v2)) == 0 and simplify(v2.dot(v3)) == 0 \
+                and simplify(v3.dot(v1)) == 0:
+                return True
+            else:
+                return False
+
+    @staticmethod
+    def _set_inv_trans_equations(curv_coord_name):
+        """
+        Store information about inverse transformation equations for
+        pre-defined coordinate systems.
+
+        Parameters
+        ==========
+
+        curv_coord_name : str
+            Name of coordinate system
+
+        """
+        if curv_coord_name == 'cartesian':
+            return lambda x, y, z: (x, y, z)
+
+        if curv_coord_name == 'spherical':
+            return lambda x, y, z: (
+                sqrt(x**2 + y**2 + z**2),
+                acos(z/sqrt(x**2 + y**2 + z**2)),
+                atan2(y, x)
+            )
+        if curv_coord_name == 'cylindrical':
+            return lambda x, y, z: (
+                sqrt(x**2 + y**2),
+                atan2(y, x),
+                z
+            )
+        raise ValueError('Wrong set of parameters.'
+                         'Type of coordinate system is defined')
+
+    def _calculate_inv_trans_equations(self):
+        """
+        Helper method for set_coordinate_type. It calculates inverse
+        transformation equations for given transformations equations.
+
+        """
+        x1, x2, x3 = symbols("x1, x2, x3", cls=Dummy, reals=True)
+        x, y, z = symbols("x, y, z", cls=Dummy)
+
+        equations = self._transformation(x1, x2, x3)
+
+        solved = solve([equations[0] - x,
+                        equations[1] - y,
+                        equations[2] - z], (x1, x2, x3), dict=True)[0]
+        solved = solved[x1], solved[x2], solved[x3]
+        self._transformation_from_parent_lambda = \
+            lambda x1, x2, x3: tuple(i.subs(list(zip((x, y, z), (x1, x2, x3)))) for i in solved)
+
+    @staticmethod
+    def _get_lame_coeff(curv_coord_name):
+        """
+        Store information about Lame coefficients for pre-defined
+        coordinate systems.
+
+        Parameters
+        ==========
+
+        curv_coord_name : str
+            Name of coordinate system
+
+        """
+        if isinstance(curv_coord_name, str):
+            if curv_coord_name == 'cartesian':
+                return lambda x, y, z: (S.One, S.One, S.One)
+            if curv_coord_name == 'spherical':
+                return lambda r, theta, phi: (S.One, r, r*sin(theta))
+            if curv_coord_name == 'cylindrical':
+                return lambda r, theta, h: (S.One, r, S.One)
+            raise ValueError('Wrong set of parameters.'
+                             ' Type of coordinate system is not defined')
+        return CoordSys3D._calculate_lame_coefficients(curv_coord_name)
+
+    @staticmethod
+    def _calculate_lame_coeff(equations):
+        """
+        It calculates Lame coefficients
+        for given transformations equations.
+
+        Parameters
+        ==========
+
+        equations : Lambda
+            Lambda of transformation equations.
+
+        """
+        return lambda x1, x2, x3: (
+                          sqrt(diff(equations(x1, x2, x3)[0], x1)**2 +
+                               diff(equations(x1, x2, x3)[1], x1)**2 +
+                               diff(equations(x1, x2, x3)[2], x1)**2),
+                          sqrt(diff(equations(x1, x2, x3)[0], x2)**2 +
+                               diff(equations(x1, x2, x3)[1], x2)**2 +
+                               diff(equations(x1, x2, x3)[2], x2)**2),
+                          sqrt(diff(equations(x1, x2, x3)[0], x3)**2 +
+                               diff(equations(x1, x2, x3)[1], x3)**2 +
+                               diff(equations(x1, x2, x3)[2], x3)**2)
+                      )
+
+    def _inverse_rotation_matrix(self):
+        """
+        Returns inverse rotation matrix.
+        """
+        return simplify(self._parent_rotation_matrix**-1)
+
+    @staticmethod
+    def _get_transformation_lambdas(curv_coord_name):
+        """
+        Store information about transformation equations for pre-defined
+        coordinate systems.
+
+        Parameters
+        ==========
+
+        curv_coord_name : str
+            Name of coordinate system
+
+        """
+        if isinstance(curv_coord_name, str):
+            if curv_coord_name == 'cartesian':
+                return lambda x, y, z: (x, y, z)
+            if curv_coord_name == 'spherical':
+                return lambda r, theta, phi: (
+                    r*sin(theta)*cos(phi),
+                    r*sin(theta)*sin(phi),
+                    r*cos(theta)
+                )
+            if curv_coord_name == 'cylindrical':
+                return lambda r, theta, h: (
+                    r*cos(theta),
+                    r*sin(theta),
+                    h
+                )
+            raise ValueError('Wrong set of parameters.'
+                             'Type of coordinate system is defined')
+
+    @classmethod
+    def _rotation_trans_equations(cls, matrix, equations):
+        """
+        Returns the transformation equations obtained from rotation matrix.
+
+        Parameters
+        ==========
+
+        matrix : Matrix
+            Rotation matrix
+
+        equations : tuple
+            Transformation equations
+
+        """
+        return tuple(matrix * Matrix(equations))
+
+    @property
+    def origin(self):
+        return self._origin
+
+    @property
+    def delop(self):
+        SymPyDeprecationWarning(
+            feature="coord_system.delop has been replaced.",
+            useinstead="Use the Del() class",
+            deprecated_since_version="1.1",
+            issue=12866,
+        ).warn()
+        from sympy.vector.deloperator import Del
+        return Del()
+
+    def base_vectors(self):
+        return self._base_vectors
+
+    def base_scalars(self):
+        return self._base_scalars
+
+    def lame_coefficients(self):
+        return self._lame_coefficients
+
+    def transformation_to_parent(self):
+        return self._transformation_lambda(*self.base_scalars())
+
+    def transformation_from_parent(self):
+        if self._parent is None:
+            raise ValueError("no parent coordinate system, use "
+                             "`transformation_from_parent_function()`")
+        return self._transformation_from_parent_lambda(
+                            *self._parent.base_scalars())
+
+    def transformation_from_parent_function(self):
+        return self._transformation_from_parent_lambda
+
+    def rotation_matrix(self, other):
+        """
+        Returns the direction cosine matrix(DCM), also known as the
+        'rotation matrix' of this coordinate system with respect to
+        another system.
+
+        If v_a is a vector defined in system 'A' (in matrix format)
+        and v_b is the same vector defined in system 'B', then
+        v_a = A.rotation_matrix(B) * v_b.
+
+        A SymPy Matrix is returned.
+
+        Parameters
+        ==========
+
+        other : CoordSys3D
+            The system which the DCM is generated to.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import symbols
+        >>> q1 = symbols('q1')
+        >>> N = CoordSys3D('N')
+        >>> A = N.orient_new_axis('A', q1, N.i)
+        >>> N.rotation_matrix(A)
+        Matrix([
+        [1,       0,        0],
+        [0, cos(q1), -sin(q1)],
+        [0, sin(q1),  cos(q1)]])
+
+        """
+        from sympy.vector.functions import _path
+        if not isinstance(other, CoordSys3D):
+            raise TypeError(str(other) +
+                            " is not a CoordSys3D")
+        # Handle special cases
+        if other == self:
+            return eye(3)
+        elif other == self._parent:
+            return self._parent_rotation_matrix
+        elif other._parent == self:
+            return other._parent_rotation_matrix.T
+        # Else, use tree to calculate position
+        rootindex, path = _path(self, other)
+        result = eye(3)
+        i = -1
+        for i in range(rootindex):
+            result *= path[i]._parent_rotation_matrix
+        i += 2
+        while i < len(path):
+            result *= path[i]._parent_rotation_matrix.T
+            i += 1
+        return result
+
+    @cacheit
+    def position_wrt(self, other):
+        """
+        Returns the position vector of the origin of this coordinate
+        system with respect to another Point/CoordSys3D.
+
+        Parameters
+        ==========
+
+        other : Point/CoordSys3D
+            If other is a Point, the position of this system's origin
+            wrt it is returned. If its an instance of CoordSyRect,
+            the position wrt its origin is returned.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> N = CoordSys3D('N')
+        >>> N1 = N.locate_new('N1', 10 * N.i)
+        >>> N.position_wrt(N1)
+        (-10)*N.i
+
+        """
+        return self.origin.position_wrt(other)
+
+    def scalar_map(self, other):
+        """
+        Returns a dictionary which expresses the coordinate variables
+        (base scalars) of this frame in terms of the variables of
+        otherframe.
+
+        Parameters
+        ==========
+
+        otherframe : CoordSys3D
+            The other system to map the variables to.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import Symbol
+        >>> A = CoordSys3D('A')
+        >>> q = Symbol('q')
+        >>> B = A.orient_new_axis('B', q, A.k)
+        >>> A.scalar_map(B)
+        {A.x: B.x*cos(q) - B.y*sin(q), A.y: B.x*sin(q) + B.y*cos(q), A.z: B.z}
+
+        """
+
+        relocated_scalars = []
+        origin_coords = tuple(self.position_wrt(other).to_matrix(other))
+        for i, x in enumerate(other.base_scalars()):
+            relocated_scalars.append(x - origin_coords[i])
+
+        vars_matrix = (self.rotation_matrix(other) *
+                       Matrix(relocated_scalars))
+        mapping = {}
+        for i, x in enumerate(self.base_scalars()):
+            mapping[x] = trigsimp(vars_matrix[i])
+        return mapping
+
+    def locate_new(self, name, position, vector_names=None,
+                   variable_names=None):
+        """
+        Returns a CoordSys3D with its origin located at the given
+        position wrt this coordinate system's origin.
+
+        Parameters
+        ==========
+
+        name : str
+            The name of the new CoordSys3D instance.
+
+        position : Vector
+            The position vector of the new system's origin wrt this
+            one.
+
+        vector_names, variable_names : iterable(optional)
+            Iterables of 3 strings each, with custom names for base
+            vectors and base scalars of the new system respectively.
+            Used for simple str printing.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> A = CoordSys3D('A')
+        >>> B = A.locate_new('B', 10 * A.i)
+        >>> B.origin.position_wrt(A.origin)
+        10*A.i
+
+        """
+        if variable_names is None:
+            variable_names = self._variable_names
+        if vector_names is None:
+            vector_names = self._vector_names
+
+        return CoordSys3D(name, location=position,
+                          vector_names=vector_names,
+                          variable_names=variable_names,
+                          parent=self)
+
+    def orient_new(self, name, orienters, location=None,
+                   vector_names=None, variable_names=None):
+        """
+        Creates a new CoordSys3D oriented in the user-specified way
+        with respect to this system.
+
+        Please refer to the documentation of the orienter classes
+        for more information about the orientation procedure.
+
+        Parameters
+        ==========
+
+        name : str
+            The name of the new CoordSys3D instance.
+
+        orienters : iterable/Orienter
+            An Orienter or an iterable of Orienters for orienting the
+            new coordinate system.
+            If an Orienter is provided, it is applied to get the new
+            system.
+            If an iterable is provided, the orienters will be applied
+            in the order in which they appear in the iterable.
+
+        location : Vector(optional)
+            The location of the new coordinate system's origin wrt this
+            system's origin. If not specified, the origins are taken to
+            be coincident.
+
+        vector_names, variable_names : iterable(optional)
+            Iterables of 3 strings each, with custom names for base
+            vectors and base scalars of the new system respectively.
+            Used for simple str printing.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import symbols
+        >>> q0, q1, q2, q3 = symbols('q0 q1 q2 q3')
+        >>> N = CoordSys3D('N')
+
+        Using an AxisOrienter
+
+        >>> from sympy.vector import AxisOrienter
+        >>> axis_orienter = AxisOrienter(q1, N.i + 2 * N.j)
+        >>> A = N.orient_new('A', (axis_orienter, ))
+
+        Using a BodyOrienter
+
+        >>> from sympy.vector import BodyOrienter
+        >>> body_orienter = BodyOrienter(q1, q2, q3, '123')
+        >>> B = N.orient_new('B', (body_orienter, ))
+
+        Using a SpaceOrienter
+
+        >>> from sympy.vector import SpaceOrienter
+        >>> space_orienter = SpaceOrienter(q1, q2, q3, '312')
+        >>> C = N.orient_new('C', (space_orienter, ))
+
+        Using a QuaternionOrienter
+
+        >>> from sympy.vector import QuaternionOrienter
+        >>> q_orienter = QuaternionOrienter(q0, q1, q2, q3)
+        >>> D = N.orient_new('D', (q_orienter, ))
+        """
+        if variable_names is None:
+            variable_names = self._variable_names
+        if vector_names is None:
+            vector_names = self._vector_names
+
+        if isinstance(orienters, Orienter):
+            if isinstance(orienters, AxisOrienter):
+                final_matrix = orienters.rotation_matrix(self)
+            else:
+                final_matrix = orienters.rotation_matrix()
+            # TODO: trigsimp is needed here so that the matrix becomes
+            # canonical (scalar_map also calls trigsimp; without this, you can
+            # end up with the same CoordinateSystem that compares differently
+            # due to a differently formatted matrix). However, this is
+            # probably not so good for performance.
+            final_matrix = trigsimp(final_matrix)
+        else:
+            final_matrix = Matrix(eye(3))
+            for orienter in orienters:
+                if isinstance(orienter, AxisOrienter):
+                    final_matrix *= orienter.rotation_matrix(self)
+                else:
+                    final_matrix *= orienter.rotation_matrix()
+
+        return CoordSys3D(name, rotation_matrix=final_matrix,
+                          vector_names=vector_names,
+                          variable_names=variable_names,
+                          location=location,
+                          parent=self)
+
+    def orient_new_axis(self, name, angle, axis, location=None,
+                        vector_names=None, variable_names=None):
+        """
+        Axis rotation is a rotation about an arbitrary axis by
+        some angle. The angle is supplied as a SymPy expr scalar, and
+        the axis is supplied as a Vector.
+
+        Parameters
+        ==========
+
+        name : string
+            The name of the new coordinate system
+
+        angle : Expr
+            The angle by which the new system is to be rotated
+
+        axis : Vector
+            The axis around which the rotation has to be performed
+
+        location : Vector(optional)
+            The location of the new coordinate system's origin wrt this
+            system's origin. If not specified, the origins are taken to
+            be coincident.
+
+        vector_names, variable_names : iterable(optional)
+            Iterables of 3 strings each, with custom names for base
+            vectors and base scalars of the new system respectively.
+            Used for simple str printing.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import symbols
+        >>> q1 = symbols('q1')
+        >>> N = CoordSys3D('N')
+        >>> B = N.orient_new_axis('B', q1, N.i + 2 * N.j)
+
+        """
+        if variable_names is None:
+            variable_names = self._variable_names
+        if vector_names is None:
+            vector_names = self._vector_names
+
+        orienter = AxisOrienter(angle, axis)
+        return self.orient_new(name, orienter,
+                               location=location,
+                               vector_names=vector_names,
+                               variable_names=variable_names)
+
+    def orient_new_body(self, name, angle1, angle2, angle3,
+                        rotation_order, location=None,
+                        vector_names=None, variable_names=None):
+        """
+        Body orientation takes this coordinate system through three
+        successive simple rotations.
+
+        Body fixed rotations include both Euler Angles and
+        Tait-Bryan Angles, see https://en.wikipedia.org/wiki/Euler_angles.
+
+        Parameters
+        ==========
+
+        name : string
+            The name of the new coordinate system
+
+        angle1, angle2, angle3 : Expr
+            Three successive angles to rotate the coordinate system by
+
+        rotation_order : string
+            String defining the order of axes for rotation
+
+        location : Vector(optional)
+            The location of the new coordinate system's origin wrt this
+            system's origin. If not specified, the origins are taken to
+            be coincident.
+
+        vector_names, variable_names : iterable(optional)
+            Iterables of 3 strings each, with custom names for base
+            vectors and base scalars of the new system respectively.
+            Used for simple str printing.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import symbols
+        >>> q1, q2, q3 = symbols('q1 q2 q3')
+        >>> N = CoordSys3D('N')
+
+        A 'Body' fixed rotation is described by three angles and
+        three body-fixed rotation axes. To orient a coordinate system D
+        with respect to N, each sequential rotation is always about
+        the orthogonal unit vectors fixed to D. For example, a '123'
+        rotation will specify rotations about N.i, then D.j, then
+        D.k. (Initially, D.i is same as N.i)
+        Therefore,
+
+        >>> D = N.orient_new_body('D', q1, q2, q3, '123')
+
+        is same as
+
+        >>> D = N.orient_new_axis('D', q1, N.i)
+        >>> D = D.orient_new_axis('D', q2, D.j)
+        >>> D = D.orient_new_axis('D', q3, D.k)
+
+        Acceptable rotation orders are of length 3, expressed in XYZ or
+        123, and cannot have a rotation about about an axis twice in a row.
+
+        >>> B = N.orient_new_body('B', q1, q2, q3, '123')
+        >>> B = N.orient_new_body('B', q1, q2, 0, 'ZXZ')
+        >>> B = N.orient_new_body('B', 0, 0, 0, 'XYX')
+
+        """
+
+        orienter = BodyOrienter(angle1, angle2, angle3, rotation_order)
+        return self.orient_new(name, orienter,
+                               location=location,
+                               vector_names=vector_names,
+                               variable_names=variable_names)
+
+    def orient_new_space(self, name, angle1, angle2, angle3,
+                         rotation_order, location=None,
+                         vector_names=None, variable_names=None):
+        """
+        Space rotation is similar to Body rotation, but the rotations
+        are applied in the opposite order.
+
+        Parameters
+        ==========
+
+        name : string
+            The name of the new coordinate system
+
+        angle1, angle2, angle3 : Expr
+            Three successive angles to rotate the coordinate system by
+
+        rotation_order : string
+            String defining the order of axes for rotation
+
+        location : Vector(optional)
+            The location of the new coordinate system's origin wrt this
+            system's origin. If not specified, the origins are taken to
+            be coincident.
+
+        vector_names, variable_names : iterable(optional)
+            Iterables of 3 strings each, with custom names for base
+            vectors and base scalars of the new system respectively.
+            Used for simple str printing.
+
+        See Also
+        ========
+
+        CoordSys3D.orient_new_body : method to orient via Euler
+            angles
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import symbols
+        >>> q1, q2, q3 = symbols('q1 q2 q3')
+        >>> N = CoordSys3D('N')
+
+        To orient a coordinate system D with respect to N, each
+        sequential rotation is always about N's orthogonal unit vectors.
+        For example, a '123' rotation will specify rotations about
+        N.i, then N.j, then N.k.
+        Therefore,
+
+        >>> D = N.orient_new_space('D', q1, q2, q3, '312')
+
+        is same as
+
+        >>> B = N.orient_new_axis('B', q1, N.i)
+        >>> C = B.orient_new_axis('C', q2, N.j)
+        >>> D = C.orient_new_axis('D', q3, N.k)
+
+        """
+
+        orienter = SpaceOrienter(angle1, angle2, angle3, rotation_order)
+        return self.orient_new(name, orienter,
+                               location=location,
+                               vector_names=vector_names,
+                               variable_names=variable_names)
+
+    def orient_new_quaternion(self, name, q0, q1, q2, q3, location=None,
+                              vector_names=None, variable_names=None):
+        """
+        Quaternion orientation orients the new CoordSys3D with
+        Quaternions, defined as a finite rotation about lambda, a unit
+        vector, by some amount theta.
+
+        This orientation is described by four parameters:
+
+        q0 = cos(theta/2)
+
+        q1 = lambda_x sin(theta/2)
+
+        q2 = lambda_y sin(theta/2)
+
+        q3 = lambda_z sin(theta/2)
+
+        Quaternion does not take in a rotation order.
+
+        Parameters
+        ==========
+
+        name : string
+            The name of the new coordinate system
+
+        q0, q1, q2, q3 : Expr
+            The quaternions to rotate the coordinate system by
+
+        location : Vector(optional)
+            The location of the new coordinate system's origin wrt this
+            system's origin. If not specified, the origins are taken to
+            be coincident.
+
+        vector_names, variable_names : iterable(optional)
+            Iterables of 3 strings each, with custom names for base
+            vectors and base scalars of the new system respectively.
+            Used for simple str printing.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import symbols
+        >>> q0, q1, q2, q3 = symbols('q0 q1 q2 q3')
+        >>> N = CoordSys3D('N')
+        >>> B = N.orient_new_quaternion('B', q0, q1, q2, q3)
+
+        """
+
+        orienter = QuaternionOrienter(q0, q1, q2, q3)
+        return self.orient_new(name, orienter,
+                               location=location,
+                               vector_names=vector_names,
+                               variable_names=variable_names)
+
+    def create_new(self, name, transformation, variable_names=None, vector_names=None):
+        """
+        Returns a CoordSys3D which is connected to self by transformation.
+
+        Parameters
+        ==========
+
+        name : str
+            The name of the new CoordSys3D instance.
+
+        transformation : Lambda, Tuple, str
+            Transformation defined by transformation equations or chosen
+            from predefined ones.
+
+        vector_names, variable_names : iterable(optional)
+            Iterables of 3 strings each, with custom names for base
+            vectors and base scalars of the new system respectively.
+            Used for simple str printing.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> a = CoordSys3D('a')
+        >>> b = a.create_new('b', transformation='spherical')
+        >>> b.transformation_to_parent()
+        (b.r*sin(b.theta)*cos(b.phi), b.r*sin(b.phi)*sin(b.theta), b.r*cos(b.theta))
+        >>> b.transformation_from_parent()
+        (sqrt(a.x**2 + a.y**2 + a.z**2), acos(a.z/sqrt(a.x**2 + a.y**2 + a.z**2)), atan2(a.y, a.x))
+
+        """
+        return CoordSys3D(name, parent=self, transformation=transformation,
+                          variable_names=variable_names, vector_names=vector_names)
+
+    def __init__(self, name, location=None, rotation_matrix=None,
+                 parent=None, vector_names=None, variable_names=None,
+                 latex_vects=None, pretty_vects=None, latex_scalars=None,
+                 pretty_scalars=None, transformation=None):
+        # Dummy initializer for setting docstring
+        pass
+
+    __init__.__doc__ = __new__.__doc__
+
+    @staticmethod
+    def _compose_rotation_and_translation(rot, translation, parent):
+        r = lambda x, y, z: CoordSys3D._rotation_trans_equations(rot, (x, y, z))
+        if parent is None:
+            return r
+
+        dx, dy, dz = [translation.dot(i) for i in parent.base_vectors()]
+        t = lambda x, y, z: (
+            x + dx,
+            y + dy,
+            z + dz,
+        )
+        return lambda x, y, z: t(*r(x, y, z))
+
+
+def _check_strings(arg_name, arg):
+    errorstr = arg_name + " must be an iterable of 3 string-types"
+    if len(arg) != 3:
+        raise ValueError(errorstr)
+    for s in arg:
+        if not isinstance(s, str):
+            raise TypeError(errorstr)
+
+
+# Delayed import to avoid cyclic import problems:
+from sympy.vector.vector import BaseVector
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/deloperator.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/deloperator.py
new file mode 100644
index 0000000000..cb8b92b91e
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/deloperator.py
@@ -0,0 +1,129 @@
+from sympy.utilities.exceptions import SymPyDeprecationWarning
+from sympy.core import Basic
+from sympy.vector.operators import gradient, divergence, curl
+
+
+class Del(Basic):
+    """
+    Represents the vector differential operator, usually represented in
+    mathematical expressions as the 'nabla' symbol.
+    """
+
+    def __new__(cls, system=None):
+        if system is not None:
+            SymPyDeprecationWarning(
+                feature="delop operator inside coordinate system",
+                useinstead="it as instance Del class",
+                deprecated_since_version="1.1",
+                issue=12866,
+            ).warn()
+        obj = super().__new__(cls)
+        obj._name = "delop"
+        return obj
+
+    def gradient(self, scalar_field, doit=False):
+        """
+        Returns the gradient of the given scalar field, as a
+        Vector instance.
+
+        Parameters
+        ==========
+
+        scalar_field : SymPy expression
+            The scalar field to calculate the gradient of.
+
+        doit : bool
+            If True, the result is returned after calling .doit() on
+            each component. Else, the returned expression contains
+            Derivative instances
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D, Del
+        >>> C = CoordSys3D('C')
+        >>> delop = Del()
+        >>> delop.gradient(9)
+        0
+        >>> delop(C.x*C.y*C.z).doit()
+        C.y*C.z*C.i + C.x*C.z*C.j + C.x*C.y*C.k
+
+        """
+
+        return gradient(scalar_field, doit=doit)
+
+    __call__ = gradient
+    __call__.__doc__ = gradient.__doc__
+
+    def dot(self, vect, doit=False):
+        """
+        Represents the dot product between this operator and a given
+        vector - equal to the divergence of the vector field.
+
+        Parameters
+        ==========
+
+        vect : Vector
+            The vector whose divergence is to be calculated.
+
+        doit : bool
+            If True, the result is returned after calling .doit() on
+            each component. Else, the returned expression contains
+            Derivative instances
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D, Del
+        >>> delop = Del()
+        >>> C = CoordSys3D('C')
+        >>> delop.dot(C.x*C.i)
+        Derivative(C.x, C.x)
+        >>> v = C.x*C.y*C.z * (C.i + C.j + C.k)
+        >>> (delop & v).doit()
+        C.x*C.y + C.x*C.z + C.y*C.z
+
+        """
+        return divergence(vect, doit=doit)
+
+    __and__ = dot
+    __and__.__doc__ = dot.__doc__
+
+    def cross(self, vect, doit=False):
+        """
+        Represents the cross product between this operator and a given
+        vector - equal to the curl of the vector field.
+
+        Parameters
+        ==========
+
+        vect : Vector
+            The vector whose curl is to be calculated.
+
+        doit : bool
+            If True, the result is returned after calling .doit() on
+            each component. Else, the returned expression contains
+            Derivative instances
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D, Del
+        >>> C = CoordSys3D('C')
+        >>> delop = Del()
+        >>> v = C.x*C.y*C.z * (C.i + C.j + C.k)
+        >>> delop.cross(v, doit = True)
+        (-C.x*C.y + C.x*C.z)*C.i + (C.x*C.y - C.y*C.z)*C.j +
+            (-C.x*C.z + C.y*C.z)*C.k
+        >>> (delop ^ C.i).doit()
+        0
+
+        """
+
+        return curl(vect, doit=doit)
+
+    __xor__ = cross
+    __xor__.__doc__ = cross.__doc__
+
+    def _sympystr(self, printer):
+        return self._name
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/dyadic.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/dyadic.py
new file mode 100644
index 0000000000..b0bdd5f2dc
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/dyadic.py
@@ -0,0 +1,281 @@
+from typing import Type
+
+from sympy.vector.basisdependent import (BasisDependent, BasisDependentAdd,
+                                         BasisDependentMul, BasisDependentZero)
+from sympy.core import S, Pow
+from sympy.core.expr import AtomicExpr
+from sympy import ImmutableMatrix as Matrix
+import sympy.vector
+
+
+class Dyadic(BasisDependent):
+    """
+    Super class for all Dyadic-classes.
+
+    References
+    ==========
+
+    .. [1] https://en.wikipedia.org/wiki/Dyadic_tensor
+    .. [2] Kane, T., Levinson, D. Dynamics Theory and Applications. 1985
+           McGraw-Hill
+
+    """
+
+    _op_priority = 13.0
+
+    _expr_type = None  # type: Type[Dyadic]
+    _mul_func = None  # type: Type[Dyadic]
+    _add_func = None  # type: Type[Dyadic]
+    _zero_func = None  # type: Type[Dyadic]
+    _base_func = None  # type: Type[Dyadic]
+    zero = None  # type: DyadicZero
+
+    @property
+    def components(self):
+        """
+        Returns the components of this dyadic in the form of a
+        Python dictionary mapping BaseDyadic instances to the
+        corresponding measure numbers.
+
+        """
+        # The '_components' attribute is defined according to the
+        # subclass of Dyadic the instance belongs to.
+        return self._components
+
+    def dot(self, other):
+        """
+        Returns the dot product(also called inner product) of this
+        Dyadic, with another Dyadic or Vector.
+        If 'other' is a Dyadic, this returns a Dyadic. Else, it returns
+        a Vector (unless an error is encountered).
+
+        Parameters
+        ==========
+
+        other : Dyadic/Vector
+            The other Dyadic or Vector to take the inner product with
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> N = CoordSys3D('N')
+        >>> D1 = N.i.outer(N.j)
+        >>> D2 = N.j.outer(N.j)
+        >>> D1.dot(D2)
+        (N.i|N.j)
+        >>> D1.dot(N.j)
+        N.i
+
+        """
+
+        Vector = sympy.vector.Vector
+        if isinstance(other, BasisDependentZero):
+            return Vector.zero
+        elif isinstance(other, Vector):
+            outvec = Vector.zero
+            for k, v in self.components.items():
+                vect_dot = k.args[1].dot(other)
+                outvec += vect_dot * v * k.args[0]
+            return outvec
+        elif isinstance(other, Dyadic):
+            outdyad = Dyadic.zero
+            for k1, v1 in self.components.items():
+                for k2, v2 in other.components.items():
+                    vect_dot = k1.args[1].dot(k2.args[0])
+                    outer_product = k1.args[0].outer(k2.args[1])
+                    outdyad += vect_dot * v1 * v2 * outer_product
+            return outdyad
+        else:
+            raise TypeError("Inner product is not defined for " +
+                            str(type(other)) + " and Dyadics.")
+
+    def __and__(self, other):
+        return self.dot(other)
+
+    __and__.__doc__ = dot.__doc__
+
+    def cross(self, other):
+        """
+        Returns the cross product between this Dyadic, and a Vector, as a
+        Vector instance.
+
+        Parameters
+        ==========
+
+        other : Vector
+            The Vector that we are crossing this Dyadic with
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> N = CoordSys3D('N')
+        >>> d = N.i.outer(N.i)
+        >>> d.cross(N.j)
+        (N.i|N.k)
+
+        """
+
+        Vector = sympy.vector.Vector
+        if other == Vector.zero:
+            return Dyadic.zero
+        elif isinstance(other, Vector):
+            outdyad = Dyadic.zero
+            for k, v in self.components.items():
+                cross_product = k.args[1].cross(other)
+                outer = k.args[0].outer(cross_product)
+                outdyad += v * outer
+            return outdyad
+        else:
+            raise TypeError(str(type(other)) + " not supported for " +
+                            "cross with dyadics")
+
+    def __xor__(self, other):
+        return self.cross(other)
+
+    __xor__.__doc__ = cross.__doc__
+
+    def to_matrix(self, system, second_system=None):
+        """
+        Returns the matrix form of the dyadic with respect to one or two
+        coordinate systems.
+
+        Parameters
+        ==========
+
+        system : CoordSys3D
+            The coordinate system that the rows and columns of the matrix
+            correspond to. If a second system is provided, this
+            only corresponds to the rows of the matrix.
+        second_system : CoordSys3D, optional, default=None
+            The coordinate system that the columns of the matrix correspond
+            to.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> N = CoordSys3D('N')
+        >>> v = N.i + 2*N.j
+        >>> d = v.outer(N.i)
+        >>> d.to_matrix(N)
+        Matrix([
+        [1, 0, 0],
+        [2, 0, 0],
+        [0, 0, 0]])
+        >>> from sympy import Symbol
+        >>> q = Symbol('q')
+        >>> P = N.orient_new_axis('P', q, N.k)
+        >>> d.to_matrix(N, P)
+        Matrix([
+        [  cos(q),   -sin(q), 0],
+        [2*cos(q), -2*sin(q), 0],
+        [       0,         0, 0]])
+
+        """
+
+        if second_system is None:
+            second_system = system
+
+        return Matrix([i.dot(self).dot(j) for i in system for j in
+                       second_system]).reshape(3, 3)
+
+    def _div_helper(one, other):
+        """ Helper for division involving dyadics """
+        if isinstance(one, Dyadic) and isinstance(other, Dyadic):
+            raise TypeError("Cannot divide two dyadics")
+        elif isinstance(one, Dyadic):
+            return DyadicMul(one, Pow(other, S.NegativeOne))
+        else:
+            raise TypeError("Cannot divide by a dyadic")
+
+
+class BaseDyadic(Dyadic, AtomicExpr):
+    """
+    Class to denote a base dyadic tensor component.
+    """
+
+    def __new__(cls, vector1, vector2):
+        Vector = sympy.vector.Vector
+        BaseVector = sympy.vector.BaseVector
+        VectorZero = sympy.vector.VectorZero
+        # Verify arguments
+        if not isinstance(vector1, (BaseVector, VectorZero)) or \
+                not isinstance(vector2, (BaseVector, VectorZero)):
+            raise TypeError("BaseDyadic cannot be composed of non-base " +
+                            "vectors")
+        # Handle special case of zero vector
+        elif vector1 == Vector.zero or vector2 == Vector.zero:
+            return Dyadic.zero
+        # Initialize instance
+        obj = super().__new__(cls, vector1, vector2)
+        obj._base_instance = obj
+        obj._measure_number = 1
+        obj._components = {obj: S.One}
+        obj._sys = vector1._sys
+        obj._pretty_form = ('(' + vector1._pretty_form + '|' +
+                             vector2._pretty_form + ')')
+        obj._latex_form = ('(' + vector1._latex_form + "{|}" +
+                           vector2._latex_form + ')')
+
+        return obj
+
+    def _sympystr(self, printer):
+        return "({}|{})".format(
+            printer._print(self.args[0]), printer._print(self.args[1]))
+
+
+class DyadicMul(BasisDependentMul, Dyadic):
+    """ Products of scalars and BaseDyadics """
+
+    def __new__(cls, *args, **options):
+        obj = BasisDependentMul.__new__(cls, *args, **options)
+        return obj
+
+    @property
+    def base_dyadic(self):
+        """ The BaseDyadic involved in the product. """
+        return self._base_instance
+
+    @property
+    def measure_number(self):
+        """ The scalar expression involved in the definition of
+        this DyadicMul.
+        """
+        return self._measure_number
+
+
+class DyadicAdd(BasisDependentAdd, Dyadic):
+    """ Class to hold dyadic sums """
+
+    def __new__(cls, *args, **options):
+        obj = BasisDependentAdd.__new__(cls, *args, **options)
+        return obj
+
+    def _sympystr(self, printer):
+        items = list(self.components.items())
+        items.sort(key=lambda x: x[0].__str__())
+        return " + ".join(printer._print(k * v) for k, v in items)
+
+
+class DyadicZero(BasisDependentZero, Dyadic):
+    """
+    Class to denote a zero dyadic
+    """
+
+    _op_priority = 13.1
+    _pretty_form = '(0|0)'
+    _latex_form = r'(\mathbf{\hat{0}}|\mathbf{\hat{0}})'
+
+    def __new__(cls):
+        obj = BasisDependentZero.__new__(cls)
+        return obj
+
+
+Dyadic._expr_type = Dyadic
+Dyadic._mul_func = DyadicMul
+Dyadic._add_func = DyadicAdd
+Dyadic._zero_func = DyadicZero
+Dyadic._base_func = BaseDyadic
+Dyadic.zero = DyadicZero()
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/functions.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/functions.py
new file mode 100644
index 0000000000..d823450cab
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/functions.py
@@ -0,0 +1,518 @@
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.vector.deloperator import Del
+from sympy.vector.scalar import BaseScalar
+from sympy.vector.vector import Vector, BaseVector
+from sympy.vector.operators import gradient, curl, divergence
+from sympy import diff, integrate, S, simplify
+from sympy.core import sympify
+from sympy.vector.dyadic import Dyadic
+
+
+def express(expr, system, system2=None, variables=False):
+    """
+    Global function for 'express' functionality.
+
+    Re-expresses a Vector, Dyadic or scalar(sympyfiable) in the given
+    coordinate system.
+
+    If 'variables' is True, then the coordinate variables (base scalars)
+    of other coordinate systems present in the vector/scalar field or
+    dyadic are also substituted in terms of the base scalars of the
+    given system.
+
+    Parameters
+    ==========
+
+    expr : Vector/Dyadic/scalar(sympyfiable)
+        The expression to re-express in CoordSys3D 'system'
+
+    system: CoordSys3D
+        The coordinate system the expr is to be expressed in
+
+    system2: CoordSys3D
+        The other coordinate system required for re-expression
+        (only for a Dyadic Expr)
+
+    variables : boolean
+        Specifies whether to substitute the coordinate variables present
+        in expr, in terms of those of parameter system
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D
+    >>> from sympy import Symbol, cos, sin
+    >>> N = CoordSys3D('N')
+    >>> q = Symbol('q')
+    >>> B = N.orient_new_axis('B', q, N.k)
+    >>> from sympy.vector import express
+    >>> express(B.i, N)
+    (cos(q))*N.i + (sin(q))*N.j
+    >>> express(N.x, B, variables=True)
+    B.x*cos(q) - B.y*sin(q)
+    >>> d = N.i.outer(N.i)
+    >>> express(d, B, N) == (cos(q))*(B.i|N.i) + (-sin(q))*(B.j|N.i)
+    True
+
+    """
+
+    if expr == 0 or expr == Vector.zero:
+        return expr
+
+    if not isinstance(system, CoordSys3D):
+        raise TypeError("system should be a CoordSys3D \
+                        instance")
+
+    if isinstance(expr, Vector):
+        if system2 is not None:
+            raise ValueError("system2 should not be provided for \
+                                Vectors")
+        # Given expr is a Vector
+        if variables:
+            # If variables attribute is True, substitute
+            # the coordinate variables in the Vector
+            system_list = []
+            for x in expr.atoms(BaseScalar, BaseVector):
+                if x.system != system:
+                    system_list.append(x.system)
+            system_list = set(system_list)
+            subs_dict = {}
+            for f in system_list:
+                subs_dict.update(f.scalar_map(system))
+            expr = expr.subs(subs_dict)
+        # Re-express in this coordinate system
+        outvec = Vector.zero
+        parts = expr.separate()
+        for x in parts:
+            if x != system:
+                temp = system.rotation_matrix(x) * parts[x].to_matrix(x)
+                outvec += matrix_to_vector(temp, system)
+            else:
+                outvec += parts[x]
+        return outvec
+
+    elif isinstance(expr, Dyadic):
+        if system2 is None:
+            system2 = system
+        if not isinstance(system2, CoordSys3D):
+            raise TypeError("system2 should be a CoordSys3D \
+                            instance")
+        outdyad = Dyadic.zero
+        var = variables
+        for k, v in expr.components.items():
+            outdyad += (express(v, system, variables=var) *
+                        (express(k.args[0], system, variables=var) |
+                         express(k.args[1], system2, variables=var)))
+
+        return outdyad
+
+    else:
+        if system2 is not None:
+            raise ValueError("system2 should not be provided for \
+                                Vectors")
+        if variables:
+            # Given expr is a scalar field
+            system_set = set()
+            expr = sympify(expr)
+            # Substitute all the coordinate variables
+            for x in expr.atoms(BaseScalar):
+                if x.system != system:
+                    system_set.add(x.system)
+            subs_dict = {}
+            for f in system_set:
+                subs_dict.update(f.scalar_map(system))
+            return expr.subs(subs_dict)
+        return expr
+
+
+def directional_derivative(field, direction_vector):
+    """
+    Returns the directional derivative of a scalar or vector field computed
+    along a given vector in coordinate system which parameters are expressed.
+
+    Parameters
+    ==========
+
+    field : Vector or Scalar
+        The scalar or vector field to compute the directional derivative of
+
+    direction_vector : Vector
+        The vector to calculated directional derivative along them.
+
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, directional_derivative
+    >>> R = CoordSys3D('R')
+    >>> f1 = R.x*R.y*R.z
+    >>> v1 = 3*R.i + 4*R.j + R.k
+    >>> directional_derivative(f1, v1)
+    R.x*R.y + 4*R.x*R.z + 3*R.y*R.z
+    >>> f2 = 5*R.x**2*R.z
+    >>> directional_derivative(f2, v1)
+    5*R.x**2 + 30*R.x*R.z
+
+    """
+    from sympy.vector.operators import _get_coord_sys_from_expr
+    coord_sys = _get_coord_sys_from_expr(field)
+    if len(coord_sys) > 0:
+        # TODO: This gets a random coordinate system in case of multiple ones:
+        coord_sys = next(iter(coord_sys))
+        field = express(field, coord_sys, variables=True)
+        i, j, k = coord_sys.base_vectors()
+        x, y, z = coord_sys.base_scalars()
+        out = Vector.dot(direction_vector, i) * diff(field, x)
+        out += Vector.dot(direction_vector, j) * diff(field, y)
+        out += Vector.dot(direction_vector, k) * diff(field, z)
+        if out == 0 and isinstance(field, Vector):
+            out = Vector.zero
+        return out
+    elif isinstance(field, Vector):
+        return Vector.zero
+    else:
+        return S.Zero
+
+
+def laplacian(expr):
+    """
+    Return the laplacian of the given field computed in terms of
+    the base scalars of the given coordinate system.
+
+    Parameters
+    ==========
+
+    expr : SymPy Expr or Vector
+        expr denotes a scalar or vector field.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, laplacian
+    >>> R = CoordSys3D('R')
+    >>> f = R.x**2*R.y**5*R.z
+    >>> laplacian(f)
+    20*R.x**2*R.y**3*R.z + 2*R.y**5*R.z
+    >>> f = R.x**2*R.i + R.y**3*R.j + R.z**4*R.k
+    >>> laplacian(f)
+    2*R.i + 6*R.y*R.j + 12*R.z**2*R.k
+
+    """
+
+    delop = Del()
+    if expr.is_Vector:
+        return (gradient(divergence(expr)) - curl(curl(expr))).doit()
+    return delop.dot(delop(expr)).doit()
+
+
+def is_conservative(field):
+    """
+    Checks if a field is conservative.
+
+    Parameters
+    ==========
+
+    field : Vector
+        The field to check for conservative property
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D
+    >>> from sympy.vector import is_conservative
+    >>> R = CoordSys3D('R')
+    >>> is_conservative(R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k)
+    True
+    >>> is_conservative(R.z*R.j)
+    False
+
+    """
+
+    # Field is conservative irrespective of system
+    # Take the first coordinate system in the result of the
+    # separate method of Vector
+    if not isinstance(field, Vector):
+        raise TypeError("field should be a Vector")
+    if field == Vector.zero:
+        return True
+    return curl(field).simplify() == Vector.zero
+
+
+def is_solenoidal(field):
+    """
+    Checks if a field is solenoidal.
+
+    Parameters
+    ==========
+
+    field : Vector
+        The field to check for solenoidal property
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D
+    >>> from sympy.vector import is_solenoidal
+    >>> R = CoordSys3D('R')
+    >>> is_solenoidal(R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k)
+    True
+    >>> is_solenoidal(R.y * R.j)
+    False
+
+    """
+
+    # Field is solenoidal irrespective of system
+    # Take the first coordinate system in the result of the
+    # separate method in Vector
+    if not isinstance(field, Vector):
+        raise TypeError("field should be a Vector")
+    if field == Vector.zero:
+        return True
+    return divergence(field).simplify() is S.Zero
+
+
+def scalar_potential(field, coord_sys):
+    """
+    Returns the scalar potential function of a field in a given
+    coordinate system (without the added integration constant).
+
+    Parameters
+    ==========
+
+    field : Vector
+        The vector field whose scalar potential function is to be
+        calculated
+
+    coord_sys : CoordSys3D
+        The coordinate system to do the calculation in
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D
+    >>> from sympy.vector import scalar_potential, gradient
+    >>> R = CoordSys3D('R')
+    >>> scalar_potential(R.k, R) == R.z
+    True
+    >>> scalar_field = 2*R.x**2*R.y*R.z
+    >>> grad_field = gradient(scalar_field)
+    >>> scalar_potential(grad_field, R)
+    2*R.x**2*R.y*R.z
+
+    """
+
+    # Check whether field is conservative
+    if not is_conservative(field):
+        raise ValueError("Field is not conservative")
+    if field == Vector.zero:
+        return S.Zero
+    # Express the field exntirely in coord_sys
+    # Substitute coordinate variables also
+    if not isinstance(coord_sys, CoordSys3D):
+        raise TypeError("coord_sys must be a CoordSys3D")
+    field = express(field, coord_sys, variables=True)
+    dimensions = coord_sys.base_vectors()
+    scalars = coord_sys.base_scalars()
+    # Calculate scalar potential function
+    temp_function = integrate(field.dot(dimensions[0]), scalars[0])
+    for i, dim in enumerate(dimensions[1:]):
+        partial_diff = diff(temp_function, scalars[i + 1])
+        partial_diff = field.dot(dim) - partial_diff
+        temp_function += integrate(partial_diff, scalars[i + 1])
+    return temp_function
+
+
+def scalar_potential_difference(field, coord_sys, point1, point2):
+    """
+    Returns the scalar potential difference between two points in a
+    certain coordinate system, wrt a given field.
+
+    If a scalar field is provided, its values at the two points are
+    considered. If a conservative vector field is provided, the values
+    of its scalar potential function at the two points are used.
+
+    Returns (potential at point2) - (potential at point1)
+
+    The position vectors of the two Points are calculated wrt the
+    origin of the coordinate system provided.
+
+    Parameters
+    ==========
+
+    field : Vector/Expr
+        The field to calculate wrt
+
+    coord_sys : CoordSys3D
+        The coordinate system to do the calculations in
+
+    point1 : Point
+        The initial Point in given coordinate system
+
+    position2 : Point
+        The second Point in the given coordinate system
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D
+    >>> from sympy.vector import scalar_potential_difference
+    >>> R = CoordSys3D('R')
+    >>> P = R.origin.locate_new('P', R.x*R.i + R.y*R.j + R.z*R.k)
+    >>> vectfield = 4*R.x*R.y*R.i + 2*R.x**2*R.j
+    >>> scalar_potential_difference(vectfield, R, R.origin, P)
+    2*R.x**2*R.y
+    >>> Q = R.origin.locate_new('O', 3*R.i + R.j + 2*R.k)
+    >>> scalar_potential_difference(vectfield, R, P, Q)
+    -2*R.x**2*R.y + 18
+
+    """
+
+    if not isinstance(coord_sys, CoordSys3D):
+        raise TypeError("coord_sys must be a CoordSys3D")
+    if isinstance(field, Vector):
+        # Get the scalar potential function
+        scalar_fn = scalar_potential(field, coord_sys)
+    else:
+        # Field is a scalar
+        scalar_fn = field
+    # Express positions in required coordinate system
+    origin = coord_sys.origin
+    position1 = express(point1.position_wrt(origin), coord_sys,
+                        variables=True)
+    position2 = express(point2.position_wrt(origin), coord_sys,
+                        variables=True)
+    # Get the two positions as substitution dicts for coordinate variables
+    subs_dict1 = {}
+    subs_dict2 = {}
+    scalars = coord_sys.base_scalars()
+    for i, x in enumerate(coord_sys.base_vectors()):
+        subs_dict1[scalars[i]] = x.dot(position1)
+        subs_dict2[scalars[i]] = x.dot(position2)
+    return scalar_fn.subs(subs_dict2) - scalar_fn.subs(subs_dict1)
+
+
+def matrix_to_vector(matrix, system):
+    """
+    Converts a vector in matrix form to a Vector instance.
+
+    It is assumed that the elements of the Matrix represent the
+    measure numbers of the components of the vector along basis
+    vectors of 'system'.
+
+    Parameters
+    ==========
+
+    matrix : SymPy Matrix, Dimensions: (3, 1)
+        The matrix to be converted to a vector
+
+    system : CoordSys3D
+        The coordinate system the vector is to be defined in
+
+    Examples
+    ========
+
+    >>> from sympy import ImmutableMatrix as Matrix
+    >>> m = Matrix([1, 2, 3])
+    >>> from sympy.vector import CoordSys3D, matrix_to_vector
+    >>> C = CoordSys3D('C')
+    >>> v = matrix_to_vector(m, C)
+    >>> v
+    C.i + 2*C.j + 3*C.k
+    >>> v.to_matrix(C) == m
+    True
+
+    """
+
+    outvec = Vector.zero
+    vects = system.base_vectors()
+    for i, x in enumerate(matrix):
+        outvec += x * vects[i]
+    return outvec
+
+
+def _path(from_object, to_object):
+    """
+    Calculates the 'path' of objects starting from 'from_object'
+    to 'to_object', along with the index of the first common
+    ancestor in the tree.
+
+    Returns (index, list) tuple.
+    """
+
+    if from_object._root != to_object._root:
+        raise ValueError("No connecting path found between " +
+                         str(from_object) + " and " + str(to_object))
+
+    other_path = []
+    obj = to_object
+    while obj._parent is not None:
+        other_path.append(obj)
+        obj = obj._parent
+    other_path.append(obj)
+    object_set = set(other_path)
+    from_path = []
+    obj = from_object
+    while obj not in object_set:
+        from_path.append(obj)
+        obj = obj._parent
+    index = len(from_path)
+    i = other_path.index(obj)
+    while i >= 0:
+        from_path.append(other_path[i])
+        i -= 1
+    return index, from_path
+
+
+def orthogonalize(*vlist, orthonormal=False):
+    """
+    Takes a sequence of independent vectors and orthogonalizes them
+    using the Gram - Schmidt process. Returns a list of
+    orthogonal or orthonormal vectors.
+
+    Parameters
+    ==========
+
+    vlist : sequence of independent vectors to be made orthogonal.
+
+    orthonormal : Optional parameter
+                  Set to True if the vectors returned should be
+                  orthonormal.
+                  Default: False
+
+    Examples
+    ========
+
+    >>> from sympy.vector.coordsysrect import CoordSys3D
+    >>> from sympy.vector.functions import orthogonalize
+    >>> C = CoordSys3D('C')
+    >>> i, j, k = C.base_vectors()
+    >>> v1 = i + 2*j
+    >>> v2 = 2*i + 3*j
+    >>> orthogonalize(v1, v2)
+    [C.i + 2*C.j, 2/5*C.i + (-1/5)*C.j]
+
+    References
+    ==========
+
+    .. [1] https://en.wikipedia.org/wiki/Gram-Schmidt_process
+
+    """
+
+    if not all(isinstance(vec, Vector) for vec in vlist):
+        raise TypeError('Each element must be of Type Vector')
+
+    ortho_vlist = []
+    for i, term in enumerate(vlist):
+        for j in range(i):
+            term -= ortho_vlist[j].projection(vlist[i])
+        # TODO : The following line introduces a performance issue
+        # and needs to be changed once a good solution for issue #10279 is
+        # found.
+        if simplify(term).equals(Vector.zero):
+            raise ValueError("Vector set not linearly independent")
+        ortho_vlist.append(term)
+
+    if orthonormal:
+        ortho_vlist = [vec.normalize() for vec in ortho_vlist]
+
+    return ortho_vlist
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/implicitregion.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/implicitregion.py
new file mode 100644
index 0000000000..e6527a5b05
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/implicitregion.py
@@ -0,0 +1,502 @@
+from sympy import S, Rational, gcd, sqrt, sign, symbols, Complement
+from sympy.core import Basic, Tuple, diff, expand, Eq, Integer
+from sympy.core.compatibility import ordered
+from sympy.core.symbol import _symbol
+from sympy.solvers import solveset, nonlinsolve, diophantine
+from sympy.polys import total_degree
+from sympy.geometry import Point
+from sympy.ntheory.factor_ import core
+
+
+class ImplicitRegion(Basic):
+    """
+    Represents an implicit region in space.
+
+    Examples
+    ========
+
+    >>> from sympy import Eq
+    >>> from sympy.abc import x, y, z, t
+    >>> from sympy.vector import ImplicitRegion
+
+    >>> ImplicitRegion((x, y), x**2 + y**2 - 4)
+    ImplicitRegion((x, y), x**2 + y**2 - 4)
+    >>> ImplicitRegion((x, y), Eq(y*x, 1))
+    ImplicitRegion((x, y), x*y - 1)
+
+    >>> parabola = ImplicitRegion((x, y), y**2 - 4*x)
+    >>> parabola.degree
+    2
+    >>> parabola.equation
+    -4*x + y**2
+    >>> parabola.rational_parametrization(t)
+    (4/t**2, 4/t)
+
+    >>> r = ImplicitRegion((x, y, z), Eq(z, x**2 + y**2))
+    >>> r.variables
+    (x, y, z)
+    >>> r.singular_points()
+    FiniteSet((0, 0, 0))
+    >>> r.regular_point()
+    (-10, -10, 200)
+
+    Parameters
+    ==========
+
+    variables : tuple to map variables in implicit equation to base scalars.
+
+    equation : An expression or Eq denoting the implicit equation of the region.
+
+    """
+    def __new__(cls, variables, equation):
+        if not isinstance(variables, Tuple):
+            variables = Tuple(*variables)
+
+        if isinstance(equation, Eq):
+            equation = equation.lhs - equation.rhs
+
+        return super().__new__(cls, variables, equation)
+
+    @property
+    def variables(self):
+        return self.args[0]
+
+    @property
+    def equation(self):
+        return self.args[1]
+
+    @property
+    def degree(self):
+        return total_degree(self.equation)
+
+    def regular_point(self):
+        """
+        Returns a point on the implicit region.
+
+        Examples
+        ========
+
+        >>> from sympy.abc import x, y, z
+        >>> from sympy.vector import ImplicitRegion
+        >>> circle = ImplicitRegion((x, y), (x + 2)**2 + (y - 3)**2 - 16)
+        >>> circle.regular_point()
+        (-2, -1)
+        >>> parabola = ImplicitRegion((x, y), x**2 - 4*y)
+        >>> parabola.regular_point()
+        (0, 0)
+        >>> r = ImplicitRegion((x, y, z), (x + y + z)**4)
+        >>> r.regular_point()
+        (-10, -10, 20)
+
+        References
+        ==========
+
+        - Erik Hillgarter, "Rational Points on Conics", Diploma Thesis, RISC-Linz,
+          J. Kepler Universitat Linz, 1996. Availaible:
+          https://www3.risc.jku.at/publications/download/risc_1355/Rational%20Points%20on%20Conics.pdf
+
+        """
+        equation = self.equation
+
+        if len(self.variables) == 1:
+            return (list(solveset(equation, self.variables[0], domain=S.Reals))[0],)
+        elif len(self.variables) == 2:
+
+            if self.degree == 2:
+                coeffs = a, b, c, d, e, f = conic_coeff(self.variables, equation)
+
+                if b**2 == 4*a*c:
+                    x_reg, y_reg = self._regular_point_parabola(*coeffs)
+                else:
+                    x_reg, y_reg = self._regular_point_ellipse(*coeffs)
+                return x_reg, y_reg
+
+        if len(self.variables) == 3:
+            x, y, z = self.variables
+
+            for x_reg in range(-10, 10):
+                for y_reg in range(-10, 10):
+                    if not solveset(equation.subs({x: x_reg, y: y_reg}), self.variables[2], domain=S.Reals).is_empty:
+                        return (x_reg, y_reg, list(solveset(equation.subs({x: x_reg, y: y_reg})))[0])
+
+        if len(self.singular_points()) != 0:
+            return list[self.singular_points()][0]
+
+        raise NotImplementedError()
+
+    def _regular_point_parabola(self, a, b, c, d, e, f):
+            ok = (a, d) != (0, 0) and (c, e) != (0, 0) and b**2 == 4*a*c and (a, c) != (0, 0)
+
+            if not ok:
+                raise ValueError("Rational Point on the conic does not exist")
+
+            if a != 0:
+                d_dash, f_dash = (4*a*e - 2*b*d, 4*a*f - d**2)
+                if d_dash != 0:
+                    y_reg = -f_dash/d_dash
+                    x_reg = -(d + b*y_reg)/(2*a)
+                else:
+                    ok = False
+            elif c != 0:
+                d_dash, f_dash = (4*c*d - 2*b*e, 4*c*f - e**2)
+                if d_dash != 0:
+                    x_reg = -f_dash/d_dash
+                    y_reg = -(e + b*x_reg)/(2*c)
+                else:
+                    ok = False
+
+            if ok:
+                return x_reg, y_reg
+            else:
+                raise ValueError("Rational Point on the conic does not exist")
+
+    def _regular_point_ellipse(self, a, b, c, d, e, f):
+            D = 4*a*c - b**2
+            ok = D
+
+            if not ok:
+                raise ValueError("Rational Point on the conic does not exist")
+
+            if a == 0 and c == 0:
+                K = -1
+                L = 4*(d*e - b*f)
+            elif c != 0:
+                K = D
+                L = 4*c**2*d**2 - 4*b*c*d*e + 4*a*c*e**2 + 4*b**2*c*f - 16*a*c**2*f
+            else:
+                K = D
+                L = 4*a**2*e**2 - 4*b*a*d*e + 4*b**2*a*f
+
+            ok = L != 0 and not(K > 0 and L < 0)
+            if not ok:
+                raise ValueError("Rational Point on the conic does not exist")
+
+            K = Rational(K).limit_denominator(10**12)
+            L = Rational(L).limit_denominator(10**12)
+
+            k1, k2 = K.p, K.q
+            l1, l2 = L.p, L.q
+            g = gcd(k2, l2)
+
+            a1 = (l2*k2)/g
+            b1 = (k1*l2)/g
+            c1 = -(l1*k2)/g
+            a2 = sign(a1)*core(abs(a1), 2)
+            r1 = sqrt(a1/a2)
+            b2 = sign(b1)*core(abs(b1), 2)
+            r2 = sqrt(b1/b2)
+            c2 = sign(c1)*core(abs(c1), 2)
+            r3 = sqrt(c1/c2)
+
+            g = gcd(gcd(a2, b2), c2)
+            a2 = a2/g
+            b2 = b2/g
+            c2 = c2/g
+
+            g1 = gcd(a2, b2)
+            a2 = a2/g1
+            b2 = b2/g1
+            c2 = c2*g1
+
+            g2 = gcd(a2,c2)
+            a2 = a2/g2
+            b2 = b2*g2
+            c2 = c2/g2
+
+            g3 = gcd(b2, c2)
+            a2 = a2*g3
+            b2 = b2/g3
+            c2 = c2/g3
+
+            x, y, z = symbols("x y z")
+            eq = a2*x**2 + b2*y**2 + c2*z**2
+
+            solutions = diophantine(eq)
+
+            if len(solutions) == 0:
+                raise ValueError("Rational Point on the conic does not exist")
+
+            flag = False
+            for sol in solutions:
+                syms = Tuple(*sol).free_symbols
+                rep = {s: 3 for s in syms}
+                sol_z = sol[2]
+
+                if sol_z == 0:
+                    flag = True
+                    continue
+
+                if not (isinstance(sol_z, Integer) or isinstance(sol_z, int)):
+                    syms_z = sol_z.free_symbols
+
+                    if len(syms_z) == 1:
+                        p = next(iter(syms_z))
+                        p_values = Complement(S.Integers, solveset(Eq(sol_z, 0), p, S.Integers))
+                        rep[p] = next(iter(p_values))
+
+                    if len(syms_z) == 2:
+                        p, q = list(ordered(syms_z))
+
+                        for i in S.Integers:
+                            subs_sol_z = sol_z.subs(p, i)
+                            q_values = Complement(S.Integers, solveset(Eq(subs_sol_z, 0), q, S.Integers))
+
+                            if not q_values.is_empty:
+                                rep[p] = i
+                                rep[q] = next(iter(q_values))
+                                break
+
+                    if len(syms) != 0:
+                        x, y, z = tuple(s.subs(rep) for s in sol)
+                    else:
+                        x, y, z =   sol
+                    flag = False
+                    break
+
+            if flag:
+                raise ValueError("Rational Point on the conic does not exist")
+
+            x = (x*g3)/r1
+            y = (y*g2)/r2
+            z = (z*g1)/r3
+            x = x/z
+            y = y/z
+
+            if a == 0 and c == 0:
+                x_reg = (x + y - 2*e)/(2*b)
+                y_reg = (x - y - 2*d)/(2*b)
+            elif c != 0:
+                x_reg = (x - 2*d*c + b*e)/K
+                y_reg = (y - b*x_reg - e)/(2*c)
+            else:
+                y_reg = (x - 2*e*a + b*d)/K
+                x_reg = (y - b*y_reg - d)/(2*a)
+
+            return x_reg, y_reg
+
+    def singular_points(self):
+        """
+        Returns a set of singular points of the region.
+
+        The singular points are those points on the region
+        where all partial derivatives vanish.
+
+        Examples
+        ========
+
+        >>> from sympy.abc import x, y
+        >>> from sympy.vector import ImplicitRegion
+        >>> I = ImplicitRegion((x, y), (y-1)**2 -x**3 + 2*x**2 -x)
+        >>> I.singular_points()
+        FiniteSet((1, 1))
+
+        """
+        eq_list = [self.equation]
+        for var in self.variables:
+            eq_list += [diff(self.equation, var)]
+
+        return nonlinsolve(eq_list, list(self.variables))
+
+    def multiplicity(self, point):
+        """
+        Returns the multiplicity of a singular point on the region.
+
+        A singular point (x,y) of region is said to be of multiplicity m
+        if all the partial derivatives off to order m - 1 vanish there.
+
+        Examples
+        ========
+
+        >>> from sympy.abc import x, y, z
+        >>> from sympy.vector import ImplicitRegion
+        >>> I = ImplicitRegion((x, y, z), x**2 + y**3 - z**4)
+        >>> I.singular_points()
+        FiniteSet((0, 0, 0))
+        >>> I.multiplicity((0, 0, 0))
+        2
+
+        """
+        if isinstance(point, Point):
+            point = point.args
+
+        modified_eq = self.equation
+
+        for i, var in enumerate(self.variables):
+            modified_eq = modified_eq.subs(var, var + point[i])
+        modified_eq = expand(modified_eq)
+
+        if len(modified_eq.args) != 0:
+            terms = modified_eq.args
+            m = min([total_degree(term) for term in terms])
+        else:
+            terms = modified_eq
+            m = total_degree(terms)
+
+        return m
+
+    def rational_parametrization(self, parameters=('t', 's'), reg_point=None):
+        """
+        Returns the rational parametrization of implict region.
+
+        Examples
+        ========
+
+        >>> from sympy import Eq
+        >>> from sympy.abc import x, y, z, s, t
+        >>> from sympy.vector import ImplicitRegion
+
+        >>> parabola = ImplicitRegion((x, y), y**2 - 4*x)
+        >>> parabola.rational_parametrization()
+        (4/t**2, 4/t)
+
+        >>> circle = ImplicitRegion((x, y), Eq(x**2 + y**2, 4))
+        >>> circle.rational_parametrization()
+        (4*t/(t**2 + 1), 4*t**2/(t**2 + 1) - 2)
+
+        >>> I = ImplicitRegion((x, y), x**3 + x**2 - y**2)
+        >>> I.rational_parametrization()
+        (t**2 - 1, t*(t**2 - 1))
+
+        >>> cubic_curve = ImplicitRegion((x, y), x**3 + x**2 - y**2)
+        >>> cubic_curve.rational_parametrization(parameters=(t))
+        (t**2 - 1, t*(t**2 - 1))
+
+        >>> sphere = ImplicitRegion((x, y, z), x**2 + y**2 + z**2 - 4)
+        >>> sphere.rational_parametrization(parameters=(t, s))
+        (-2 + 4/(s**2 + t**2 + 1), 4*s/(s**2 + t**2 + 1), 4*t/(s**2 + t**2 + 1))
+
+        For some conics, regular_points() is unable to find a point on curve.
+        To calulcate the parametric representation in such cases, user need
+        to determine a point on the region and pass it using reg_point.
+
+        >>> c = ImplicitRegion((x, y), (x  - 1/2)**2 + (y)**2 - (1/4)**2)
+        >>> c.rational_parametrization(reg_point=(3/4, 0))
+        (0.75 - 0.5/(t**2 + 1), -0.5*t/(t**2 + 1))
+
+        References
+        ==========
+
+        - Christoph M. Hoffmann, "Conversion Methods between Parametric and
+          Implicit Curves and Surfaces", Purdue e-Pubs, 1990. Available:
+          https://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1827&context=cstech
+
+        """
+        equation = self.equation
+        degree = self.degree
+
+        if degree == 1:
+            if len(self.variables) == 1:
+                return (equation,)
+            elif len(self.variables) == 2:
+                x, y = self.variables
+                y_par = list(solveset(equation, y))[0]
+                return x, y_par
+            else:
+                raise NotImplementedError()
+
+        point = ()
+
+        # Finding the (n - 1) fold point of the monoid of degree
+        if degree == 2:
+            # For degree 2 curves, either a regular point or a singular point can be used.
+            if reg_point is not None:
+                # Using point provided by the user as regular point
+                if isinstance(point, Point):
+                    point = point.args
+                point = reg_point
+            else:
+                if len(self.singular_points()) != 0:
+                    point = list(self.singular_points())[0]
+                else:
+                    point = self.regular_point()
+
+        if len(self.singular_points()) != 0:
+            singular_points = self.singular_points()
+            for spoint in singular_points:
+                syms = Tuple(*spoint).free_symbols
+                rep = {s: 2 for s in syms}
+
+                if len(syms) != 0:
+                   spoint = tuple(s.subs(rep) for s in spoint)
+
+                if self.multiplicity(spoint) == degree - 1:
+                    point = spoint
+                    break
+
+        if len(point) == 0:
+            # The region in not a monoid
+            raise NotImplementedError()
+
+        modified_eq = equation
+
+        # Shifting the region such that fold point moves to origin
+        for i, var in enumerate(self.variables):
+            modified_eq = modified_eq.subs(var, var + point[i])
+        modified_eq = expand(modified_eq)
+
+        hn = hn_1 = 0
+        for term in modified_eq.args:
+            if total_degree(term) == degree:
+                hn += term
+            else:
+                hn_1 += term
+
+        hn_1 = -1*hn_1
+
+        if not isinstance(parameters, tuple):
+            parameters = (parameters,)
+
+        if len(self.variables) == 2:
+
+            parameter1 = parameters[0]
+            if parameter1 == 's':
+                # To avoid name conflict between parameters
+                s = _symbol('s_', real=True)
+            else:
+                s = _symbol('s', real=True)
+            t = _symbol(parameter1, real=True)
+
+            hn = hn.subs({self.variables[0]: s, self.variables[1]: t})
+            hn_1 = hn_1.subs({self.variables[0]: s, self.variables[1]: t})
+
+            x_par = (s*(hn_1/hn)).subs(s, 1) + point[0]
+            y_par = (t*(hn_1/hn)).subs(s, 1) + point[1]
+
+            return x_par, y_par
+
+        elif len(self.variables) == 3:
+
+            parameter1, parameter2 = parameters
+            if parameter1 == 'r' or parameter2 == 'r':
+                # To avoid name conflict between parameters
+                r = _symbol('r_', real=True)
+            else:
+                r = _symbol('r', real=True)
+            s = _symbol(parameter2, real=True)
+            t = _symbol(parameter1, real=True)
+
+            hn = hn.subs({self.variables[0]: r, self.variables[1]: s, self.variables[2]: t})
+            hn_1 = hn_1.subs({self.variables[0]: r, self.variables[1]: s, self.variables[2]: t})
+
+            x_par = (r*(hn_1/hn)).subs(r, 1) + point[0]
+            y_par = (s*(hn_1/hn)).subs(r, 1) + point[1]
+            z_par = (t*(hn_1/hn)).subs(r, 1) + point[2]
+
+            return x_par, y_par, z_par
+
+        raise NotImplementedError()
+
+def conic_coeff(variables, equation):
+    if total_degree(equation) != 2:
+        raise ValueError()
+    x = variables[0]
+    y = variables[1]
+
+    equation = expand(equation)
+    a = equation.coeff(x**2)
+    b = equation.coeff(x*y)
+    c = equation.coeff(y**2)
+    d = equation.coeff(x, 1).coeff(y, 0)
+    e = equation.coeff(y, 1).coeff(x, 0)
+    f = equation.coeff(x, 0).coeff(y, 0)
+    return a, b, c, d, e, f
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/integrals.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/integrals.py
new file mode 100644
index 0000000000..6984883f52
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/integrals.py
@@ -0,0 +1,207 @@
+from sympy import S, simplify
+from sympy.core import Basic, diff
+from sympy.matrices import Matrix
+from sympy.vector import (CoordSys3D, Vector, ParametricRegion,
+                        parametric_region_list, ImplicitRegion)
+from sympy.vector.operators import _get_coord_sys_from_expr
+from sympy.integrals import Integral, integrate
+from sympy.utilities.iterables import topological_sort, default_sort_key
+from sympy.geometry.entity import GeometryEntity
+
+
+class ParametricIntegral(Basic):
+    """
+    Represents integral of a scalar or vector field
+    over a Parametric Region
+
+    Examples
+    ========
+
+    >>> from sympy import cos, sin, pi
+    >>> from sympy.vector import CoordSys3D, ParametricRegion, ParametricIntegral
+    >>> from sympy.abc import r, t, theta, phi
+
+    >>> C = CoordSys3D('C')
+    >>> curve = ParametricRegion((3*t - 2, t + 1), (t, 1, 2))
+    >>> ParametricIntegral(C.x, curve)
+    5*sqrt(10)/2
+    >>> length = ParametricIntegral(1, curve)
+    >>> length
+    sqrt(10)
+    >>> semisphere = ParametricRegion((2*sin(phi)*cos(theta), 2*sin(phi)*sin(theta), 2*cos(phi)),\
+                            (theta, 0, 2*pi), (phi, 0, pi/2))
+    >>> ParametricIntegral(C.z, semisphere)
+    8*pi
+
+    >>> ParametricIntegral(C.j + C.k, ParametricRegion((r*cos(theta), r*sin(theta)), r, theta))
+    0
+
+    """
+
+    def __new__(cls, field, parametricregion):
+
+        coord_set = _get_coord_sys_from_expr(field)
+
+        if len(coord_set) == 0:
+            coord_sys = CoordSys3D('C')
+        elif len(coord_set) > 1:
+            raise ValueError
+        else:
+            coord_sys = next(iter(coord_set))
+
+        if parametricregion.dimensions == 0:
+            return S.Zero
+
+        base_vectors = coord_sys.base_vectors()
+        base_scalars = coord_sys.base_scalars()
+
+        parametricfield = field
+
+        r = Vector.zero
+        for i in range(len(parametricregion.definition)):
+            r += base_vectors[i]*parametricregion.definition[i]
+
+        if len(coord_set) != 0:
+            for i in range(len(parametricregion.definition)):
+                parametricfield = parametricfield.subs(base_scalars[i], parametricregion.definition[i])
+
+        if parametricregion.dimensions == 1:
+            parameter = parametricregion.parameters[0]
+
+            r_diff = diff(r, parameter)
+            lower, upper = parametricregion.limits[parameter][0], parametricregion.limits[parameter][1]
+
+            if isinstance(parametricfield, Vector):
+                integrand = simplify(r_diff.dot(parametricfield))
+            else:
+                integrand = simplify(r_diff.magnitude()*parametricfield)
+
+            result = integrate(integrand, (parameter, lower, upper))
+
+        elif parametricregion.dimensions == 2:
+            u, v = cls._bounds_case(parametricregion.parameters, parametricregion.limits)
+
+            r_u = diff(r, u)
+            r_v = diff(r, v)
+            normal_vector = simplify(r_u.cross(r_v))
+
+            if isinstance(parametricfield, Vector):
+                integrand = parametricfield.dot(normal_vector)
+            else:
+                integrand = parametricfield*normal_vector.magnitude()
+
+            integrand = simplify(integrand)
+
+            lower_u, upper_u = parametricregion.limits[u][0], parametricregion.limits[u][1]
+            lower_v, upper_v = parametricregion.limits[v][0], parametricregion.limits[v][1]
+
+            result = integrate(integrand, (u, lower_u, upper_u), (v, lower_v, upper_v))
+
+        else:
+            variables = cls._bounds_case(parametricregion.parameters, parametricregion.limits)
+            coeff = Matrix(parametricregion.definition).jacobian(variables).det()
+            integrand = simplify(parametricfield*coeff)
+
+            l = [(var, parametricregion.limits[var][0], parametricregion.limits[var][1]) for var in variables]
+            result = integrate(integrand, *l)
+
+        if not isinstance(result, Integral):
+            return result
+        else:
+            return super().__new__(cls, field, parametricregion)
+
+    @classmethod
+    def _bounds_case(cls, parameters, limits):
+
+        V = list(limits.keys())
+        E = list()
+
+        for p in V:
+            lower_p = limits[p][0]
+            upper_p = limits[p][1]
+
+            lower_p = lower_p.atoms()
+            upper_p = upper_p.atoms()
+            for q in V:
+                if p == q:
+                    continue
+                if lower_p.issuperset({q}) or upper_p.issuperset({q}):
+                    E.append((p, q))
+
+        if not E:
+            return parameters
+        else:
+            return topological_sort((V, E), key=default_sort_key)
+
+    @property
+    def field(self):
+        return self.args[0]
+
+    @property
+    def parametricregion(self):
+        return self.args[1]
+
+
+def vector_integrate(field, *region):
+    """
+    Compute the integral of a vector/scalar field
+    over a a region or a set of parameters.
+
+    Examples
+    ========
+    >>> from sympy.vector import CoordSys3D, ParametricRegion, vector_integrate
+    >>> from sympy.abc import x, y, t
+    >>> C = CoordSys3D('C')
+
+    >>> region = ParametricRegion((t, t**2), (t, 1, 5))
+    >>> vector_integrate(C.x*C.i, region)
+    12
+
+    Integrals over some objects of geometry module can also be calculated.
+
+    >>> from sympy.geometry import Point, Circle, Triangle
+    >>> c = Circle(Point(0, 2), 5)
+    >>> vector_integrate(C.x**2 + C.y**2, c)
+    290*pi
+    >>> triangle = Triangle(Point(-2, 3), Point(2, 3), Point(0, 5))
+    >>> vector_integrate(3*C.x**2*C.y*C.i + C.j, triangle)
+    -8
+
+    Integrals over some simple implicit regions can be computed. But in most cases,
+    it takes too long to compute over them. This is due to the expressions of parametric
+    representation becoming large.
+
+    >>> from sympy.vector import ImplicitRegion
+    >>> c2 = ImplicitRegion((x, y), (x - 2)**2 + (y - 1)**2 - 9)
+    >>> vector_integrate(1, c2)
+    12*pi
+
+    Integral of fields with respect to base scalars:
+
+    >>> vector_integrate(12*C.y**3, (C.y, 1, 3))
+    240
+    >>> vector_integrate(C.x**2*C.z, C.x)
+    C.x**3*C.z/3
+    >>> vector_integrate(C.x*C.i - C.y*C.k, C.x)
+    (Integral(C.x, C.x))*C.i + (Integral(-C.y, C.x))*C.k
+    >>> _.doit()
+    C.x**2/2*C.i + (-C.x*C.y)*C.k
+
+    """
+    if len(region) == 1:
+        if isinstance(region[0], ParametricRegion):
+            return ParametricIntegral(field, region[0])
+
+        if isinstance(region[0], ImplicitRegion):
+            region = parametric_region_list(region[0])[0]
+            return vector_integrate(field, region)
+
+        if isinstance(region[0], GeometryEntity):
+            regions_list = parametric_region_list(region[0])
+
+            result = 0
+            for reg in regions_list:
+                result += vector_integrate(field, reg)
+            return result
+
+    return integrate(field, *region)
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/operators.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/operators.py
new file mode 100644
index 0000000000..2f303ee690
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/operators.py
@@ -0,0 +1,367 @@
+import collections
+from sympy.core.expr import Expr
+from sympy.core import sympify, S, preorder_traversal
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.vector.vector import Vector, VectorMul, VectorAdd, Cross, Dot
+from sympy.vector.scalar import BaseScalar
+from sympy.utilities.exceptions import SymPyDeprecationWarning
+from sympy.core.function import Derivative
+from sympy import Add, Mul
+
+
+def _get_coord_systems(expr):
+    g = preorder_traversal(expr)
+    ret = set()
+    for i in g:
+        if isinstance(i, CoordSys3D):
+            ret.add(i)
+            g.skip()
+    return frozenset(ret)
+
+
+def _get_coord_sys_from_expr(expr, coord_sys=None):
+    """
+    expr : expression
+        The coordinate system is extracted from this parameter.
+    """
+
+    # TODO: Remove this line when warning from issue #12884 will be removed
+    if coord_sys is not None:
+        SymPyDeprecationWarning(
+            feature="coord_sys parameter",
+            useinstead="do not use it",
+            deprecated_since_version="1.1",
+            issue=12884,
+        ).warn()
+
+    return _get_coord_systems(expr)
+
+
+def _split_mul_args_wrt_coordsys(expr):
+    d = collections.defaultdict(lambda: S.One)
+    for i in expr.args:
+        d[_get_coord_systems(i)] *= i
+    return list(d.values())
+
+
+class Gradient(Expr):
+    """
+    Represents unevaluated Gradient.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, Gradient
+    >>> R = CoordSys3D('R')
+    >>> s = R.x*R.y*R.z
+    >>> Gradient(s)
+    Gradient(R.x*R.y*R.z)
+
+    """
+
+    def __new__(cls, expr):
+        expr = sympify(expr)
+        obj = Expr.__new__(cls, expr)
+        obj._expr = expr
+        return obj
+
+    def doit(self, **kwargs):
+        return gradient(self._expr, doit=True)
+
+
+class Divergence(Expr):
+    """
+    Represents unevaluated Divergence.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, Divergence
+    >>> R = CoordSys3D('R')
+    >>> v = R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k
+    >>> Divergence(v)
+    Divergence(R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k)
+
+    """
+
+    def __new__(cls, expr):
+        expr = sympify(expr)
+        obj = Expr.__new__(cls, expr)
+        obj._expr = expr
+        return obj
+
+    def doit(self, **kwargs):
+        return divergence(self._expr, doit=True)
+
+
+class Curl(Expr):
+    """
+    Represents unevaluated Curl.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, Curl
+    >>> R = CoordSys3D('R')
+    >>> v = R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k
+    >>> Curl(v)
+    Curl(R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k)
+
+    """
+
+    def __new__(cls, expr):
+        expr = sympify(expr)
+        obj = Expr.__new__(cls, expr)
+        obj._expr = expr
+        return obj
+
+    def doit(self, **kwargs):
+        return curl(self._expr, doit=True)
+
+
+def curl(vect, coord_sys=None, doit=True):
+    """
+    Returns the curl of a vector field computed wrt the base scalars
+    of the given coordinate system.
+
+    Parameters
+    ==========
+
+    vect : Vector
+        The vector operand
+
+    coord_sys : CoordSys3D
+        The coordinate system to calculate the gradient in.
+        Deprecated since version 1.1
+
+    doit : bool
+        If True, the result is returned after calling .doit() on
+        each component. Else, the returned expression contains
+        Derivative instances
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, curl
+    >>> R = CoordSys3D('R')
+    >>> v1 = R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k
+    >>> curl(v1)
+    0
+    >>> v2 = R.x*R.y*R.z*R.i
+    >>> curl(v2)
+    R.x*R.y*R.j + (-R.x*R.z)*R.k
+
+    """
+
+    coord_sys = _get_coord_sys_from_expr(vect, coord_sys)
+
+    if len(coord_sys) == 0:
+        return Vector.zero
+    elif len(coord_sys) == 1:
+        coord_sys = next(iter(coord_sys))
+        i, j, k = coord_sys.base_vectors()
+        x, y, z = coord_sys.base_scalars()
+        h1, h2, h3 = coord_sys.lame_coefficients()
+        vectx = vect.dot(i)
+        vecty = vect.dot(j)
+        vectz = vect.dot(k)
+        outvec = Vector.zero
+        outvec += (Derivative(vectz * h3, y) -
+                   Derivative(vecty * h2, z)) * i / (h2 * h3)
+        outvec += (Derivative(vectx * h1, z) -
+                   Derivative(vectz * h3, x)) * j / (h1 * h3)
+        outvec += (Derivative(vecty * h2, x) -
+                   Derivative(vectx * h1, y)) * k / (h2 * h1)
+
+        if doit:
+            return outvec.doit()
+        return outvec
+    else:
+        if isinstance(vect, (Add, VectorAdd)):
+            from sympy.vector import express
+            try:
+                cs = next(iter(coord_sys))
+                args = [express(i, cs, variables=True) for i in vect.args]
+            except ValueError:
+                args = vect.args
+            return VectorAdd.fromiter(curl(i, doit=doit) for i in args)
+        elif isinstance(vect, (Mul, VectorMul)):
+            vector = [i for i in vect.args if isinstance(i, (Vector, Cross, Gradient))][0]
+            scalar = Mul.fromiter(i for i in vect.args if not isinstance(i, (Vector, Cross, Gradient)))
+            res = Cross(gradient(scalar), vector).doit() + scalar*curl(vector, doit=doit)
+            if doit:
+                return res.doit()
+            return res
+        elif isinstance(vect, (Cross, Curl, Gradient)):
+            return Curl(vect)
+        else:
+            raise Curl(vect)
+
+
+def divergence(vect, coord_sys=None, doit=True):
+    """
+    Returns the divergence of a vector field computed wrt the base
+    scalars of the given coordinate system.
+
+    Parameters
+    ==========
+
+    vector : Vector
+        The vector operand
+
+    coord_sys : CoordSys3D
+        The coordinate system to calculate the gradient in
+        Deprecated since version 1.1
+
+    doit : bool
+        If True, the result is returned after calling .doit() on
+        each component. Else, the returned expression contains
+        Derivative instances
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, divergence
+    >>> R = CoordSys3D('R')
+    >>> v1 = R.x*R.y*R.z * (R.i+R.j+R.k)
+
+    >>> divergence(v1)
+    R.x*R.y + R.x*R.z + R.y*R.z
+    >>> v2 = 2*R.y*R.z*R.j
+    >>> divergence(v2)
+    2*R.z
+
+    """
+    coord_sys = _get_coord_sys_from_expr(vect, coord_sys)
+    if len(coord_sys) == 0:
+        return S.Zero
+    elif len(coord_sys) == 1:
+        if isinstance(vect, (Cross, Curl, Gradient)):
+            return Divergence(vect)
+        # TODO: is case of many coord systems, this gets a random one:
+        coord_sys = next(iter(coord_sys))
+        i, j, k = coord_sys.base_vectors()
+        x, y, z = coord_sys.base_scalars()
+        h1, h2, h3 = coord_sys.lame_coefficients()
+        vx = _diff_conditional(vect.dot(i), x, h2, h3) \
+             / (h1 * h2 * h3)
+        vy = _diff_conditional(vect.dot(j), y, h3, h1) \
+             / (h1 * h2 * h3)
+        vz = _diff_conditional(vect.dot(k), z, h1, h2) \
+             / (h1 * h2 * h3)
+        res = vx + vy + vz
+        if doit:
+            return res.doit()
+        return res
+    else:
+        if isinstance(vect, (Add, VectorAdd)):
+            return Add.fromiter(divergence(i, doit=doit) for i in vect.args)
+        elif isinstance(vect, (Mul, VectorMul)):
+            vector = [i for i in vect.args if isinstance(i, (Vector, Cross, Gradient))][0]
+            scalar = Mul.fromiter(i for i in vect.args if not isinstance(i, (Vector, Cross, Gradient)))
+            res = Dot(vector, gradient(scalar)) + scalar*divergence(vector, doit=doit)
+            if doit:
+                return res.doit()
+            return res
+        elif isinstance(vect, (Cross, Curl, Gradient)):
+            return Divergence(vect)
+        else:
+            raise Divergence(vect)
+
+
+def gradient(scalar_field, coord_sys=None, doit=True):
+    """
+    Returns the vector gradient of a scalar field computed wrt the
+    base scalars of the given coordinate system.
+
+    Parameters
+    ==========
+
+    scalar_field : SymPy Expr
+        The scalar field to compute the gradient of
+
+    coord_sys : CoordSys3D
+        The coordinate system to calculate the gradient in
+        Deprecated since version 1.1
+
+    doit : bool
+        If True, the result is returned after calling .doit() on
+        each component. Else, the returned expression contains
+        Derivative instances
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, gradient
+    >>> R = CoordSys3D('R')
+    >>> s1 = R.x*R.y*R.z
+    >>> gradient(s1)
+    R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k
+    >>> s2 = 5*R.x**2*R.z
+    >>> gradient(s2)
+    10*R.x*R.z*R.i + 5*R.x**2*R.k
+
+    """
+    coord_sys = _get_coord_sys_from_expr(scalar_field, coord_sys)
+
+    if len(coord_sys) == 0:
+        return Vector.zero
+    elif len(coord_sys) == 1:
+        coord_sys = next(iter(coord_sys))
+        h1, h2, h3 = coord_sys.lame_coefficients()
+        i, j, k = coord_sys.base_vectors()
+        x, y, z = coord_sys.base_scalars()
+        vx = Derivative(scalar_field, x) / h1
+        vy = Derivative(scalar_field, y) / h2
+        vz = Derivative(scalar_field, z) / h3
+
+        if doit:
+            return (vx * i + vy * j + vz * k).doit()
+        return vx * i + vy * j + vz * k
+    else:
+        if isinstance(scalar_field, (Add, VectorAdd)):
+            return VectorAdd.fromiter(gradient(i) for i in scalar_field.args)
+        if isinstance(scalar_field, (Mul, VectorMul)):
+            s = _split_mul_args_wrt_coordsys(scalar_field)
+            return VectorAdd.fromiter(scalar_field / i * gradient(i) for i in s)
+        return Gradient(scalar_field)
+
+
+class Laplacian(Expr):
+    """
+    Represents unevaluated Laplacian.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, Laplacian
+    >>> R = CoordSys3D('R')
+    >>> v = 3*R.x**3*R.y**2*R.z**3
+    >>> Laplacian(v)
+    Laplacian(3*R.x**3*R.y**2*R.z**3)
+
+    """
+
+    def __new__(cls, expr):
+        expr = sympify(expr)
+        obj = Expr.__new__(cls, expr)
+        obj._expr = expr
+        return obj
+
+    def doit(self, **kwargs):
+        from sympy.vector.functions import laplacian
+        return laplacian(self._expr)
+
+
+def _diff_conditional(expr, base_scalar, coeff_1, coeff_2):
+    """
+    First re-expresses expr in the system that base_scalar belongs to.
+    If base_scalar appears in the re-expressed form, differentiates
+    it wrt base_scalar.
+    Else, returns 0
+    """
+    from sympy.vector.functions import express
+    new_expr = express(expr, base_scalar.system, variables=True)
+    if base_scalar in new_expr.atoms(BaseScalar):
+        return Derivative(coeff_1 * coeff_2 * new_expr, base_scalar)
+    return S.Zero
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/orienters.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/orienters.py
new file mode 100644
index 0000000000..bcaab04a8e
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/orienters.py
@@ -0,0 +1,396 @@
+from sympy.core.basic import Basic
+from sympy import (sympify, eye, sin, cos, rot_axis1, rot_axis2,
+                   rot_axis3, ImmutableMatrix as Matrix)
+from sympy.core.cache import cacheit
+from sympy.core.symbol import Str
+import sympy.vector
+
+
+class Orienter(Basic):
+    """
+    Super-class for all orienter classes.
+    """
+
+    def rotation_matrix(self):
+        """
+        The rotation matrix corresponding to this orienter
+        instance.
+        """
+        return self._parent_orient
+
+
+class AxisOrienter(Orienter):
+    """
+    Class to denote an axis orienter.
+    """
+
+    def __new__(cls, angle, axis):
+        if not isinstance(axis, sympy.vector.Vector):
+            raise TypeError("axis should be a Vector")
+        angle = sympify(angle)
+
+        obj = super().__new__(cls, angle, axis)
+        obj._angle = angle
+        obj._axis = axis
+
+        return obj
+
+    def __init__(self, angle, axis):
+        """
+        Axis rotation is a rotation about an arbitrary axis by
+        some angle. The angle is supplied as a SymPy expr scalar, and
+        the axis is supplied as a Vector.
+
+        Parameters
+        ==========
+
+        angle : Expr
+            The angle by which the new system is to be rotated
+
+        axis : Vector
+            The axis around which the rotation has to be performed
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import symbols
+        >>> q1 = symbols('q1')
+        >>> N = CoordSys3D('N')
+        >>> from sympy.vector import AxisOrienter
+        >>> orienter = AxisOrienter(q1, N.i + 2 * N.j)
+        >>> B = N.orient_new('B', (orienter, ))
+
+        """
+        # Dummy initializer for docstrings
+        pass
+
+    @cacheit
+    def rotation_matrix(self, system):
+        """
+        The rotation matrix corresponding to this orienter
+        instance.
+
+        Parameters
+        ==========
+
+        system : CoordSys3D
+            The coordinate system wrt which the rotation matrix
+            is to be computed
+        """
+
+        axis = sympy.vector.express(self.axis, system).normalize()
+        axis = axis.to_matrix(system)
+        theta = self.angle
+        parent_orient = ((eye(3) - axis * axis.T) * cos(theta) +
+                         Matrix([[0, -axis[2], axis[1]],
+                                 [axis[2], 0, -axis[0]],
+                                 [-axis[1], axis[0], 0]]) * sin(theta) +
+                         axis * axis.T)
+        parent_orient = parent_orient.T
+        return parent_orient
+
+    @property
+    def angle(self):
+        return self._angle
+
+    @property
+    def axis(self):
+        return self._axis
+
+
+class ThreeAngleOrienter(Orienter):
+    """
+    Super-class for Body and Space orienters.
+    """
+
+    def __new__(cls, angle1, angle2, angle3, rot_order):
+        if isinstance(rot_order, Str):
+            rot_order = rot_order.name
+
+        approved_orders = ('123', '231', '312', '132', '213',
+                           '321', '121', '131', '212', '232',
+                           '313', '323', '')
+        original_rot_order = rot_order
+        rot_order = str(rot_order).upper()
+        if not (len(rot_order) == 3):
+            raise TypeError('rot_order should be a str of length 3')
+        rot_order = [i.replace('X', '1') for i in rot_order]
+        rot_order = [i.replace('Y', '2') for i in rot_order]
+        rot_order = [i.replace('Z', '3') for i in rot_order]
+        rot_order = ''.join(rot_order)
+        if rot_order not in approved_orders:
+            raise TypeError('Invalid rot_type parameter')
+        a1 = int(rot_order[0])
+        a2 = int(rot_order[1])
+        a3 = int(rot_order[2])
+        angle1 = sympify(angle1)
+        angle2 = sympify(angle2)
+        angle3 = sympify(angle3)
+        if cls._in_order:
+            parent_orient = (_rot(a1, angle1) *
+                             _rot(a2, angle2) *
+                             _rot(a3, angle3))
+        else:
+            parent_orient = (_rot(a3, angle3) *
+                             _rot(a2, angle2) *
+                             _rot(a1, angle1))
+        parent_orient = parent_orient.T
+
+        obj = super().__new__(
+            cls, angle1, angle2, angle3, Str(rot_order))
+        obj._angle1 = angle1
+        obj._angle2 = angle2
+        obj._angle3 = angle3
+        obj._rot_order = original_rot_order
+        obj._parent_orient = parent_orient
+
+        return obj
+
+    @property
+    def angle1(self):
+        return self._angle1
+
+    @property
+    def angle2(self):
+        return self._angle2
+
+    @property
+    def angle3(self):
+        return self._angle3
+
+    @property
+    def rot_order(self):
+        return self._rot_order
+
+
+class BodyOrienter(ThreeAngleOrienter):
+    """
+    Class to denote a body-orienter.
+    """
+
+    _in_order = True
+
+    def __new__(cls, angle1, angle2, angle3, rot_order):
+        obj = ThreeAngleOrienter.__new__(cls, angle1, angle2, angle3,
+                                         rot_order)
+        return obj
+
+    def __init__(self, angle1, angle2, angle3, rot_order):
+        """
+        Body orientation takes this coordinate system through three
+        successive simple rotations.
+
+        Body fixed rotations include both Euler Angles and
+        Tait-Bryan Angles, see https://en.wikipedia.org/wiki/Euler_angles.
+
+        Parameters
+        ==========
+
+        angle1, angle2, angle3 : Expr
+            Three successive angles to rotate the coordinate system by
+
+        rotation_order : string
+            String defining the order of axes for rotation
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D, BodyOrienter
+        >>> from sympy import symbols
+        >>> q1, q2, q3 = symbols('q1 q2 q3')
+        >>> N = CoordSys3D('N')
+
+        A 'Body' fixed rotation is described by three angles and
+        three body-fixed rotation axes. To orient a coordinate system D
+        with respect to N, each sequential rotation is always about
+        the orthogonal unit vectors fixed to D. For example, a '123'
+        rotation will specify rotations about N.i, then D.j, then
+        D.k. (Initially, D.i is same as N.i)
+        Therefore,
+
+        >>> body_orienter = BodyOrienter(q1, q2, q3, '123')
+        >>> D = N.orient_new('D', (body_orienter, ))
+
+        is same as
+
+        >>> from sympy.vector import AxisOrienter
+        >>> axis_orienter1 = AxisOrienter(q1, N.i)
+        >>> D = N.orient_new('D', (axis_orienter1, ))
+        >>> axis_orienter2 = AxisOrienter(q2, D.j)
+        >>> D = D.orient_new('D', (axis_orienter2, ))
+        >>> axis_orienter3 = AxisOrienter(q3, D.k)
+        >>> D = D.orient_new('D', (axis_orienter3, ))
+
+        Acceptable rotation orders are of length 3, expressed in XYZ or
+        123, and cannot have a rotation about about an axis twice in a row.
+
+        >>> body_orienter1 = BodyOrienter(q1, q2, q3, '123')
+        >>> body_orienter2 = BodyOrienter(q1, q2, 0, 'ZXZ')
+        >>> body_orienter3 = BodyOrienter(0, 0, 0, 'XYX')
+
+        """
+        # Dummy initializer for docstrings
+        pass
+
+
+class SpaceOrienter(ThreeAngleOrienter):
+    """
+    Class to denote a space-orienter.
+    """
+
+    _in_order = False
+
+    def __new__(cls, angle1, angle2, angle3, rot_order):
+        obj = ThreeAngleOrienter.__new__(cls, angle1, angle2, angle3,
+                                         rot_order)
+        return obj
+
+    def __init__(self, angle1, angle2, angle3, rot_order):
+        """
+        Space rotation is similar to Body rotation, but the rotations
+        are applied in the opposite order.
+
+        Parameters
+        ==========
+
+        angle1, angle2, angle3 : Expr
+            Three successive angles to rotate the coordinate system by
+
+        rotation_order : string
+            String defining the order of axes for rotation
+
+        See Also
+        ========
+
+        BodyOrienter : Orienter to orient systems wrt Euler angles.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D, SpaceOrienter
+        >>> from sympy import symbols
+        >>> q1, q2, q3 = symbols('q1 q2 q3')
+        >>> N = CoordSys3D('N')
+
+        To orient a coordinate system D with respect to N, each
+        sequential rotation is always about N's orthogonal unit vectors.
+        For example, a '123' rotation will specify rotations about
+        N.i, then N.j, then N.k.
+        Therefore,
+
+        >>> space_orienter = SpaceOrienter(q1, q2, q3, '312')
+        >>> D = N.orient_new('D', (space_orienter, ))
+
+        is same as
+
+        >>> from sympy.vector import AxisOrienter
+        >>> axis_orienter1 = AxisOrienter(q1, N.i)
+        >>> B = N.orient_new('B', (axis_orienter1, ))
+        >>> axis_orienter2 = AxisOrienter(q2, N.j)
+        >>> C = B.orient_new('C', (axis_orienter2, ))
+        >>> axis_orienter3 = AxisOrienter(q3, N.k)
+        >>> D = C.orient_new('C', (axis_orienter3, ))
+
+        """
+        # Dummy initializer for docstrings
+        pass
+
+
+class QuaternionOrienter(Orienter):
+    """
+    Class to denote a quaternion-orienter.
+    """
+
+    def __new__(cls, q0, q1, q2, q3):
+        q0 = sympify(q0)
+        q1 = sympify(q1)
+        q2 = sympify(q2)
+        q3 = sympify(q3)
+        parent_orient = (Matrix([[q0 ** 2 + q1 ** 2 - q2 ** 2 -
+                                  q3 ** 2,
+                                  2 * (q1 * q2 - q0 * q3),
+                                  2 * (q0 * q2 + q1 * q3)],
+                                 [2 * (q1 * q2 + q0 * q3),
+                                  q0 ** 2 - q1 ** 2 +
+                                  q2 ** 2 - q3 ** 2,
+                                  2 * (q2 * q3 - q0 * q1)],
+                                 [2 * (q1 * q3 - q0 * q2),
+                                  2 * (q0 * q1 + q2 * q3),
+                                  q0 ** 2 - q1 ** 2 -
+                                  q2 ** 2 + q3 ** 2]]))
+        parent_orient = parent_orient.T
+
+        obj = super().__new__(cls, q0, q1, q2, q3)
+        obj._q0 = q0
+        obj._q1 = q1
+        obj._q2 = q2
+        obj._q3 = q3
+        obj._parent_orient = parent_orient
+
+        return obj
+
+    def __init__(self, angle1, angle2, angle3, rot_order):
+        """
+        Quaternion orientation orients the new CoordSys3D with
+        Quaternions, defined as a finite rotation about lambda, a unit
+        vector, by some amount theta.
+
+        This orientation is described by four parameters:
+
+        q0 = cos(theta/2)
+
+        q1 = lambda_x sin(theta/2)
+
+        q2 = lambda_y sin(theta/2)
+
+        q3 = lambda_z sin(theta/2)
+
+        Quaternion does not take in a rotation order.
+
+        Parameters
+        ==========
+
+        q0, q1, q2, q3 : Expr
+            The quaternions to rotate the coordinate system by
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import symbols
+        >>> q0, q1, q2, q3 = symbols('q0 q1 q2 q3')
+        >>> N = CoordSys3D('N')
+        >>> from sympy.vector import QuaternionOrienter
+        >>> q_orienter = QuaternionOrienter(q0, q1, q2, q3)
+        >>> B = N.orient_new('B', (q_orienter, ))
+
+        """
+        # Dummy initializer for docstrings
+        pass
+
+    @property
+    def q0(self):
+        return self._q0
+
+    @property
+    def q1(self):
+        return self._q1
+
+    @property
+    def q2(self):
+        return self._q2
+
+    @property
+    def q3(self):
+        return self._q3
+
+
+def _rot(axis, angle):
+    """DCM for simple axis 1, 2 or 3 rotations. """
+    if axis == 1:
+        return Matrix(rot_axis1(angle).T)
+    elif axis == 2:
+        return Matrix(rot_axis2(angle).T)
+    elif axis == 3:
+        return Matrix(rot_axis3(angle).T)
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/parametricregion.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/parametricregion.py
new file mode 100644
index 0000000000..c3cd6f0e0a
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/parametricregion.py
@@ -0,0 +1,188 @@
+from functools import singledispatch
+from sympy import pi, tan
+from sympy.simplify import trigsimp
+from sympy.core import Basic, Tuple
+from sympy.core.symbol import _symbol
+from sympy.solvers import solve
+from sympy.geometry import Point, Segment, Curve, Ellipse, Polygon
+from sympy.vector import ImplicitRegion
+
+
+class ParametricRegion(Basic):
+    """
+    Represents a parametric region in space.
+
+    Examples
+    ========
+
+    >>> from sympy import cos, sin, pi
+    >>> from sympy.abc import r, theta, t, a, b, x, y
+    >>> from sympy.vector import ParametricRegion
+
+    >>> ParametricRegion((t, t**2), (t, -1, 2))
+    ParametricRegion((t, t**2), (t, -1, 2))
+    >>> ParametricRegion((x, y), (x, 3, 4), (y, 5, 6))
+    ParametricRegion((x, y), (x, 3, 4), (y, 5, 6))
+    >>> ParametricRegion((r*cos(theta), r*sin(theta)), (r, -2, 2), (theta, 0, pi))
+    ParametricRegion((r*cos(theta), r*sin(theta)), (r, -2, 2), (theta, 0, pi))
+    >>> ParametricRegion((a*cos(t), b*sin(t)), t)
+    ParametricRegion((a*cos(t), b*sin(t)), t)
+
+    >>> circle = ParametricRegion((r*cos(theta), r*sin(theta)), r, (theta, 0, pi))
+    >>> circle.parameters
+    (r, theta)
+    >>> circle.definition
+    (r*cos(theta), r*sin(theta))
+    >>> circle.limits
+    {theta: (0, pi)}
+
+    Dimension of a parametric region determines whether a region is a curve, surface
+    or volume region. It does not represent its dimensions in space.
+
+    >>> circle.dimensions
+    1
+
+    Parameters
+    ==========
+
+    definition : tuple to define base scalars in terms of parameters.
+
+    bounds : Parameter or a tuple of length 3 to define parameter and corresponding lower and upper bound.
+
+    """
+    def __new__(cls, definition, *bounds):
+        parameters = ()
+        limits = {}
+
+        if not isinstance(bounds, Tuple):
+            bounds = Tuple(*bounds)
+
+        for bound in bounds:
+            if  isinstance(bound, tuple) or isinstance(bound, Tuple):
+                if len(bound) != 3:
+                    raise ValueError("Tuple should be in the form (parameter, lowerbound, upperbound)")
+                parameters += (bound[0],)
+                limits[bound[0]] = (bound[1], bound[2])
+            else:
+                parameters += (bound,)
+
+        if not (isinstance(definition, tuple) or isinstance(definition, Tuple)):
+            definition = (definition,)
+
+        obj = super().__new__(cls, Tuple(*definition), *bounds)
+        obj._parameters = parameters
+        obj._limits = limits
+
+        return obj
+
+    @property
+    def definition(self):
+        return self.args[0]
+
+    @property
+    def limits(self):
+        return self._limits
+
+    @property
+    def parameters(self):
+        return self._parameters
+
+    @property
+    def dimensions(self):
+        return len(self.limits)
+
+
+@singledispatch
+def parametric_region_list(reg):
+    """
+    Returns a list of ParametricRegion objects representing the geometric region.
+
+    Examples
+    ========
+
+    >>> from sympy.abc import t
+    >>> from sympy.vector import parametric_region_list
+    >>> from sympy.geometry import Point, Curve, Ellipse, Segment, Polygon
+
+    >>> p = Point(2, 5)
+    >>> parametric_region_list(p)
+    [ParametricRegion((2, 5))]
+
+    >>> c = Curve((t**3, 4*t), (t, -3, 4))
+    >>> parametric_region_list(c)
+    [ParametricRegion((t**3, 4*t), (t, -3, 4))]
+
+    >>> e = Ellipse(Point(1, 3), 2, 3)
+    >>> parametric_region_list(e)
+    [ParametricRegion((2*cos(t) + 1, 3*sin(t) + 3), (t, 0, 2*pi))]
+
+    >>> s = Segment(Point(1, 3), Point(2, 6))
+    >>> parametric_region_list(s)
+    [ParametricRegion((t + 1, 3*t + 3), (t, 0, 1))]
+
+    >>> p1, p2, p3, p4 = [(0, 1), (2, -3), (5, 3), (-2, 3)]
+    >>> poly = Polygon(p1, p2, p3, p4)
+    >>> parametric_region_list(poly)
+    [ParametricRegion((2*t, 1 - 4*t), (t, 0, 1)), ParametricRegion((3*t + 2, 6*t - 3), (t, 0, 1)),\
+     ParametricRegion((5 - 7*t, 3), (t, 0, 1)), ParametricRegion((2*t - 2, 3 - 2*t),  (t, 0, 1))]
+
+    """
+    raise ValueError("SymPy cannot determine parametric representation of the region.")
+
+
+@parametric_region_list.register(Point)
+def _(obj):
+    return [ParametricRegion(obj.args)]
+
+
+@parametric_region_list.register(Curve)  # type: ignore
+def _(obj):
+    definition = obj.arbitrary_point(obj.parameter).args
+    bounds = obj.limits
+    return [ParametricRegion(definition, bounds)]
+
+
+@parametric_region_list.register(Ellipse) # type: ignore
+def _(obj, parameter='t'):
+    definition = obj.arbitrary_point(parameter).args
+    t = _symbol(parameter, real=True)
+    bounds = (t, 0, 2*pi)
+    return [ParametricRegion(definition, bounds)]
+
+
+@parametric_region_list.register(Segment) # type: ignore
+def _(obj, parameter='t'):
+    t = _symbol(parameter, real=True)
+    definition = obj.arbitrary_point(t).args
+
+    for i in range(0, 3):
+        lower_bound = solve(definition[i] - obj.points[0].args[i], t)
+        upper_bound = solve(definition[i] - obj.points[1].args[i], t)
+
+        if len(lower_bound) == 1 and len(upper_bound) == 1:
+            bounds = t, lower_bound[0], upper_bound[0]
+            break
+
+    definition_tuple = obj.arbitrary_point(parameter).args
+    return [ParametricRegion(definition_tuple, bounds)]
+
+
+@parametric_region_list.register(Polygon) # type: ignore
+def _(obj, parameter='t'):
+    l = [parametric_region_list(side, parameter)[0] for side in obj.sides]
+    return l
+
+
+@parametric_region_list.register(ImplicitRegion) # type: ignore
+def _(obj, parameters=('t', 's')):
+    definition = obj.rational_parametrization(parameters)
+    bounds = []
+
+    for i in range(len(obj.variables) - 1):
+        # Each parameter is replaced by its tangent to simplify intergation
+        parameter = _symbol(parameters[i], real=True)
+        definition = [trigsimp(elem.subs(parameter, tan(parameter))) for elem in definition]
+        bounds.append((parameter, 0, 2*pi),)
+
+    definition = Tuple(*definition)
+    return [ParametricRegion(definition, *bounds)]
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/point.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/point.py
new file mode 100644
index 0000000000..e46bb22d91
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/point.py
@@ -0,0 +1,151 @@
+from sympy.core.basic import Basic
+from sympy.core.symbol import Str
+from sympy.vector.vector import Vector
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.vector.functions import _path
+from sympy.core.cache import cacheit
+
+
+class Point(Basic):
+    """
+    Represents a point in 3-D space.
+    """
+
+    def __new__(cls, name, position=Vector.zero, parent_point=None):
+        name = str(name)
+        # Check the args first
+        if not isinstance(position, Vector):
+            raise TypeError(
+                "position should be an instance of Vector, not %s" % type(
+                    position))
+        if (not isinstance(parent_point, Point) and
+                parent_point is not None):
+            raise TypeError(
+                "parent_point should be an instance of Point, not %s" % type(
+                    parent_point))
+        # Super class construction
+        if parent_point is None:
+            obj = super().__new__(cls, Str(name), position)
+        else:
+            obj = super().__new__(cls, Str(name), position, parent_point)
+        # Decide the object parameters
+        obj._name = name
+        obj._pos = position
+        if parent_point is None:
+            obj._parent = None
+            obj._root = obj
+        else:
+            obj._parent = parent_point
+            obj._root = parent_point._root
+        # Return object
+        return obj
+
+    @cacheit
+    def position_wrt(self, other):
+        """
+        Returns the position vector of this Point with respect to
+        another Point/CoordSys3D.
+
+        Parameters
+        ==========
+
+        other : Point/CoordSys3D
+            If other is a Point, the position of this Point wrt it is
+            returned. If its an instance of CoordSyRect, the position
+            wrt its origin is returned.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> N = CoordSys3D('N')
+        >>> p1 = N.origin.locate_new('p1', 10 * N.i)
+        >>> N.origin.position_wrt(p1)
+        (-10)*N.i
+
+        """
+
+        if (not isinstance(other, Point) and
+                not isinstance(other, CoordSys3D)):
+            raise TypeError(str(other) +
+                            "is not a Point or CoordSys3D")
+        if isinstance(other, CoordSys3D):
+            other = other.origin
+        # Handle special cases
+        if other == self:
+            return Vector.zero
+        elif other == self._parent:
+            return self._pos
+        elif other._parent == self:
+            return -1 * other._pos
+        # Else, use point tree to calculate position
+        rootindex, path = _path(self, other)
+        result = Vector.zero
+        i = -1
+        for i in range(rootindex):
+            result += path[i]._pos
+        i += 2
+        while i < len(path):
+            result -= path[i]._pos
+            i += 1
+        return result
+
+    def locate_new(self, name, position):
+        """
+        Returns a new Point located at the given position wrt this
+        Point.
+        Thus, the position vector of the new Point wrt this one will
+        be equal to the given 'position' parameter.
+
+        Parameters
+        ==========
+
+        name : str
+            Name of the new point
+
+        position : Vector
+            The position vector of the new Point wrt this one
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> N = CoordSys3D('N')
+        >>> p1 = N.origin.locate_new('p1', 10 * N.i)
+        >>> p1.position_wrt(N.origin)
+        10*N.i
+
+        """
+        return Point(name, position, self)
+
+    def express_coordinates(self, coordinate_system):
+        """
+        Returns the Cartesian/rectangular coordinates of this point
+        wrt the origin of the given CoordSys3D instance.
+
+        Parameters
+        ==========
+
+        coordinate_system : CoordSys3D
+            The coordinate system to express the coordinates of this
+            Point in.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> N = CoordSys3D('N')
+        >>> p1 = N.origin.locate_new('p1', 10 * N.i)
+        >>> p2 = p1.locate_new('p2', 5 * N.j)
+        >>> p2.express_coordinates(N)
+        (10, 5, 0)
+
+        """
+
+        # Determine the position vector
+        pos_vect = self.position_wrt(coordinate_system.origin)
+        # Express it in the given coordinate system
+        return tuple(pos_vect.to_matrix(coordinate_system))
+
+    def _sympystr(self, printer):
+        return self._name
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/scalar.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/scalar.py
new file mode 100644
index 0000000000..2441b6aeed
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/scalar.py
@@ -0,0 +1,71 @@
+from sympy.core import AtomicExpr, Symbol, S
+from sympy.core.sympify import _sympify
+from sympy.printing.pretty.stringpict import prettyForm
+from sympy.printing.precedence import PRECEDENCE
+
+
+class BaseScalar(AtomicExpr):
+    """
+    A coordinate symbol/base scalar.
+
+    Ideally, users should not instantiate this class.
+
+    Unicode pretty forms in Python 2 should use the `u` prefix.
+
+    """
+
+    def __new__(cls, index, system, pretty_str=None, latex_str=None):
+        from sympy.vector.coordsysrect import CoordSys3D
+        if pretty_str is None:
+            pretty_str = "x{}".format(index)
+        elif isinstance(pretty_str, Symbol):
+            pretty_str = pretty_str.name
+        if latex_str is None:
+            latex_str = "x_{}".format(index)
+        elif isinstance(latex_str, Symbol):
+            latex_str = latex_str.name
+
+        index = _sympify(index)
+        system = _sympify(system)
+        obj = super().__new__(cls, index, system)
+        if not isinstance(system, CoordSys3D):
+            raise TypeError("system should be a CoordSys3D")
+        if index not in range(0, 3):
+            raise ValueError("Invalid index specified.")
+        # The _id is used for equating purposes, and for hashing
+        obj._id = (index, system)
+        obj._name = obj.name = system._name + '.' + system._variable_names[index]
+        obj._pretty_form = '' + pretty_str
+        obj._latex_form = latex_str
+        obj._system = system
+
+        return obj
+
+    is_commutative = True
+    is_symbol = True
+
+    @property
+    def free_symbols(self):
+        return {self}
+
+    _diff_wrt = True
+
+    def _eval_derivative(self, s):
+        if self == s:
+            return S.One
+        return S.Zero
+
+    def _latex(self, printer=None):
+        return self._latex_form
+
+    def _pretty(self, printer=None):
+        return prettyForm(self._pretty_form)
+
+    precedence = PRECEDENCE['Atom']
+
+    @property
+    def system(self):
+        return self._system
+
+    def _sympystr(self, printer):
+        return self._name
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/__init__.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_coordsysrect.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_coordsysrect.py
new file mode 100644
index 0000000000..fd35f60ae9
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_coordsysrect.py
@@ -0,0 +1,462 @@
+from sympy.testing.pytest import raises, warns_deprecated_sympy
+from sympy.vector.coordsysrect import CoordSys3D, CoordSysCartesian
+from sympy.vector.scalar import BaseScalar
+from sympy import sin, sinh, cos, cosh, sqrt, pi, ImmutableMatrix as Matrix, \
+     symbols, simplify, zeros, expand, acos, atan2
+from sympy.vector.functions import express
+from sympy.vector.point import Point
+from sympy.vector.vector import Vector
+from sympy.vector.orienters import (AxisOrienter, BodyOrienter,
+                                    SpaceOrienter, QuaternionOrienter)
+
+
+x, y, z = symbols('x y z')
+a, b, c, q = symbols('a b c q')
+q1, q2, q3, q4 = symbols('q1 q2 q3 q4')
+
+
+def test_func_args():
+    A = CoordSys3D('A')
+    assert A.x.func(*A.x.args) == A.x
+    expr = 3*A.x + 4*A.y
+    assert expr.func(*expr.args) == expr
+    assert A.i.func(*A.i.args) == A.i
+    v = A.x*A.i + A.y*A.j + A.z*A.k
+    assert v.func(*v.args) == v
+    assert A.origin.func(*A.origin.args) == A.origin
+
+
+def test_coordsyscartesian_equivalence():
+    A = CoordSys3D('A')
+    A1 = CoordSys3D('A')
+    assert A1 == A
+    B = CoordSys3D('B')
+    assert A != B
+
+
+def test_orienters():
+    A = CoordSys3D('A')
+    axis_orienter = AxisOrienter(a, A.k)
+    body_orienter = BodyOrienter(a, b, c, '123')
+    space_orienter = SpaceOrienter(a, b, c, '123')
+    q_orienter = QuaternionOrienter(q1, q2, q3, q4)
+    assert axis_orienter.rotation_matrix(A) == Matrix([
+        [ cos(a), sin(a), 0],
+        [-sin(a), cos(a), 0],
+        [      0,      0, 1]])
+    assert body_orienter.rotation_matrix() == Matrix([
+        [ cos(b)*cos(c),  sin(a)*sin(b)*cos(c) + sin(c)*cos(a),
+          sin(a)*sin(c) - sin(b)*cos(a)*cos(c)],
+        [-sin(c)*cos(b), -sin(a)*sin(b)*sin(c) + cos(a)*cos(c),
+         sin(a)*cos(c) + sin(b)*sin(c)*cos(a)],
+        [        sin(b),                        -sin(a)*cos(b),
+                 cos(a)*cos(b)]])
+    assert space_orienter.rotation_matrix() == Matrix([
+        [cos(b)*cos(c), sin(c)*cos(b),       -sin(b)],
+        [sin(a)*sin(b)*cos(c) - sin(c)*cos(a),
+         sin(a)*sin(b)*sin(c) + cos(a)*cos(c), sin(a)*cos(b)],
+        [sin(a)*sin(c) + sin(b)*cos(a)*cos(c), -sin(a)*cos(c) +
+         sin(b)*sin(c)*cos(a), cos(a)*cos(b)]])
+    assert q_orienter.rotation_matrix() == Matrix([
+        [q1**2 + q2**2 - q3**2 - q4**2, 2*q1*q4 + 2*q2*q3,
+         -2*q1*q3 + 2*q2*q4],
+        [-2*q1*q4 + 2*q2*q3, q1**2 - q2**2 + q3**2 - q4**2,
+         2*q1*q2 + 2*q3*q4],
+        [2*q1*q3 + 2*q2*q4,
+         -2*q1*q2 + 2*q3*q4, q1**2 - q2**2 - q3**2 + q4**2]])
+
+
+def test_coordinate_vars():
+    """
+    Tests the coordinate variables functionality with respect to
+    reorientation of coordinate systems.
+    """
+    A = CoordSys3D('A')
+    # Note that the name given on the lhs is different from A.x._name
+    assert BaseScalar(0, A, 'A_x', r'\mathbf{{x}_{A}}') == A.x
+    assert BaseScalar(1, A, 'A_y', r'\mathbf{{y}_{A}}') == A.y
+    assert BaseScalar(2, A, 'A_z', r'\mathbf{{z}_{A}}') == A.z
+    assert BaseScalar(0, A, 'A_x', r'\mathbf{{x}_{A}}').__hash__() == A.x.__hash__()
+    assert isinstance(A.x, BaseScalar) and \
+           isinstance(A.y, BaseScalar) and \
+           isinstance(A.z, BaseScalar)
+    assert A.x*A.y == A.y*A.x
+    assert A.scalar_map(A) == {A.x: A.x, A.y: A.y, A.z: A.z}
+    assert A.x.system == A
+    assert A.x.diff(A.x) == 1
+    B = A.orient_new_axis('B', q, A.k)
+    assert B.scalar_map(A) == {B.z: A.z, B.y: -A.x*sin(q) + A.y*cos(q),
+                                 B.x: A.x*cos(q) + A.y*sin(q)}
+    assert A.scalar_map(B) == {A.x: B.x*cos(q) - B.y*sin(q),
+                                 A.y: B.x*sin(q) + B.y*cos(q), A.z: B.z}
+    assert express(B.x, A, variables=True) == A.x*cos(q) + A.y*sin(q)
+    assert express(B.y, A, variables=True) == -A.x*sin(q) + A.y*cos(q)
+    assert express(B.z, A, variables=True) == A.z
+    assert expand(express(B.x*B.y*B.z, A, variables=True)) == \
+           expand(A.z*(-A.x*sin(q) + A.y*cos(q))*(A.x*cos(q) + A.y*sin(q)))
+    assert express(B.x*B.i + B.y*B.j + B.z*B.k, A) == \
+           (B.x*cos(q) - B.y*sin(q))*A.i + (B.x*sin(q) + \
+           B.y*cos(q))*A.j + B.z*A.k
+    assert simplify(express(B.x*B.i + B.y*B.j + B.z*B.k, A, \
+                            variables=True)) == \
+           A.x*A.i + A.y*A.j + A.z*A.k
+    assert express(A.x*A.i + A.y*A.j + A.z*A.k, B) == \
+           (A.x*cos(q) + A.y*sin(q))*B.i + \
+           (-A.x*sin(q) + A.y*cos(q))*B.j + A.z*B.k
+    assert simplify(express(A.x*A.i + A.y*A.j + A.z*A.k, B, \
+                            variables=True)) == \
+           B.x*B.i + B.y*B.j + B.z*B.k
+    N = B.orient_new_axis('N', -q, B.k)
+    assert N.scalar_map(A) == \
+           {N.x: A.x, N.z: A.z, N.y: A.y}
+    C = A.orient_new_axis('C', q, A.i + A.j + A.k)
+    mapping = A.scalar_map(C)
+    assert mapping[A.x].equals(C.x*(2*cos(q) + 1)/3 +
+                            C.y*(-2*sin(q + pi/6) + 1)/3 +
+                            C.z*(-2*cos(q + pi/3) + 1)/3)
+    assert mapping[A.y].equals(C.x*(-2*cos(q + pi/3) + 1)/3 +
+                            C.y*(2*cos(q) + 1)/3 +
+                            C.z*(-2*sin(q + pi/6) + 1)/3)
+    assert mapping[A.z].equals(C.x*(-2*sin(q + pi/6) + 1)/3 +
+                            C.y*(-2*cos(q + pi/3) + 1)/3 +
+                            C.z*(2*cos(q) + 1)/3)
+    D = A.locate_new('D', a*A.i + b*A.j + c*A.k)
+    assert D.scalar_map(A) == {D.z: A.z - c, D.x: A.x - a, D.y: A.y - b}
+    E = A.orient_new_axis('E', a, A.k, a*A.i + b*A.j + c*A.k)
+    assert A.scalar_map(E) == {A.z: E.z + c,
+                               A.x: E.x*cos(a) - E.y*sin(a) + a,
+                               A.y: E.x*sin(a) + E.y*cos(a) + b}
+    assert E.scalar_map(A) == {E.x: (A.x - a)*cos(a) + (A.y - b)*sin(a),
+                               E.y: (-A.x + a)*sin(a) + (A.y - b)*cos(a),
+                               E.z: A.z - c}
+    F = A.locate_new('F', Vector.zero)
+    assert A.scalar_map(F) == {A.z: F.z, A.x: F.x, A.y: F.y}
+
+
+def test_rotation_matrix():
+    N = CoordSys3D('N')
+    A = N.orient_new_axis('A', q1, N.k)
+    B = A.orient_new_axis('B', q2, A.i)
+    C = B.orient_new_axis('C', q3, B.j)
+    D = N.orient_new_axis('D', q4, N.j)
+    E = N.orient_new_space('E', q1, q2, q3, '123')
+    F = N.orient_new_quaternion('F', q1, q2, q3, q4)
+    G = N.orient_new_body('G', q1, q2, q3, '123')
+    assert N.rotation_matrix(C) == Matrix([
+        [- sin(q1) * sin(q2) * sin(q3) + cos(q1) * cos(q3), - sin(q1) *
+        cos(q2), sin(q1) * sin(q2) * cos(q3) + sin(q3) * cos(q1)], \
+        [sin(q1) * cos(q3) + sin(q2) * sin(q3) * cos(q1), \
+         cos(q1) * cos(q2), sin(q1) * sin(q3) - sin(q2) * cos(q1) * \
+         cos(q3)], [- sin(q3) * cos(q2), sin(q2), cos(q2) * cos(q3)]])
+    test_mat = D.rotation_matrix(C) - Matrix(
+        [[cos(q1) * cos(q3) * cos(q4) - sin(q3) * (- sin(q4) * cos(q2) +
+        sin(q1) * sin(q2) * cos(q4)), - sin(q2) * sin(q4) - sin(q1) *
+            cos(q2) * cos(q4), sin(q3) * cos(q1) * cos(q4) + cos(q3) * \
+          (- sin(q4) * cos(q2) + sin(q1) * sin(q2) * cos(q4))], \
+         [sin(q1) * cos(q3) + sin(q2) * sin(q3) * cos(q1), cos(q1) * \
+          cos(q2), sin(q1) * sin(q3) - sin(q2) * cos(q1) * cos(q3)], \
+         [sin(q4) * cos(q1) * cos(q3) - sin(q3) * (cos(q2) * cos(q4) + \
+                                                   sin(q1) * sin(q2) * \
+                                                   sin(q4)), sin(q2) *
+                cos(q4) - sin(q1) * sin(q4) * cos(q2), sin(q3) * \
+          sin(q4) * cos(q1) + cos(q3) * (cos(q2) * cos(q4) + \
+                                         sin(q1) * sin(q2) * sin(q4))]])
+    assert test_mat.expand() == zeros(3, 3)
+    assert E.rotation_matrix(N) == Matrix(
+        [[cos(q2)*cos(q3), sin(q3)*cos(q2), -sin(q2)],
+        [sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1), \
+         sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3), sin(q1)*cos(q2)], \
+         [sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3), - \
+          sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1), cos(q1)*cos(q2)]])
+    assert F.rotation_matrix(N) == Matrix([[
+        q1**2 + q2**2 - q3**2 - q4**2,
+        2*q1*q4 + 2*q2*q3, -2*q1*q3 + 2*q2*q4],[ -2*q1*q4 + 2*q2*q3,
+            q1**2 - q2**2 + q3**2 - q4**2, 2*q1*q2 + 2*q3*q4],
+                                           [2*q1*q3 + 2*q2*q4,
+                                            -2*q1*q2 + 2*q3*q4,
+                                q1**2 - q2**2 - q3**2 + q4**2]])
+    assert G.rotation_matrix(N) == Matrix([[
+        cos(q2)*cos(q3),  sin(q1)*sin(q2)*cos(q3) + sin(q3)*cos(q1),
+        sin(q1)*sin(q3) - sin(q2)*cos(q1)*cos(q3)], [
+            -sin(q3)*cos(q2), -sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3),
+            sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1)],[
+                sin(q2), -sin(q1)*cos(q2), cos(q1)*cos(q2)]])
+
+
+def test_vector_with_orientation():
+    """
+    Tests the effects of orientation of coordinate systems on
+    basic vector operations.
+    """
+    N = CoordSys3D('N')
+    A = N.orient_new_axis('A', q1, N.k)
+    B = A.orient_new_axis('B', q2, A.i)
+    C = B.orient_new_axis('C', q3, B.j)
+
+    # Test to_matrix
+    v1 = a*N.i + b*N.j + c*N.k
+    assert v1.to_matrix(A) == Matrix([[ a*cos(q1) + b*sin(q1)],
+                                      [-a*sin(q1) + b*cos(q1)],
+                                      [                     c]])
+
+    # Test dot
+    assert N.i.dot(A.i) == cos(q1)
+    assert N.i.dot(A.j) == -sin(q1)
+    assert N.i.dot(A.k) == 0
+    assert N.j.dot(A.i) == sin(q1)
+    assert N.j.dot(A.j) == cos(q1)
+    assert N.j.dot(A.k) == 0
+    assert N.k.dot(A.i) == 0
+    assert N.k.dot(A.j) == 0
+    assert N.k.dot(A.k) == 1
+
+    assert N.i.dot(A.i + A.j) == -sin(q1) + cos(q1) == \
+           (A.i + A.j).dot(N.i)
+
+    assert A.i.dot(C.i) == cos(q3)
+    assert A.i.dot(C.j) == 0
+    assert A.i.dot(C.k) == sin(q3)
+    assert A.j.dot(C.i) == sin(q2)*sin(q3)
+    assert A.j.dot(C.j) == cos(q2)
+    assert A.j.dot(C.k) == -sin(q2)*cos(q3)
+    assert A.k.dot(C.i) == -cos(q2)*sin(q3)
+    assert A.k.dot(C.j) == sin(q2)
+    assert A.k.dot(C.k) == cos(q2)*cos(q3)
+
+    # Test cross
+    assert N.i.cross(A.i) == sin(q1)*A.k
+    assert N.i.cross(A.j) == cos(q1)*A.k
+    assert N.i.cross(A.k) == -sin(q1)*A.i - cos(q1)*A.j
+    assert N.j.cross(A.i) == -cos(q1)*A.k
+    assert N.j.cross(A.j) == sin(q1)*A.k
+    assert N.j.cross(A.k) == cos(q1)*A.i - sin(q1)*A.j
+    assert N.k.cross(A.i) == A.j
+    assert N.k.cross(A.j) == -A.i
+    assert N.k.cross(A.k) == Vector.zero
+
+    assert N.i.cross(A.i) == sin(q1)*A.k
+    assert N.i.cross(A.j) == cos(q1)*A.k
+    assert N.i.cross(A.i + A.j) == sin(q1)*A.k + cos(q1)*A.k
+    assert (A.i + A.j).cross(N.i) == (-sin(q1) - cos(q1))*N.k
+
+    assert A.i.cross(C.i) == sin(q3)*C.j
+    assert A.i.cross(C.j) == -sin(q3)*C.i + cos(q3)*C.k
+    assert A.i.cross(C.k) == -cos(q3)*C.j
+    assert C.i.cross(A.i) == (-sin(q3)*cos(q2))*A.j + \
+           (-sin(q2)*sin(q3))*A.k
+    assert C.j.cross(A.i) == (sin(q2))*A.j + (-cos(q2))*A.k
+    assert express(C.k.cross(A.i), C).trigsimp() == cos(q3)*C.j
+
+
+def test_orient_new_methods():
+    N = CoordSys3D('N')
+    orienter1 = AxisOrienter(q4, N.j)
+    orienter2 = SpaceOrienter(q1, q2, q3, '123')
+    orienter3 = QuaternionOrienter(q1, q2, q3, q4)
+    orienter4 = BodyOrienter(q1, q2, q3, '123')
+    D = N.orient_new('D', (orienter1, ))
+    E = N.orient_new('E', (orienter2, ))
+    F = N.orient_new('F', (orienter3, ))
+    G = N.orient_new('G', (orienter4, ))
+    assert D == N.orient_new_axis('D', q4, N.j)
+    assert E == N.orient_new_space('E', q1, q2, q3, '123')
+    assert F == N.orient_new_quaternion('F', q1, q2, q3, q4)
+    assert G == N.orient_new_body('G', q1, q2, q3, '123')
+
+
+def test_locatenew_point():
+    """
+    Tests Point class, and locate_new method in CoordSysCartesian.
+    """
+    A = CoordSys3D('A')
+    assert isinstance(A.origin, Point)
+    v = a*A.i + b*A.j + c*A.k
+    C = A.locate_new('C', v)
+    assert C.origin.position_wrt(A) == \
+           C.position_wrt(A) == \
+           C.origin.position_wrt(A.origin) == v
+    assert A.origin.position_wrt(C) == \
+           A.position_wrt(C) == \
+           A.origin.position_wrt(C.origin) == -v
+    assert A.origin.express_coordinates(C) == (-a, -b, -c)
+    p = A.origin.locate_new('p', -v)
+    assert p.express_coordinates(A) == (-a, -b, -c)
+    assert p.position_wrt(C.origin) == p.position_wrt(C) == \
+           -2 * v
+    p1 = p.locate_new('p1', 2*v)
+    assert p1.position_wrt(C.origin) == Vector.zero
+    assert p1.express_coordinates(C) == (0, 0, 0)
+    p2 = p.locate_new('p2', A.i)
+    assert p1.position_wrt(p2) == 2*v - A.i
+    assert p2.express_coordinates(C) == (-2*a + 1, -2*b, -2*c)
+
+
+def test_create_new():
+    a = CoordSys3D('a')
+    c = a.create_new('c', transformation='spherical')
+    assert c._parent == a
+    assert c.transformation_to_parent() == \
+           (c.r*sin(c.theta)*cos(c.phi), c.r*sin(c.theta)*sin(c.phi), c.r*cos(c.theta))
+    assert c.transformation_from_parent() == \
+           (sqrt(a.x**2 + a.y**2 + a.z**2), acos(a.z/sqrt(a.x**2 + a.y**2 + a.z**2)), atan2(a.y, a.x))
+
+
+def test_evalf():
+    A = CoordSys3D('A')
+    v = 3*A.i + 4*A.j + a*A.k
+    assert v.n() == v.evalf()
+    assert v.evalf(subs={a:1}) == v.subs(a, 1).evalf()
+
+
+def test_lame_coefficients():
+    a = CoordSys3D('a', 'spherical')
+    assert a.lame_coefficients() == (1, a.r, sin(a.theta)*a.r)
+    a = CoordSys3D('a')
+    assert a.lame_coefficients() == (1, 1, 1)
+    a = CoordSys3D('a', 'cartesian')
+    assert a.lame_coefficients() == (1, 1, 1)
+    a = CoordSys3D('a', 'cylindrical')
+    assert a.lame_coefficients() == (1, a.r, 1)
+
+
+def test_transformation_equations():
+
+    x, y, z = symbols('x y z')
+    # Str
+    a = CoordSys3D('a', transformation='spherical',
+                   variable_names=["r", "theta", "phi"])
+    r, theta, phi = a.base_scalars()
+
+    assert r == a.r
+    assert theta == a.theta
+    assert phi == a.phi
+
+    raises(AttributeError, lambda: a.x)
+    raises(AttributeError, lambda: a.y)
+    raises(AttributeError, lambda: a.z)
+
+    assert a.transformation_to_parent() == (
+        r*sin(theta)*cos(phi),
+        r*sin(theta)*sin(phi),
+        r*cos(theta)
+    )
+    assert a.lame_coefficients() == (1, r, r*sin(theta))
+    assert a.transformation_from_parent_function()(x, y, z) == (
+        sqrt(x ** 2 + y ** 2 + z ** 2),
+        acos((z) / sqrt(x**2 + y**2 + z**2)),
+        atan2(y, x)
+    )
+    a = CoordSys3D('a', transformation='cylindrical',
+                   variable_names=["r", "theta", "z"])
+    r, theta, z = a.base_scalars()
+    assert a.transformation_to_parent() == (
+        r*cos(theta),
+        r*sin(theta),
+        z
+    )
+    assert a.lame_coefficients() == (1, a.r, 1)
+    assert a.transformation_from_parent_function()(x, y, z) == (sqrt(x**2 + y**2),
+                            atan2(y, x), z)
+
+    a = CoordSys3D('a', 'cartesian')
+    assert a.transformation_to_parent() == (a.x, a.y, a.z)
+    assert a.lame_coefficients() == (1, 1, 1)
+    assert a.transformation_from_parent_function()(x, y, z) == (x, y, z)
+
+    # Variables and expressions
+
+    # Cartesian with equation tuple:
+    x, y, z = symbols('x y z')
+    a = CoordSys3D('a', ((x, y, z), (x, y, z)))
+    a._calculate_inv_trans_equations()
+    assert a.transformation_to_parent() == (a.x1, a.x2, a.x3)
+    assert a.lame_coefficients() == (1, 1, 1)
+    assert a.transformation_from_parent_function()(x, y, z) == (x, y, z)
+    r, theta, z = symbols("r theta z")
+
+    # Cylindrical with equation tuple:
+    a = CoordSys3D('a', [(r, theta, z), (r*cos(theta), r*sin(theta), z)],
+                   variable_names=["r", "theta", "z"])
+    r, theta, z = a.base_scalars()
+    assert a.transformation_to_parent() == (
+        r*cos(theta), r*sin(theta), z
+    )
+    assert a.lame_coefficients() == (
+        sqrt(sin(theta)**2 + cos(theta)**2),
+        sqrt(r**2*sin(theta)**2 + r**2*cos(theta)**2),
+        1
+    )  # ==> this should simplify to (1, r, 1), tests are too slow with `simplify`.
+
+    # Definitions with `lambda`:
+
+    # Cartesian with `lambda`
+    a = CoordSys3D('a', lambda x, y, z: (x, y, z))
+    assert a.transformation_to_parent() == (a.x1, a.x2, a.x3)
+    assert a.lame_coefficients() == (1, 1, 1)
+    a._calculate_inv_trans_equations()
+    assert a.transformation_from_parent_function()(x, y, z) == (x, y, z)
+
+    # Spherical with `lambda`
+    a = CoordSys3D('a', lambda r, theta, phi: (r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)),
+                   variable_names=["r", "theta", "phi"])
+    r, theta, phi = a.base_scalars()
+    assert a.transformation_to_parent() == (
+        r*sin(theta)*cos(phi), r*sin(phi)*sin(theta), r*cos(theta)
+    )
+    assert a.lame_coefficients() == (
+        sqrt(sin(phi)**2*sin(theta)**2 + sin(theta)**2*cos(phi)**2 + cos(theta)**2),
+        sqrt(r**2*sin(phi)**2*cos(theta)**2 + r**2*sin(theta)**2 + r**2*cos(phi)**2*cos(theta)**2),
+        sqrt(r**2*sin(phi)**2*sin(theta)**2 + r**2*sin(theta)**2*cos(phi)**2)
+    )  # ==> this should simplify to (1, r, sin(theta)*r), `simplify` is too slow.
+
+    # Cylindrical with `lambda`
+    a = CoordSys3D('a', lambda r, theta, z:
+        (r*cos(theta), r*sin(theta), z),
+        variable_names=["r", "theta", "z"]
+    )
+    r, theta, z = a.base_scalars()
+    assert a.transformation_to_parent() == (r*cos(theta), r*sin(theta), z)
+    assert a.lame_coefficients() == (
+        sqrt(sin(theta)**2 + cos(theta)**2),
+        sqrt(r**2*sin(theta)**2 + r**2*cos(theta)**2),
+        1
+    )  # ==> this should simplify to (1, a.x, 1)
+
+    raises(TypeError, lambda: CoordSys3D('a', transformation={
+        x: x*sin(y)*cos(z), y:x*sin(y)*sin(z), z:  x*cos(y)}))
+
+
+def test_check_orthogonality():
+    x, y, z = symbols('x y z')
+    u,v = symbols('u, v')
+    a = CoordSys3D('a', transformation=((x, y, z), (x*sin(y)*cos(z), x*sin(y)*sin(z), x*cos(y))))
+    assert a._check_orthogonality(a._transformation) is True
+    a = CoordSys3D('a', transformation=((x, y, z), (x * cos(y), x * sin(y), z)))
+    assert a._check_orthogonality(a._transformation) is True
+    a = CoordSys3D('a', transformation=((u, v, z), (cosh(u) * cos(v), sinh(u) * sin(v), z)))
+    assert a._check_orthogonality(a._transformation) is True
+
+    raises(ValueError, lambda: CoordSys3D('a', transformation=((x, y, z), (x, x, z))))
+    raises(ValueError, lambda: CoordSys3D('a', transformation=(
+        (x, y, z), (x*sin(y/2)*cos(z), x*sin(y)*sin(z), x*cos(y)))))
+
+
+def test_coordsys3d():
+    with warns_deprecated_sympy():
+        assert CoordSysCartesian("C") == CoordSys3D("C")
+
+
+def test_rotation_trans_equations():
+    a = CoordSys3D('a')
+    from sympy import symbols
+    q0 = symbols('q0')
+    assert a._rotation_trans_equations(a._parent_rotation_matrix, a.base_scalars()) == (a.x, a.y, a.z)
+    assert a._rotation_trans_equations(a._inverse_rotation_matrix(), a.base_scalars()) == (a.x, a.y, a.z)
+    b = a.orient_new_axis('b', 0, -a.k)
+    assert b._rotation_trans_equations(b._parent_rotation_matrix, b.base_scalars()) == (b.x, b.y, b.z)
+    assert b._rotation_trans_equations(b._inverse_rotation_matrix(), b.base_scalars()) == (b.x, b.y, b.z)
+    c = a.orient_new_axis('c', q0, -a.k)
+    assert c._rotation_trans_equations(c._parent_rotation_matrix, c.base_scalars()) == \
+           (-sin(q0) * c.y + cos(q0) * c.x, sin(q0) * c.x + cos(q0) * c.y, c.z)
+    assert c._rotation_trans_equations(c._inverse_rotation_matrix(), c.base_scalars()) == \
+           (sin(q0) * c.y + cos(q0) * c.x, -sin(q0) * c.x + cos(q0) * c.y, c.z)
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_dyadic.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_dyadic.py
new file mode 100644
index 0000000000..f301a770a8
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_dyadic.py
@@ -0,0 +1,117 @@
+from sympy import sin, cos, symbols, pi, ImmutableMatrix as Matrix, \
+     simplify
+from sympy.vector import (CoordSys3D, Vector, Dyadic,
+                          DyadicAdd, DyadicMul, DyadicZero,
+                          BaseDyadic, express)
+
+
+A = CoordSys3D('A')
+
+
+def test_dyadic():
+    a, b = symbols('a, b')
+    assert Dyadic.zero != 0
+    assert isinstance(Dyadic.zero, DyadicZero)
+    assert BaseDyadic(A.i, A.j) != BaseDyadic(A.j, A.i)
+    assert (BaseDyadic(Vector.zero, A.i) ==
+            BaseDyadic(A.i, Vector.zero) == Dyadic.zero)
+
+    d1 = A.i | A.i
+    d2 = A.j | A.j
+    d3 = A.i | A.j
+
+    assert isinstance(d1, BaseDyadic)
+    d_mul = a*d1
+    assert isinstance(d_mul, DyadicMul)
+    assert d_mul.base_dyadic == d1
+    assert d_mul.measure_number == a
+    assert isinstance(a*d1 + b*d3, DyadicAdd)
+    assert d1 == A.i.outer(A.i)
+    assert d3 == A.i.outer(A.j)
+    v1 = a*A.i - A.k
+    v2 = A.i + b*A.j
+    assert v1 | v2 == v1.outer(v2) == a * (A.i|A.i) + (a*b) * (A.i|A.j) +\
+           - (A.k|A.i) - b * (A.k|A.j)
+    assert d1 * 0 == Dyadic.zero
+    assert d1 != Dyadic.zero
+    assert d1 * 2 == 2 * (A.i | A.i)
+    assert d1 / 2. == 0.5 * d1
+
+    assert d1.dot(0 * d1) == Vector.zero
+    assert d1 & d2 == Dyadic.zero
+    assert d1.dot(A.i) == A.i == d1 & A.i
+
+    assert d1.cross(Vector.zero) == Dyadic.zero
+    assert d1.cross(A.i) == Dyadic.zero
+    assert d1 ^ A.j == d1.cross(A.j)
+    assert d1.cross(A.k) == - A.i | A.j
+    assert d2.cross(A.i) == - A.j | A.k == d2 ^ A.i
+
+    assert A.i ^ d1 == Dyadic.zero
+    assert A.j.cross(d1) == - A.k | A.i == A.j ^ d1
+    assert Vector.zero.cross(d1) == Dyadic.zero
+    assert A.k ^ d1 == A.j | A.i
+    assert A.i.dot(d1) == A.i & d1 == A.i
+    assert A.j.dot(d1) == Vector.zero
+    assert Vector.zero.dot(d1) == Vector.zero
+    assert A.j & d2 == A.j
+
+    assert d1.dot(d3) == d1 & d3 == A.i | A.j == d3
+    assert d3 & d1 == Dyadic.zero
+
+    q = symbols('q')
+    B = A.orient_new_axis('B', q, A.k)
+    assert express(d1, B) == express(d1, B, B)
+
+    expr1 = ((cos(q)**2) * (B.i | B.i) + (-sin(q) * cos(q)) *
+            (B.i | B.j) + (-sin(q) * cos(q)) * (B.j | B.i) + (sin(q)**2) *
+            (B.j | B.j))
+    assert (express(d1, B) - expr1).simplify() == Dyadic.zero
+
+    expr2 = (cos(q)) * (B.i | A.i) + (-sin(q)) * (B.j | A.i)
+    assert (express(d1, B, A) - expr2).simplify() == Dyadic.zero
+
+    expr3 = (cos(q)) * (A.i | B.i) + (-sin(q)) * (A.i | B.j)
+    assert (express(d1, A, B) - expr3).simplify() == Dyadic.zero
+
+    assert d1.to_matrix(A) == Matrix([[1, 0, 0], [0, 0, 0], [0, 0, 0]])
+    assert d1.to_matrix(A, B) == Matrix([[cos(q), -sin(q), 0],
+                                         [0, 0, 0],
+                                         [0, 0, 0]])
+    assert d3.to_matrix(A) == Matrix([[0, 1, 0], [0, 0, 0], [0, 0, 0]])
+    a, b, c, d, e, f = symbols('a, b, c, d, e, f')
+    v1 = a * A.i + b * A.j + c * A.k
+    v2 = d * A.i + e * A.j + f * A.k
+    d4 = v1.outer(v2)
+    assert d4.to_matrix(A) == Matrix([[a * d, a * e, a * f],
+                                      [b * d, b * e, b * f],
+                                      [c * d, c * e, c * f]])
+    d5 = v1.outer(v1)
+    C = A.orient_new_axis('C', q, A.i)
+    for expected, actual in zip(C.rotation_matrix(A) * d5.to_matrix(A) * \
+                               C.rotation_matrix(A).T, d5.to_matrix(C)):
+        assert (expected - actual).simplify() == 0
+
+
+def test_dyadic_simplify():
+    x, y, z, k, n, m, w, f, s, A = symbols('x, y, z, k, n, m, w, f, s, A')
+    N = CoordSys3D('N')
+
+    dy = N.i | N.i
+    test1 = (1 / x + 1 / y) * dy
+    assert (N.i & test1 & N.i) != (x + y) / (x * y)
+    test1 = test1.simplify()
+    assert test1.simplify() == simplify(test1)
+    assert (N.i & test1 & N.i) == (x + y) / (x * y)
+
+    test2 = (A**2 * s**4 / (4 * pi * k * m**3)) * dy
+    test2 = test2.simplify()
+    assert (N.i & test2 & N.i) == (A**2 * s**4 / (4 * pi * k * m**3))
+
+    test3 = ((4 + 4 * x - 2 * (2 + 2 * x)) / (2 + 2 * x)) * dy
+    test3 = test3.simplify()
+    assert (N.i & test3 & N.i) == 0
+
+    test4 = ((-4 * x * y**2 - 2 * y**3 - 2 * x**2 * y) / (x + y)**2) * dy
+    test4 = test4.simplify()
+    assert (N.i & test4 & N.i) == -2 * y
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_field_functions.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_field_functions.py
new file mode 100644
index 0000000000..3f50e790bd
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_field_functions.py
@@ -0,0 +1,322 @@
+from sympy.core.function import Derivative
+from sympy.vector.vector import Vector
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.simplify import simplify
+from sympy.core.symbol import symbols
+from sympy.core import S
+from sympy import sin, cos
+from sympy.vector.vector import Dot
+from sympy.vector.operators import curl, divergence, gradient, Gradient, Divergence, Cross
+from sympy.vector.deloperator import Del
+from sympy.vector.functions import (is_conservative, is_solenoidal,
+                                    scalar_potential, directional_derivative,
+                                    laplacian, scalar_potential_difference)
+from sympy.testing.pytest import raises
+
+C = CoordSys3D('C')
+i, j, k = C.base_vectors()
+x, y, z = C.base_scalars()
+delop = Del()
+a, b, c, q = symbols('a b c q')
+
+
+def test_del_operator():
+    # Tests for curl
+
+    assert delop ^ Vector.zero == Vector.zero
+    assert ((delop ^ Vector.zero).doit() == Vector.zero ==
+            curl(Vector.zero))
+    assert delop.cross(Vector.zero) == delop ^ Vector.zero
+    assert (delop ^ i).doit() == Vector.zero
+    assert delop.cross(2*y**2*j, doit=True) == Vector.zero
+    assert delop.cross(2*y**2*j) == delop ^ 2*y**2*j
+    v = x*y*z * (i + j + k)
+    assert ((delop ^ v).doit() ==
+            (-x*y + x*z)*i + (x*y - y*z)*j + (-x*z + y*z)*k ==
+            curl(v))
+    assert delop ^ v == delop.cross(v)
+    assert (delop.cross(2*x**2*j) ==
+            (Derivative(0, C.y) - Derivative(2*C.x**2, C.z))*C.i +
+            (-Derivative(0, C.x) + Derivative(0, C.z))*C.j +
+            (-Derivative(0, C.y) + Derivative(2*C.x**2, C.x))*C.k)
+    assert (delop.cross(2*x**2*j, doit=True) == 4*x*k ==
+            curl(2*x**2*j))
+
+    #Tests for divergence
+    assert delop & Vector.zero is S.Zero == divergence(Vector.zero)
+    assert (delop & Vector.zero).doit() is S.Zero
+    assert delop.dot(Vector.zero) == delop & Vector.zero
+    assert (delop & i).doit() is S.Zero
+    assert (delop & x**2*i).doit() == 2*x == divergence(x**2*i)
+    assert (delop.dot(v, doit=True) == x*y + y*z + z*x ==
+            divergence(v))
+    assert delop & v == delop.dot(v)
+    assert delop.dot(1/(x*y*z) * (i + j + k), doit=True) == \
+           - 1 / (x*y*z**2) - 1 / (x*y**2*z) - 1 / (x**2*y*z)
+    v = x*i + y*j + z*k
+    assert (delop & v == Derivative(C.x, C.x) +
+            Derivative(C.y, C.y) + Derivative(C.z, C.z))
+    assert delop.dot(v, doit=True) == 3 == divergence(v)
+    assert delop & v == delop.dot(v)
+    assert simplify((delop & v).doit()) == 3
+
+    #Tests for gradient
+    assert (delop.gradient(0, doit=True) == Vector.zero ==
+            gradient(0))
+    assert delop.gradient(0) == delop(0)
+    assert (delop(S.Zero)).doit() == Vector.zero
+    assert (delop(x) == (Derivative(C.x, C.x))*C.i +
+            (Derivative(C.x, C.y))*C.j + (Derivative(C.x, C.z))*C.k)
+    assert (delop(x)).doit() == i == gradient(x)
+    assert (delop(x*y*z) ==
+            (Derivative(C.x*C.y*C.z, C.x))*C.i +
+            (Derivative(C.x*C.y*C.z, C.y))*C.j +
+            (Derivative(C.x*C.y*C.z, C.z))*C.k)
+    assert (delop.gradient(x*y*z, doit=True) ==
+            y*z*i + z*x*j + x*y*k ==
+            gradient(x*y*z))
+    assert delop(x*y*z) == delop.gradient(x*y*z)
+    assert (delop(2*x**2)).doit() == 4*x*i
+    assert ((delop(a*sin(y) / x)).doit() ==
+            -a*sin(y)/x**2 * i + a*cos(y)/x * j)
+
+    #Tests for directional derivative
+    assert (Vector.zero & delop)(a) is S.Zero
+    assert ((Vector.zero & delop)(a)).doit() is S.Zero
+    assert ((v & delop)(Vector.zero)).doit() == Vector.zero
+    assert ((v & delop)(S.Zero)).doit() is S.Zero
+    assert ((i & delop)(x)).doit() == 1
+    assert ((j & delop)(y)).doit() == 1
+    assert ((k & delop)(z)).doit() == 1
+    assert ((i & delop)(x*y*z)).doit() == y*z
+    assert ((v & delop)(x)).doit() == x
+    assert ((v & delop)(x*y*z)).doit() == 3*x*y*z
+    assert (v & delop)(x + y + z) == C.x + C.y + C.z
+    assert ((v & delop)(x + y + z)).doit() == x + y + z
+    assert ((v & delop)(v)).doit() == v
+    assert ((i & delop)(v)).doit() == i
+    assert ((j & delop)(v)).doit() == j
+    assert ((k & delop)(v)).doit() == k
+    assert ((v & delop)(Vector.zero)).doit() == Vector.zero
+
+    # Tests for laplacian on scalar fields
+    assert laplacian(x*y*z) is S.Zero
+    assert laplacian(x**2) == S(2)
+    assert laplacian(x**2*y**2*z**2) == \
+                    2*y**2*z**2 + 2*x**2*z**2 + 2*x**2*y**2
+    A = CoordSys3D('A', transformation="spherical", variable_names=["r", "theta", "phi"])
+    B = CoordSys3D('B', transformation='cylindrical', variable_names=["r", "theta", "z"])
+    assert laplacian(A.r + A.theta + A.phi) == 2/A.r + cos(A.theta)/(A.r**2*sin(A.theta))
+    assert laplacian(B.r + B.theta + B.z) == 1/B.r
+
+    # Tests for laplacian on vector fields
+    assert laplacian(x*y*z*(i + j + k)) == Vector.zero
+    assert laplacian(x*y**2*z*(i + j + k)) == \
+                            2*x*z*i + 2*x*z*j + 2*x*z*k
+
+
+
+def test_product_rules():
+    """
+    Tests the six product rules defined with respect to the Del
+    operator
+
+    References
+    ==========
+
+    .. [1] https://en.wikipedia.org/wiki/Del
+
+    """
+
+    #Define the scalar and vector functions
+    f = 2*x*y*z
+    g = x*y + y*z + z*x
+    u = x**2*i + 4*j - y**2*z*k
+    v = 4*i + x*y*z*k
+
+    # First product rule
+    lhs = delop(f * g, doit=True)
+    rhs = (f * delop(g) + g * delop(f)).doit()
+    assert simplify(lhs) == simplify(rhs)
+
+    # Second product rule
+    lhs = delop(u & v).doit()
+    rhs = ((u ^ (delop ^ v)) + (v ^ (delop ^ u)) + \
+          ((u & delop)(v)) + ((v & delop)(u))).doit()
+    assert simplify(lhs) == simplify(rhs)
+
+    # Third product rule
+    lhs = (delop & (f*v)).doit()
+    rhs = ((f * (delop & v)) + (v & (delop(f)))).doit()
+    assert simplify(lhs) == simplify(rhs)
+
+    # Fourth product rule
+    lhs = (delop & (u ^ v)).doit()
+    rhs = ((v & (delop ^ u)) - (u & (delop ^ v))).doit()
+    assert simplify(lhs) == simplify(rhs)
+
+    # Fifth product rule
+    lhs = (delop ^ (f * v)).doit()
+    rhs = (((delop(f)) ^ v) + (f * (delop ^ v))).doit()
+    assert simplify(lhs) == simplify(rhs)
+
+    # Sixth product rule
+    lhs = (delop ^ (u ^ v)).doit()
+    rhs = (u * (delop & v) - v * (delop & u) +
+           (v & delop)(u) - (u & delop)(v)).doit()
+    assert simplify(lhs) == simplify(rhs)
+
+
+P = C.orient_new_axis('P', q, C.k)  # type: ignore
+scalar_field = 2*x**2*y*z
+grad_field = gradient(scalar_field)
+vector_field = y**2*i + 3*x*j + 5*y*z*k
+curl_field = curl(vector_field)
+
+
+def test_conservative():
+    assert is_conservative(Vector.zero) is True
+    assert is_conservative(i) is True
+    assert is_conservative(2 * i + 3 * j + 4 * k) is True
+    assert (is_conservative(y*z*i + x*z*j + x*y*k) is
+            True)
+    assert is_conservative(x * j) is False
+    assert is_conservative(grad_field) is True
+    assert is_conservative(curl_field) is False
+    assert (is_conservative(4*x*y*z*i + 2*x**2*z*j) is
+            False)
+    assert is_conservative(z*P.i + P.x*k) is True
+
+
+def test_solenoidal():
+    assert is_solenoidal(Vector.zero) is True
+    assert is_solenoidal(i) is True
+    assert is_solenoidal(2 * i + 3 * j + 4 * k) is True
+    assert (is_solenoidal(y*z*i + x*z*j + x*y*k) is
+            True)
+    assert is_solenoidal(y * j) is False
+    assert is_solenoidal(grad_field) is False
+    assert is_solenoidal(curl_field) is True
+    assert is_solenoidal((-2*y + 3)*k) is True
+    assert is_solenoidal(cos(q)*i + sin(q)*j + cos(q)*P.k) is True
+    assert is_solenoidal(z*P.i + P.x*k) is True
+
+
+def test_directional_derivative():
+    assert directional_derivative(C.x*C.y*C.z, 3*C.i + 4*C.j + C.k) == C.x*C.y + 4*C.x*C.z + 3*C.y*C.z
+    assert directional_derivative(5*C.x**2*C.z, 3*C.i + 4*C.j + C.k) == 5*C.x**2 + 30*C.x*C.z
+    assert directional_derivative(5*C.x**2*C.z, 4*C.j) is S.Zero
+
+    D = CoordSys3D("D", "spherical", variable_names=["r", "theta", "phi"],
+                   vector_names=["e_r", "e_theta", "e_phi"])
+    r, theta, phi = D.base_scalars()
+    e_r, e_theta, e_phi = D.base_vectors()
+    assert directional_derivative(r**2*e_r, e_r) == 2*r*e_r
+    assert directional_derivative(5*r**2*phi, 3*e_r + 4*e_theta + e_phi) == 5*r**2 + 30*r*phi
+
+
+def test_scalar_potential():
+    assert scalar_potential(Vector.zero, C) == 0
+    assert scalar_potential(i, C) == x
+    assert scalar_potential(j, C) == y
+    assert scalar_potential(k, C) == z
+    assert scalar_potential(y*z*i + x*z*j + x*y*k, C) == x*y*z
+    assert scalar_potential(grad_field, C) == scalar_field
+    assert scalar_potential(z*P.i + P.x*k, C) == x*z*cos(q) + y*z*sin(q)
+    assert scalar_potential(z*P.i + P.x*k, P) == P.x*P.z
+    raises(ValueError, lambda: scalar_potential(x*j, C))
+
+
+def test_scalar_potential_difference():
+    point1 = C.origin.locate_new('P1', 1*i + 2*j + 3*k)
+    point2 = C.origin.locate_new('P2', 4*i + 5*j + 6*k)
+    genericpointC = C.origin.locate_new('RP', x*i + y*j + z*k)
+    genericpointP = P.origin.locate_new('PP', P.x*P.i + P.y*P.j + P.z*P.k)
+    assert scalar_potential_difference(S.Zero, C, point1, point2) == 0
+    assert (scalar_potential_difference(scalar_field, C, C.origin,
+                                        genericpointC) ==
+            scalar_field)
+    assert (scalar_potential_difference(grad_field, C, C.origin,
+                                        genericpointC) ==
+            scalar_field)
+    assert scalar_potential_difference(grad_field, C, point1, point2) == 948
+    assert (scalar_potential_difference(y*z*i + x*z*j +
+                                        x*y*k, C, point1,
+                                        genericpointC) ==
+            x*y*z - 6)
+    potential_diff_P = (2*P.z*(P.x*sin(q) + P.y*cos(q))*
+                        (P.x*cos(q) - P.y*sin(q))**2)
+    assert (scalar_potential_difference(grad_field, P, P.origin,
+                                        genericpointP).simplify() ==
+            potential_diff_P.simplify())
+
+
+def test_differential_operators_curvilinear_system():
+    A = CoordSys3D('A', transformation="spherical", variable_names=["r", "theta", "phi"])
+    B = CoordSys3D('B', transformation='cylindrical', variable_names=["r", "theta", "z"])
+    # Test for spherical coordinate system and gradient
+    assert gradient(3*A.r + 4*A.theta) == 3*A.i + 4/A.r*A.j
+    assert gradient(3*A.r*A.phi + 4*A.theta) == 3*A.phi*A.i + 4/A.r*A.j + (3/sin(A.theta))*A.k
+    assert gradient(0*A.r + 0*A.theta+0*A.phi) == Vector.zero
+    assert gradient(A.r*A.theta*A.phi) == A.theta*A.phi*A.i + A.phi*A.j + (A.theta/sin(A.theta))*A.k
+    # Test for spherical coordinate system and divergence
+    assert divergence(A.r * A.i + A.theta * A.j + A.phi * A.k) == \
+           (sin(A.theta)*A.r + cos(A.theta)*A.r*A.theta)/(sin(A.theta)*A.r**2) + 3 + 1/(sin(A.theta)*A.r)
+    assert divergence(3*A.r*A.phi*A.i + A.theta*A.j + A.r*A.theta*A.phi*A.k) == \
+           (sin(A.theta)*A.r + cos(A.theta)*A.r*A.theta)/(sin(A.theta)*A.r**2) + 9*A.phi + A.theta/sin(A.theta)
+    assert divergence(Vector.zero) == 0
+    assert divergence(0*A.i + 0*A.j + 0*A.k) == 0
+    # Test for spherical coordinate system and curl
+    assert curl(A.r*A.i + A.theta*A.j + A.phi*A.k) == \
+           (cos(A.theta)*A.phi/(sin(A.theta)*A.r))*A.i + (-A.phi/A.r)*A.j + A.theta/A.r*A.k
+    assert curl(A.r*A.j + A.phi*A.k) == (cos(A.theta)*A.phi/(sin(A.theta)*A.r))*A.i + (-A.phi/A.r)*A.j + 2*A.k
+
+    # Test for cylindrical coordinate system and gradient
+    assert gradient(0*B.r + 0*B.theta+0*B.z) == Vector.zero
+    assert gradient(B.r*B.theta*B.z) == B.theta*B.z*B.i + B.z*B.j + B.r*B.theta*B.k
+    assert gradient(3*B.r) == 3*B.i
+    assert gradient(2*B.theta) == 2/B.r * B.j
+    assert gradient(4*B.z) == 4*B.k
+    # Test for cylindrical coordinate system and divergence
+    assert divergence(B.r*B.i + B.theta*B.j + B.z*B.k) == 3 + 1/B.r
+    assert divergence(B.r*B.j + B.z*B.k) == 1
+    # Test for cylindrical coordinate system and curl
+    assert curl(B.r*B.j + B.z*B.k) == 2*B.k
+    assert curl(3*B.i + 2/B.r*B.j + 4*B.k) == Vector.zero
+
+def test_mixed_coordinates():
+    # gradient
+    a = CoordSys3D('a')
+    b = CoordSys3D('b')
+    c = CoordSys3D('c')
+    assert gradient(a.x*b.y) == b.y*a.i + a.x*b.j
+    assert gradient(3*cos(q)*a.x*b.x+a.y*(a.x+(cos(q)+b.x))) ==\
+           (a.y + 3*b.x*cos(q))*a.i + (a.x + b.x + cos(q))*a.j + (3*a.x*cos(q) + a.y)*b.i
+    # Some tests need further work:
+    # assert gradient(a.x*(cos(a.x+b.x))) == (cos(a.x + b.x))*a.i + a.x*Gradient(cos(a.x + b.x))
+    # assert gradient(cos(a.x + b.x)*cos(a.x + b.z)) == Gradient(cos(a.x + b.x)*cos(a.x + b.z))
+    assert gradient(a.x**b.y) == Gradient(a.x**b.y)
+    # assert gradient(cos(a.x+b.y)*a.z) == None
+    assert gradient(cos(a.x*b.y)) == Gradient(cos(a.x*b.y))
+    assert gradient(3*cos(q)*a.x*b.x*a.z*a.y+ b.y*b.z + cos(a.x+a.y)*b.z) == \
+           (3*a.y*a.z*b.x*cos(q) - b.z*sin(a.x + a.y))*a.i + \
+           (3*a.x*a.z*b.x*cos(q) - b.z*sin(a.x + a.y))*a.j + (3*a.x*a.y*b.x*cos(q))*a.k + \
+           (3*a.x*a.y*a.z*cos(q))*b.i + b.z*b.j + (b.y + cos(a.x + a.y))*b.k
+    # divergence
+    assert divergence(a.i*a.x+a.j*a.y+a.z*a.k + b.i*b.x+b.j*b.y+b.z*b.k + c.i*c.x+c.j*c.y+c.z*c.k) == S(9)
+    # assert divergence(3*a.i*a.x*cos(a.x+b.z) + a.j*b.x*c.z) == None
+    assert divergence(3*a.i*a.x*a.z + b.j*b.x*c.z + 3*a.j*a.z*a.y) == \
+            6*a.z + b.x*Dot(b.j, c.k)
+    assert divergence(3*cos(q)*a.x*b.x*b.i*c.x) == \
+        3*a.x*b.x*cos(q)*Dot(b.i, c.i) + 3*a.x*c.x*cos(q) + 3*b.x*c.x*cos(q)*Dot(b.i, a.i)
+    assert divergence(a.x*b.x*c.x*Cross(a.x*a.i, a.y*b.j)) ==\
+           a.x*b.x*c.x*Divergence(Cross(a.x*a.i, a.y*b.j)) + \
+           b.x*c.x*Dot(Cross(a.x*a.i, a.y*b.j), a.i) + \
+           a.x*c.x*Dot(Cross(a.x*a.i, a.y*b.j), b.i) + \
+           a.x*b.x*Dot(Cross(a.x*a.i, a.y*b.j), c.i)
+    assert divergence(a.x*b.x*c.x*(a.x*a.i + b.x*b.i)) == \
+                4*a.x*b.x*c.x +\
+                a.x**2*c.x*Dot(a.i, b.i) +\
+                a.x**2*b.x*Dot(a.i, c.i) +\
+                b.x**2*c.x*Dot(b.i, a.i) +\
+                a.x*b.x**2*Dot(b.i, c.i)
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_functions.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_functions.py
new file mode 100644
index 0000000000..1785b4802d
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_functions.py
@@ -0,0 +1,179 @@
+from sympy.vector.vector import Vector
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.vector.functions import express, matrix_to_vector, orthogonalize
+from sympy import symbols, S, sqrt, sin, cos, ImmutableMatrix as Matrix, Rational
+from sympy.testing.pytest import raises
+
+N = CoordSys3D('N')
+q1, q2, q3, q4, q5 = symbols('q1 q2 q3 q4 q5')
+A = N.orient_new_axis('A', q1, N.k)  # type: ignore
+B = A.orient_new_axis('B', q2, A.i)
+C = B.orient_new_axis('C', q3, B.j)
+
+
+def test_express():
+    assert express(Vector.zero, N) == Vector.zero
+    assert express(S.Zero, N) is S.Zero
+    assert express(A.i, C) == cos(q3)*C.i + sin(q3)*C.k
+    assert express(A.j, C) == sin(q2)*sin(q3)*C.i + cos(q2)*C.j - \
+        sin(q2)*cos(q3)*C.k
+    assert express(A.k, C) == -sin(q3)*cos(q2)*C.i + sin(q2)*C.j + \
+        cos(q2)*cos(q3)*C.k
+    assert express(A.i, N) == cos(q1)*N.i + sin(q1)*N.j
+    assert express(A.j, N) == -sin(q1)*N.i + cos(q1)*N.j
+    assert express(A.k, N) == N.k
+    assert express(A.i, A) == A.i
+    assert express(A.j, A) == A.j
+    assert express(A.k, A) == A.k
+    assert express(A.i, B) == B.i
+    assert express(A.j, B) == cos(q2)*B.j - sin(q2)*B.k
+    assert express(A.k, B) == sin(q2)*B.j + cos(q2)*B.k
+    assert express(A.i, C) == cos(q3)*C.i + sin(q3)*C.k
+    assert express(A.j, C) == sin(q2)*sin(q3)*C.i + cos(q2)*C.j - \
+        sin(q2)*cos(q3)*C.k
+    assert express(A.k, C) == -sin(q3)*cos(q2)*C.i + sin(q2)*C.j + \
+        cos(q2)*cos(q3)*C.k
+    # Check to make sure UnitVectors get converted properly
+    assert express(N.i, N) == N.i
+    assert express(N.j, N) == N.j
+    assert express(N.k, N) == N.k
+    assert express(N.i, A) == (cos(q1)*A.i - sin(q1)*A.j)
+    assert express(N.j, A) == (sin(q1)*A.i + cos(q1)*A.j)
+    assert express(N.k, A) == A.k
+    assert express(N.i, B) == (cos(q1)*B.i - sin(q1)*cos(q2)*B.j +
+            sin(q1)*sin(q2)*B.k)
+    assert express(N.j, B) == (sin(q1)*B.i + cos(q1)*cos(q2)*B.j -
+            sin(q2)*cos(q1)*B.k)
+    assert express(N.k, B) == (sin(q2)*B.j + cos(q2)*B.k)
+    assert express(N.i, C) == (
+        (cos(q1)*cos(q3) - sin(q1)*sin(q2)*sin(q3))*C.i -
+        sin(q1)*cos(q2)*C.j +
+        (sin(q3)*cos(q1) + sin(q1)*sin(q2)*cos(q3))*C.k)
+    assert express(N.j, C) == (
+        (sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1))*C.i +
+        cos(q1)*cos(q2)*C.j +
+        (sin(q1)*sin(q3) - sin(q2)*cos(q1)*cos(q3))*C.k)
+    assert express(N.k, C) == (-sin(q3)*cos(q2)*C.i + sin(q2)*C.j +
+            cos(q2)*cos(q3)*C.k)
+
+    assert express(A.i, N) == (cos(q1)*N.i + sin(q1)*N.j)
+    assert express(A.j, N) == (-sin(q1)*N.i + cos(q1)*N.j)
+    assert express(A.k, N) == N.k
+    assert express(A.i, A) == A.i
+    assert express(A.j, A) == A.j
+    assert express(A.k, A) == A.k
+    assert express(A.i, B) == B.i
+    assert express(A.j, B) == (cos(q2)*B.j - sin(q2)*B.k)
+    assert express(A.k, B) == (sin(q2)*B.j + cos(q2)*B.k)
+    assert express(A.i, C) == (cos(q3)*C.i + sin(q3)*C.k)
+    assert express(A.j, C) == (sin(q2)*sin(q3)*C.i + cos(q2)*C.j -
+            sin(q2)*cos(q3)*C.k)
+    assert express(A.k, C) == (-sin(q3)*cos(q2)*C.i + sin(q2)*C.j +
+            cos(q2)*cos(q3)*C.k)
+
+    assert express(B.i, N) == (cos(q1)*N.i + sin(q1)*N.j)
+    assert express(B.j, N) == (-sin(q1)*cos(q2)*N.i +
+            cos(q1)*cos(q2)*N.j + sin(q2)*N.k)
+    assert express(B.k, N) == (sin(q1)*sin(q2)*N.i -
+            sin(q2)*cos(q1)*N.j + cos(q2)*N.k)
+    assert express(B.i, A) == A.i
+    assert express(B.j, A) == (cos(q2)*A.j + sin(q2)*A.k)
+    assert express(B.k, A) == (-sin(q2)*A.j + cos(q2)*A.k)
+    assert express(B.i, B) == B.i
+    assert express(B.j, B) == B.j
+    assert express(B.k, B) == B.k
+    assert express(B.i, C) == (cos(q3)*C.i + sin(q3)*C.k)
+    assert express(B.j, C) == C.j
+    assert express(B.k, C) == (-sin(q3)*C.i + cos(q3)*C.k)
+
+    assert express(C.i, N) == (
+        (cos(q1)*cos(q3) - sin(q1)*sin(q2)*sin(q3))*N.i +
+        (sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1))*N.j -
+        sin(q3)*cos(q2)*N.k)
+    assert express(C.j, N) == (
+        -sin(q1)*cos(q2)*N.i + cos(q1)*cos(q2)*N.j + sin(q2)*N.k)
+    assert express(C.k, N) == (
+        (sin(q3)*cos(q1) + sin(q1)*sin(q2)*cos(q3))*N.i +
+        (sin(q1)*sin(q3) - sin(q2)*cos(q1)*cos(q3))*N.j +
+        cos(q2)*cos(q3)*N.k)
+    assert express(C.i, A) == (cos(q3)*A.i + sin(q2)*sin(q3)*A.j -
+            sin(q3)*cos(q2)*A.k)
+    assert express(C.j, A) == (cos(q2)*A.j + sin(q2)*A.k)
+    assert express(C.k, A) == (sin(q3)*A.i - sin(q2)*cos(q3)*A.j +
+            cos(q2)*cos(q3)*A.k)
+    assert express(C.i, B) == (cos(q3)*B.i - sin(q3)*B.k)
+    assert express(C.j, B) == B.j
+    assert express(C.k, B) == (sin(q3)*B.i + cos(q3)*B.k)
+    assert express(C.i, C) == C.i
+    assert express(C.j, C) == C.j
+    assert express(C.k, C) == C.k == (C.k)
+
+    #  Check to make sure Vectors get converted back to UnitVectors
+    assert N.i == express((cos(q1)*A.i - sin(q1)*A.j), N).simplify()
+    assert N.j == express((sin(q1)*A.i + cos(q1)*A.j), N).simplify()
+    assert N.i == express((cos(q1)*B.i - sin(q1)*cos(q2)*B.j +
+            sin(q1)*sin(q2)*B.k), N).simplify()
+    assert N.j == express((sin(q1)*B.i + cos(q1)*cos(q2)*B.j -
+        sin(q2)*cos(q1)*B.k), N).simplify()
+    assert N.k == express((sin(q2)*B.j + cos(q2)*B.k), N).simplify()
+
+
+    assert A.i == express((cos(q1)*N.i + sin(q1)*N.j), A).simplify()
+    assert A.j == express((-sin(q1)*N.i + cos(q1)*N.j), A).simplify()
+
+    assert A.j == express((cos(q2)*B.j - sin(q2)*B.k), A).simplify()
+    assert A.k == express((sin(q2)*B.j + cos(q2)*B.k), A).simplify()
+
+    assert A.i == express((cos(q3)*C.i + sin(q3)*C.k), A).simplify()
+    assert A.j == express((sin(q2)*sin(q3)*C.i + cos(q2)*C.j -
+            sin(q2)*cos(q3)*C.k), A).simplify()
+
+    assert A.k == express((-sin(q3)*cos(q2)*C.i + sin(q2)*C.j +
+            cos(q2)*cos(q3)*C.k), A).simplify()
+    assert B.i == express((cos(q1)*N.i + sin(q1)*N.j), B).simplify()
+    assert B.j == express((-sin(q1)*cos(q2)*N.i +
+            cos(q1)*cos(q2)*N.j + sin(q2)*N.k), B).simplify()
+
+    assert B.k == express((sin(q1)*sin(q2)*N.i -
+            sin(q2)*cos(q1)*N.j + cos(q2)*N.k), B).simplify()
+
+    assert B.j == express((cos(q2)*A.j + sin(q2)*A.k), B).simplify()
+    assert B.k == express((-sin(q2)*A.j + cos(q2)*A.k), B).simplify()
+    assert B.i == express((cos(q3)*C.i + sin(q3)*C.k), B).simplify()
+    assert B.k == express((-sin(q3)*C.i + cos(q3)*C.k), B).simplify()
+    assert C.i == express((cos(q3)*A.i + sin(q2)*sin(q3)*A.j -
+            sin(q3)*cos(q2)*A.k), C).simplify()
+    assert C.j == express((cos(q2)*A.j + sin(q2)*A.k), C).simplify()
+    assert C.k == express((sin(q3)*A.i - sin(q2)*cos(q3)*A.j +
+            cos(q2)*cos(q3)*A.k), C).simplify()
+    assert C.i == express((cos(q3)*B.i - sin(q3)*B.k), C).simplify()
+    assert C.k == express((sin(q3)*B.i + cos(q3)*B.k), C).simplify()
+
+
+def test_matrix_to_vector():
+    m = Matrix([[1], [2], [3]])
+    assert matrix_to_vector(m, C) == C.i + 2*C.j + 3*C.k
+    m = Matrix([[0], [0], [0]])
+    assert matrix_to_vector(m, N) == matrix_to_vector(m, C) == \
+           Vector.zero
+    m = Matrix([[q1], [q2], [q3]])
+    assert matrix_to_vector(m, N) == q1*N.i + q2*N.j + q3*N.k
+
+
+def test_orthogonalize():
+    C = CoordSys3D('C')
+    a, b = symbols('a b', integer=True)
+    i, j, k = C.base_vectors()
+    v1 = i + 2*j
+    v2 = 2*i + 3*j
+    v3 = 3*i + 5*j
+    v4 = 3*i + j
+    v5 = 2*i + 2*j
+    v6 = a*i + b*j
+    v7 = 4*a*i + 4*b*j
+    assert orthogonalize(v1, v2) == [C.i + 2*C.j, C.i*Rational(2, 5) + -C.j/5]
+    # from wikipedia
+    assert orthogonalize(v4, v5, orthonormal=True) == \
+        [(3*sqrt(10))*C.i/10 + (sqrt(10))*C.j/10, (-sqrt(10))*C.i/10 + (3*sqrt(10))*C.j/10]
+    raises(ValueError, lambda: orthogonalize(v1, v2, v3))
+    raises(ValueError, lambda: orthogonalize(v6, v7))
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_implicitregion.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_implicitregion.py
new file mode 100644
index 0000000000..862aab11f8
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_implicitregion.py
@@ -0,0 +1,91 @@
+from sympy import Eq, S, sqrt
+from sympy.abc import x, y, z, s, t
+from sympy.sets import FiniteSet, EmptySet
+from sympy.geometry import Point
+from sympy.vector import ImplicitRegion
+from sympy.testing.pytest import raises
+
+
+def test_ImplicitRegion():
+    ellipse = ImplicitRegion((x, y), (x**2/4 + y**2/16 - 1))
+    assert ellipse.equation == x**2/4 + y**2/16 - 1
+    assert ellipse.variables == (x, y)
+    assert ellipse.degree == 2
+    r = ImplicitRegion((x, y, z), Eq(x**4 + y**2 - x*y, 6))
+    assert r.equation == x**4 + y**2 - x*y - 6
+    assert r.variables == (x, y, z)
+    assert r.degree == 4
+
+
+def test_regular_point():
+    r1 = ImplicitRegion((x,), x**2 - 16)
+    r1.regular_point() == (-4,)
+    c1 = ImplicitRegion((x, y), x**2 + y**2 - 4)
+    c1.regular_point() == (2, 0)
+    c2 = ImplicitRegion((x, y), (x - S(5)/2)**2 + y**2 - (S(1)/4)**2)
+    c2.regular_point() == (11/4, 0)
+    c3 = ImplicitRegion((x, y), (y - 5)**2  - 16*(x - 5))
+    c3.regular_point() == (5, 5)
+    r2 = ImplicitRegion((x, y), x**2 - 4*x*y - 3*y**2 + 4*x + 8*y - 5)
+    r2.regular_point == (4/7, 13/21)
+    r3 = ImplicitRegion((x, y), x**2 - 2*x*y + 3*y**2 - 2*x - 5*y + 3/2)
+    raises(ValueError, lambda: r3.regular_point())
+
+
+def test_singular_points_and_multiplicty():
+    r1 = ImplicitRegion((x, y, z), Eq(x + y + z, 0))
+    assert r1.singular_points() == FiniteSet((-y - z, y, z))
+    assert r1.multiplicity((0, 0, 0)) == 1
+    assert r1.multiplicity((-y - z, y, z)) == 1
+    r2 = ImplicitRegion((x, y, z), x*y*z + y**4 -x**2*z**2)
+    assert r2.singular_points() == FiniteSet((0, 0, z), ((-y*sqrt(4*y**2 + 1)/2 + y/2)/z, y, z),\
+                            ((y*sqrt(4*y**2 + 1)/2 + y/2)/z, y, z))
+    assert r2.multiplicity((0, 0, 0)) == 3
+    assert r2.multiplicity((0, 0, 6)) == 2
+    r3 = ImplicitRegion((x, y, z), z**2 - x**2 - y**2)
+    assert r3.singular_points() == FiniteSet((0, 0, 0))
+    assert r3.multiplicity((0, 0, 0)) == 2
+    r4 = ImplicitRegion((x, y), x**2 + y**2 - 2*x)
+    assert r4.singular_points() == EmptySet
+    assert r4.multiplicity(Point(1, 3)) == 0
+
+
+def test_rational_parametrization():
+    p = ImplicitRegion((x,), x - 2)
+    assert p.rational_parametrization() == (x - 2,)
+
+    line = ImplicitRegion((x, y), Eq(y, 3*x + 2))
+    assert line.rational_parametrization() == (x, 3*x + 2)
+
+    circle1 = ImplicitRegion((x, y), (x-2)**2 + (y+3)**2 - 4)
+    assert circle1.rational_parametrization(parameters=t) == (4*t/(t**2 + 1) + 2, 4*t**2/(t**2 + 1) - 5)
+    circle2 = ImplicitRegion((x, y), (x - S.Half)**2 + y**2 - (S(1)/2)**2)
+
+    assert circle2.rational_parametrization(parameters=t) == (t/(t**2 + 1) + S(1)/2, t**2/(t**2 + 1) - S(1)/2)
+    circle3 = ImplicitRegion((x, y), Eq(x**2 + y**2, 2*x))
+    assert circle3.rational_parametrization(parameters=(t,)) == (2*t/(t**2 + 1) + 1, 2*t**2/(t**2 + 1) - 1)
+
+    parabola = ImplicitRegion((x, y), (y - 3)**2 - 4*(x + 6))
+    assert parabola.rational_parametrization(t) == (-6 + 4/t**2, 3 + 4/t)
+
+    rect_hyperbola = ImplicitRegion((x, y), x*y - 1)
+    assert rect_hyperbola.rational_parametrization(t) == (-1 + (t + 1)/t, t)
+
+    cubic_curve = ImplicitRegion((x, y), x**3 + x**2 - y**2)
+    assert cubic_curve.rational_parametrization(parameters=(t)) == (t**2 - 1, t*(t**2 - 1))
+    cuspidal = ImplicitRegion((x, y), (x**3 - y**2))
+    assert cuspidal.rational_parametrization(t) == (t**2, t**3)
+
+    I = ImplicitRegion((x, y), x**3 + x**2 - y**2)
+    assert I.rational_parametrization(t) == (t**2 - 1, t*(t**2 - 1))
+
+    sphere = ImplicitRegion((x, y, z), Eq(x**2 + y**2 + z**2, 2*x))
+    assert sphere.rational_parametrization(parameters=(s, t)) == (2/(s**2 + t**2 + 1), 2*t/(s**2 + t**2 + 1), 2*s/(s**2 + t**2 + 1))
+
+    conic = ImplicitRegion((x, y), Eq(x**2 + 4*x*y + 3*y**2 + x - y + 10, 0))
+    conic.rational_parametrization(t) == (17/2 + 4/(3*t**2 + 4*t + 1), 4*t/(3*t**2 + 4*t + 1) - 11/2)
+
+    r1 = ImplicitRegion((x, y), y**2 - x**3 + x)
+    raises(NotImplementedError, lambda: r1.rational_parametrization())
+    r2 = ImplicitRegion((x, y), y**2 - x**3 - x**2 + 1)
+    raises(NotImplementedError, lambda: r2.rational_parametrization())
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_integrals.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_integrals.py
new file mode 100644
index 0000000000..e5271a2111
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_integrals.py
@@ -0,0 +1,103 @@
+from sympy import sin, cos, pi, S, sqrt
+from sympy.testing.pytest import raises
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.vector.integrals import ParametricIntegral, vector_integrate
+from sympy.vector.parametricregion import ParametricRegion
+from sympy.vector.implicitregion import ImplicitRegion
+from sympy.abc import x, y, z, u, v, r, t, theta, phi
+from sympy.geometry import Point, Segment, Curve, Circle, Polygon, Plane
+
+C = CoordSys3D('C')
+
+def test_parametric_lineintegrals():
+    halfcircle = ParametricRegion((4*cos(theta), 4*sin(theta)), (theta, -pi/2, pi/2))
+    assert ParametricIntegral(C.x*C.y**4, halfcircle) == S(8192)/5
+
+    curve = ParametricRegion((t, t**2, t**3), (t, 0, 1))
+    field1 = 8*C.x**2*C.y*C.z*C.i + 5*C.z*C.j - 4*C.x*C.y*C.k
+    assert ParametricIntegral(field1, curve) == 1
+    line = ParametricRegion((4*t - 1, 2 - 2*t, t), (t, 0, 1))
+    assert ParametricIntegral(C.x*C.z*C.i - C.y*C.z*C.k, line) == 3
+
+    assert ParametricIntegral(4*C.x**3, ParametricRegion((1, t), (t, 0, 2))) == 8
+
+    helix = ParametricRegion((cos(t), sin(t), 3*t), (t, 0, 4*pi))
+    assert ParametricIntegral(C.x*C.y*C.z, helix) == -3*sqrt(10)*pi
+
+    field2 = C.y*C.i + C.z*C.j + C.z*C.k
+    assert ParametricIntegral(field2, ParametricRegion((cos(t), sin(t), t**2), (t, 0, pi))) == -5*pi/2 + pi**4/2
+
+def test_parametric_surfaceintegrals():
+
+    semisphere = ParametricRegion((2*sin(phi)*cos(theta), 2*sin(phi)*sin(theta), 2*cos(phi)),\
+                            (theta, 0, 2*pi), (phi, 0, pi/2))
+    assert ParametricIntegral(C.z, semisphere) == 8*pi
+
+    cylinder = ParametricRegion((sqrt(3)*cos(theta), sqrt(3)*sin(theta), z), (z, 0, 6), (theta, 0, 2*pi))
+    assert ParametricIntegral(C.y, cylinder) == 0
+
+    cone = ParametricRegion((v*cos(u), v*sin(u), v), (u, 0, 2*pi), (v, 0, 1))
+    assert ParametricIntegral(C.x*C.i + C.y*C.j + C.z**4*C.k, cone) == pi/3
+
+    triangle1 = ParametricRegion((x, y), (x, 0, 2), (y, 0, 10 - 5*x))
+    triangle2 = ParametricRegion((x, y), (y, 0, 10 - 5*x), (x, 0, 2))
+    assert ParametricIntegral(-15.6*C.y*C.k, triangle1) == ParametricIntegral(-15.6*C.y*C.k, triangle2)
+    assert ParametricIntegral(C.z, triangle1) == 10*C.z
+
+def test_parametric_volumeintegrals():
+
+    cube = ParametricRegion((x, y, z), (x, 0, 1), (y, 0, 1), (z, 0, 1))
+    assert ParametricIntegral(1, cube) == 1
+
+    solidsphere1 = ParametricRegion((r*sin(phi)*cos(theta), r*sin(phi)*sin(theta), r*cos(phi)),\
+                            (r, 0, 2), (theta, 0, 2*pi), (phi, 0, pi))
+    solidsphere2 = ParametricRegion((r*sin(phi)*cos(theta), r*sin(phi)*sin(theta), r*cos(phi)),\
+                            (r, 0, 2), (phi, 0, pi), (theta, 0, 2*pi))
+    assert ParametricIntegral(C.x**2 + C.y**2, solidsphere1) == -256*pi/15
+    assert ParametricIntegral(C.x**2 + C.y**2, solidsphere2) == 256*pi/15
+
+    region_under_plane1 = ParametricRegion((x, y, z), (x, 0, 3), (y, 0, -2*x/3 + 2),\
+                                    (z, 0, 6 - 2*x - 3*y))
+    region_under_plane2 = ParametricRegion((x, y, z), (x, 0, 3), (z, 0, 6 - 2*x - 3*y),\
+                                    (y, 0, -2*x/3 + 2))
+
+    assert ParametricIntegral(C.x*C.i + C.j - 100*C.k, region_under_plane1) == \
+        ParametricIntegral(C.x*C.i + C.j - 100*C.k, region_under_plane2)
+    assert ParametricIntegral(2*C.x, region_under_plane2) == -9
+
+def test_vector_integrate():
+    halfdisc = ParametricRegion((r*cos(theta), r* sin(theta)), (r, -2, 2), (theta, 0, pi))
+    assert vector_integrate(C.x**2, halfdisc) == 4*pi
+    vector_integrate(C.x, ParametricRegion((t, t**2), (t, 2, 3))) == -17*sqrt(17)/12 + 37*sqrt(37)/12
+
+    assert  vector_integrate(C.y**3*C.z, (C.x, 0, 3), (C.y, -1, 4)) == 765*C.z/4
+
+    s1 = Segment(Point(0, 0), Point(0, 1))
+    assert vector_integrate(-15*C.y, s1) == S(-15)/2
+    s2 = Segment(Point(4, 3, 9), Point(1, 1, 7))
+    assert vector_integrate(C.y*C.i, s2) == -6
+
+    curve = Curve((sin(t), cos(t)), (t, 0, 2))
+    assert vector_integrate(5*C.z, curve) == 10*C.z
+
+    c1 = Circle(Point(2, 3), 6)
+    assert vector_integrate(C.x*C.y, c1) == 72*pi
+    c2 = Circle(Point(0, 0), Point(1, 1), Point(1, 0))
+    assert vector_integrate(1, c2) == c2.circumference
+
+    triangle = Polygon((0, 0), (1, 0), (1, 1))
+    assert vector_integrate(C.x*C.i - 14*C.y*C.j, triangle) == 0
+    p1, p2, p3, p4 = [(0, 0), (1, 0), (5, 1), (0, 1)]
+    poly = Polygon(p1, p2, p3, p4)
+    assert vector_integrate(-23*C.z, poly) == -161*C.z - 23*sqrt(17)*C.z
+
+    point = Point(2, 3)
+    assert vector_integrate(C.i*C.y - C.z, point) == ParametricIntegral(C.y*C.i, ParametricRegion((2, 3)))
+
+    c3 = ImplicitRegion((x, y), x**2 + y**2 - 4)
+    assert vector_integrate(45, c3) == 360*pi
+    c4 = ImplicitRegion((x, y), (x - 3)**2 + (y - 4)**2 - 9)
+    assert vector_integrate(1, c4) == 12*pi
+
+    pl = Plane(Point(1, 1, 1), Point(2, 3, 4), Point(2, 2, 2))
+    raises(ValueError, lambda: vector_integrate(C.x*C.z*C.i + C.k, pl))
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_operators.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_operators.py
new file mode 100644
index 0000000000..2f3eccf65e
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_operators.py
@@ -0,0 +1,40 @@
+from sympy.vector import CoordSys3D, Gradient, Divergence, Curl, VectorZero, Laplacian
+from sympy.printing.repr import srepr
+
+R = CoordSys3D('R')
+s1 = R.x*R.y*R.z  # type: ignore
+s2 = R.x + 3*R.y**2  # type: ignore
+s3 = R.x**2 + R.y**2 + R.z**2  # type: ignore
+v1 = R.x*R.i + R.z*R.z*R.j  # type: ignore
+v2 = R.x*R.i + R.y*R.j + R.z*R.k  # type: ignore
+v3 = R.x**2*R.i + R.y**2*R.j + R.z**2*R.k  # type: ignore
+
+
+def test_Gradient():
+    assert Gradient(s1) == Gradient(R.x*R.y*R.z)
+    assert Gradient(s2) == Gradient(R.x + 3*R.y**2)
+    assert Gradient(s1).doit() == R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k
+    assert Gradient(s2).doit() == R.i + 6*R.y*R.j
+
+
+def test_Divergence():
+    assert Divergence(v1) == Divergence(R.x*R.i + R.z*R.z*R.j)
+    assert Divergence(v2) == Divergence(R.x*R.i + R.y*R.j + R.z*R.k)
+    assert Divergence(v1).doit() == 1
+    assert Divergence(v2).doit() == 3
+
+
+def test_Curl():
+    assert Curl(v1) == Curl(R.x*R.i + R.z*R.z*R.j)
+    assert Curl(v2) == Curl(R.x*R.i + R.y*R.j + R.z*R.k)
+    assert Curl(v1).doit() == (-2*R.z)*R.i
+    assert Curl(v2).doit() == VectorZero()
+
+
+def test_Laplacian():
+    assert Laplacian(s3) == Laplacian(R.x**2 + R.y**2 + R.z**2)
+    assert Laplacian(v3) == Laplacian(R.x**2*R.i + R.y**2*R.j + R.z**2*R.k)
+    assert Laplacian(s3).doit() == 6
+    assert Laplacian(v3).doit() == 2*R.i + 2*R.j + 2*R.k
+    assert srepr(Laplacian(s3)) == \
+            'Laplacian(Add(Pow(R.x, Integer(2)), Pow(R.y, Integer(2)), Pow(R.z, Integer(2))))'
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_parametricregion.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_parametricregion.py
new file mode 100644
index 0000000000..68cd82db55
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_parametricregion.py
@@ -0,0 +1,96 @@
+from sympy import sin, cos, pi
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.vector.parametricregion import ParametricRegion, parametric_region_list
+from sympy.geometry import Point, Segment, Curve, Ellipse, Line, Parabola, Polygon
+from sympy.testing.pytest import raises
+from sympy.abc import a, b, r, t, x, y, z, theta, phi
+
+
+C = CoordSys3D('C')
+
+def test_ParametricRegion():
+
+    point = ParametricRegion((3, 4))
+    assert point.definition == (3, 4)
+    assert point.parameters == ()
+    assert point.limits == {}
+    assert point.dimensions == 0
+
+    # line x = y
+    line_xy = ParametricRegion((y, y), (y, 1, 5))
+    assert line_xy .definition == (y, y)
+    assert line_xy.parameters == (y,)
+    assert line_xy.dimensions == 1
+
+    # line y = z
+    line_yz = ParametricRegion((x,t,t), x, (t, 1, 2))
+    assert line_yz.definition == (x,t,t)
+    assert line_yz.parameters == (x, t)
+    assert line_yz.limits == {t: (1, 2)}
+    assert line_yz.dimensions == 1
+
+    p1 = ParametricRegion((9*a, -16*b), (a, 0, 2), (b, -1, 5))
+    assert p1.definition == (9*a, -16*b)
+    assert p1.parameters == (a, b)
+    assert p1.limits == {a: (0, 2), b: (-1, 5)}
+    assert p1.dimensions == 2
+
+    p2 = ParametricRegion((t, t**3), t)
+    assert p2.parameters == (t,)
+    assert p2.limits == {}
+    assert p2.dimensions == 0
+
+    circle = ParametricRegion((r*cos(theta), r*sin(theta)), r, (theta, 0, 2*pi))
+    assert circle.definition == (r*cos(theta), r*sin(theta))
+    assert circle.dimensions == 1
+
+    halfdisc = ParametricRegion((r*cos(theta), r*sin(theta)), (r, -2, 2), (theta, 0, pi))
+    assert halfdisc.definition == (r*cos(theta), r*sin(theta))
+    assert halfdisc.parameters == (r, theta)
+    assert halfdisc.limits == {r: (-2, 2), theta: (0, pi)}
+    assert halfdisc.dimensions == 2
+
+    ellipse = ParametricRegion((a*cos(t), b*sin(t)), (t, 0, 8))
+    assert ellipse.parameters == (t,)
+    assert ellipse.limits == {t: (0, 8)}
+    assert ellipse.dimensions == 1
+
+    cylinder = ParametricRegion((r*cos(theta), r*sin(theta), z), (r, 0, 1), (theta, 0, 2*pi), (z, 0, 4))
+    assert cylinder.parameters == (r, theta, z)
+    assert cylinder.dimensions == 3
+
+    sphere = ParametricRegion((r*sin(phi)*cos(theta),r*sin(phi)*sin(theta), r*cos(phi)),
+                                r, (theta, 0, 2*pi), (phi, 0, pi))
+    assert sphere.definition == (r*sin(phi)*cos(theta),r*sin(phi)*sin(theta), r*cos(phi))
+    assert sphere.parameters == (r, theta, phi)
+    assert sphere.dimensions == 2
+
+    raises(ValueError, lambda: ParametricRegion((a*t**2, 2*a*t), (a, -2)))
+    raises(ValueError, lambda: ParametricRegion((a, b), (a**2, sin(b)), (a, 2, 4, 6)))
+
+
+def test_parametric_region_list():
+
+    point = Point(-5, 12)
+    assert parametric_region_list(point) == [ParametricRegion((-5, 12))]
+
+    e = Ellipse(Point(2, 8), 2, 6)
+    assert parametric_region_list(e, t) == [ParametricRegion((2*cos(t) + 2, 6*sin(t) + 8), (t, 0, 2*pi))]
+
+    c = Curve((t, t**3), (t, 5, 3))
+    assert parametric_region_list(c) == [ParametricRegion((t, t**3), (t, 5, 3))]
+
+    s = Segment(Point(2, 11, -6), Point(0, 2, 5))
+    assert parametric_region_list(s, t) == [ParametricRegion((2 - 2*t, 11 - 9*t, 11*t - 6), (t, 0, 1))]
+    s1 = Segment(Point(0, 0), (1, 0))
+    assert parametric_region_list(s1, t) == [ParametricRegion((t, 0), (t, 0, 1))]
+    s2 = Segment(Point(1, 2, 3), Point(1, 2, 5))
+    assert parametric_region_list(s2, t) == [ParametricRegion((1, 2, 2*t + 3), (t, 0, 1))]
+    s3 = Segment(Point(12, 56), Point(12, 56))
+    assert parametric_region_list(s3) == [ParametricRegion((12, 56))]
+
+    poly = Polygon((1,3), (-3, 8), (2, 4))
+    assert parametric_region_list(poly, t) == [ParametricRegion((1 - 4*t, 5*t + 3), (t, 0, 1)), ParametricRegion((5*t - 3, 8 - 4*t), (t, 0, 1)), ParametricRegion((2 - t, 4 - t), (t, 0, 1))]
+
+    p1 = Parabola(Point(0, 0), Line(Point(5, 8), Point(7,8)))
+    raises(ValueError, lambda: parametric_region_list(p1))
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_printing.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_printing.py
new file mode 100644
index 0000000000..7edac35a0e
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_printing.py
@@ -0,0 +1,168 @@
+# -*- coding: utf-8 -*-
+from sympy import Integral, latex, Function
+from sympy import pretty as xpretty
+from sympy.vector import CoordSys3D, Vector, express
+from sympy.abc import a, b, c
+from sympy.testing.pytest import XFAIL
+
+
+def pretty(expr):
+    """ASCII pretty-printing"""
+    return xpretty(expr, use_unicode=False, wrap_line=False)
+
+
+def upretty(expr):
+    """Unicode pretty-printing"""
+    return xpretty(expr, use_unicode=True, wrap_line=False)
+
+
+# Initialize the basic and tedious vector/dyadic expressions
+# needed for testing.
+# Some of the pretty forms shown denote how the expressions just
+# above them should look with pretty printing.
+N = CoordSys3D('N')
+C = N.orient_new_axis('C', a, N.k)  # type: ignore
+v = []
+d = []
+v.append(Vector.zero)
+v.append(N.i)  # type: ignore
+v.append(-N.i)  # type: ignore
+v.append(N.i + N.j)  # type: ignore
+v.append(a*N.i)  # type: ignore
+v.append(a*N.i - b*N.j)  # type: ignore
+v.append((a**2 + N.x)*N.i + N.k)  # type: ignore
+v.append((a**2 + b)*N.i + 3*(C.y - c)*N.k)  # type: ignore
+f = Function('f')
+v.append(N.j - (Integral(f(b)) - C.x**2)*N.k)  # type: ignore
+upretty_v_8 = """\
+      ⎛   2   ⌠        ⎞    \n\
+j_N + ⎜x_C  - ⎮ f(b) db⎟ k_N\n\
+      ⎝       ⌡        ⎠    \
+"""
+pretty_v_8 = """\
+j_N + /         /       \\\n\
+      |   2    |        |\n\
+      |x_C  -  | f(b) db|\n\
+      |        |        |\n\
+      \\       /         / \
+"""
+
+v.append(N.i + C.k)  # type: ignore
+v.append(express(N.i, C))  # type: ignore
+v.append((a**2 + b)*N.i + (Integral(f(b)))*N.k)  # type: ignore
+upretty_v_11 = """\
+⎛ 2    ⎞        ⎛⌠        ⎞    \n\
+⎝a  + b⎠ i_N  + ⎜⎮ f(b) db⎟ k_N\n\
+                ⎝⌡        ⎠    \
+"""
+pretty_v_11 = """\
+/ 2    \\ + /  /       \\\n\
+\\a  + b/ i_N| |        |\n\
+           | | f(b) db|\n\
+           | |        |\n\
+           \\/         / \
+"""
+
+for x in v:
+    d.append(x | N.k)  # type: ignore
+s = 3*N.x**2*C.y  # type: ignore
+upretty_s = """\
+         2\n\
+3⋅y_C⋅x_N \
+"""
+pretty_s = """\
+         2\n\
+3*y_C*x_N \
+"""
+
+# This is the pretty form for ((a**2 + b)*N.i + 3*(C.y - c)*N.k) | N.k
+upretty_d_7 = """\
+⎛ 2    ⎞                                     \n\
+⎝a  + b⎠ (i_N|k_N)  + (3⋅y_C - 3⋅c) (k_N|k_N)\
+"""
+pretty_d_7 = """\
+/ 2    \\ (i_N|k_N) + (3*y_C - 3*c) (k_N|k_N)\n\
+\\a  + b/                                    \
+"""
+
+
+def test_str_printing():
+    assert str(v[0]) == '0'
+    assert str(v[1]) == 'N.i'
+    assert str(v[2]) == '(-1)*N.i'
+    assert str(v[3]) == 'N.i + N.j'
+    assert str(v[8]) == 'N.j + (C.x**2 - Integral(f(b), b))*N.k'
+    assert str(v[9]) == 'C.k + N.i'
+    assert str(s) == '3*C.y*N.x**2'
+    assert str(d[0]) == '0'
+    assert str(d[1]) == '(N.i|N.k)'
+    assert str(d[4]) == 'a*(N.i|N.k)'
+    assert str(d[5]) == 'a*(N.i|N.k) + (-b)*(N.j|N.k)'
+    assert str(d[8]) == ('(N.j|N.k) + (C.x**2 - ' +
+                         'Integral(f(b), b))*(N.k|N.k)')
+
+
+@XFAIL
+def test_pretty_printing_ascii():
+    assert pretty(v[0]) == '0'
+    assert pretty(v[1]) == 'i_N'
+    assert pretty(v[5]) == '(a) i_N + (-b) j_N'
+    assert pretty(v[8]) == pretty_v_8
+    assert pretty(v[2]) == '(-1) i_N'
+    assert pretty(v[11]) == pretty_v_11
+    assert pretty(s) == pretty_s
+    assert pretty(d[0]) == '(0|0)'
+    assert pretty(d[5]) == '(a) (i_N|k_N) + (-b) (j_N|k_N)'
+    assert pretty(d[7]) == pretty_d_7
+    assert pretty(d[10]) == '(cos(a)) (i_C|k_N) + (-sin(a)) (j_C|k_N)'
+
+
+def test_pretty_print_unicode_v():
+    assert upretty(v[0]) == '0'
+    assert upretty(v[1]) == 'i_N'
+    assert upretty(v[5]) == '(a) i_N + (-b) j_N'
+    # Make sure the printing works in other objects
+    assert upretty(v[5].args) == '((a) i_N, (-b) j_N)'
+    assert upretty(v[8]) == upretty_v_8
+    assert upretty(v[2]) == '(-1) i_N'
+    assert upretty(v[11]) == upretty_v_11
+    assert upretty(s) == upretty_s
+    assert upretty(d[0]) == '(0|0)'
+    assert upretty(d[5]) == '(a) (i_N|k_N) + (-b) (j_N|k_N)'
+    assert upretty(d[7]) == upretty_d_7
+    assert upretty(d[10]) == '(cos(a)) (i_C|k_N) + (-sin(a)) (j_C|k_N)'
+
+
+def test_latex_printing():
+    assert latex(v[0]) == '\\mathbf{\\hat{0}}'
+    assert latex(v[1]) == '\\mathbf{\\hat{i}_{N}}'
+    assert latex(v[2]) == '- \\mathbf{\\hat{i}_{N}}'
+    assert latex(v[5]) == ('(a)\\mathbf{\\hat{i}_{N}} + ' +
+                           '(- b)\\mathbf{\\hat{j}_{N}}')
+    assert latex(v[6]) == ('(\\mathbf{{x}_{N}} + a^{2})\\mathbf{\\hat{i}_' +
+                          '{N}} + \\mathbf{\\hat{k}_{N}}')
+    assert latex(v[8]) == ('\\mathbf{\\hat{j}_{N}} + (\\mathbf{{x}_' +
+                           '{C}}^{2} - \\int f{\\left(b \\right)}\\,' +
+                           ' db)\\mathbf{\\hat{k}_{N}}')
+    assert latex(s) == '3 \\mathbf{{y}_{C}} \\mathbf{{x}_{N}}^{2}'
+    assert latex(d[0]) == '(\\mathbf{\\hat{0}}|\\mathbf{\\hat{0}})'
+    assert latex(d[4]) == ('(a)(\\mathbf{\\hat{i}_{N}}{|}\\mathbf' +
+                           '{\\hat{k}_{N}})')
+    assert latex(d[9]) == ('(\\mathbf{\\hat{k}_{C}}{|}\\mathbf{\\' +
+                           'hat{k}_{N}}) + (\\mathbf{\\hat{i}_{N}}{|' +
+                           '}\\mathbf{\\hat{k}_{N}})')
+    assert latex(d[11]) == ('(a^{2} + b)(\\mathbf{\\hat{i}_{N}}{|}\\' +
+                            'mathbf{\\hat{k}_{N}}) + (\\int f{\\left(' +
+                            'b \\right)}\\, db)(\\mathbf{\\hat{k}_{N}' +
+                            '}{|}\\mathbf{\\hat{k}_{N}})')
+
+
+def test_custom_names():
+    A = CoordSys3D('A', vector_names=['x', 'y', 'z'],
+                   variable_names=['i', 'j', 'k'])
+    assert A.i.__str__() == 'A.i'
+    assert A.x.__str__() == 'A.x'
+    assert A.i._pretty_form == 'i_A'
+    assert A.x._pretty_form == 'x_A'
+    assert A.i._latex_form == r'\mathbf{{i}_{A}}'
+    assert A.x._latex_form == r"\mathbf{\hat{x}_{A}}"
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_vector.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_vector.py
new file mode 100644
index 0000000000..f7fc13d66f
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_vector.py
@@ -0,0 +1,241 @@
+from sympy.core import Rational
+from sympy.simplify import simplify, trigsimp
+from sympy import pi, sqrt, symbols, ImmutableMatrix as Matrix, \
+     sin, cos, Function, Integral, Derivative, diff
+from sympy.vector.vector import Vector, BaseVector, VectorAdd, \
+     VectorMul, VectorZero
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.vector.vector import Cross, Dot, cross
+from sympy.testing.pytest import raises
+
+C = CoordSys3D('C')
+
+i, j, k = C.base_vectors()
+a, b, c = symbols('a b c')
+
+
+def test_cross():
+    v1 = C.x * i + C.z * C.z * j
+    v2 = C.x * i + C.y * j + C.z * k
+    assert Cross(v1, v2) == Cross(C.x*C.i + C.z**2*C.j, C.x*C.i + C.y*C.j + C.z*C.k)
+    assert Cross(v1, v2).doit() == C.z**3*C.i + (-C.x*C.z)*C.j + (C.x*C.y - C.x*C.z**2)*C.k
+    assert cross(v1, v2) == C.z**3*C.i + (-C.x*C.z)*C.j + (C.x*C.y - C.x*C.z**2)*C.k
+    assert Cross(v1, v2) == -Cross(v2, v1)
+    assert Cross(v1, v2) + Cross(v2, v1) == Vector.zero
+
+
+def test_dot():
+    v1 = C.x * i + C.z * C.z * j
+    v2 = C.x * i + C.y * j + C.z * k
+    assert Dot(v1, v2) == Dot(C.x*C.i + C.z**2*C.j, C.x*C.i + C.y*C.j + C.z*C.k)
+    assert Dot(v1, v2).doit() == C.x**2 + C.y*C.z**2
+    assert Dot(v1, v2).doit() == C.x**2 + C.y*C.z**2
+    assert Dot(v1, v2) == Dot(v2, v1)
+
+
+def test_vector_sympy():
+    """
+    Test whether the Vector framework confirms to the hashing
+    and equality testing properties of SymPy.
+    """
+    v1 = 3*j
+    assert v1 == j*3
+    assert v1.components == {j: 3}
+    v2 = 3*i + 4*j + 5*k
+    v3 = 2*i + 4*j + i + 4*k + k
+    assert v3 == v2
+    assert v3.__hash__() == v2.__hash__()
+
+
+def test_vector():
+    assert isinstance(i, BaseVector)
+    assert i != j
+    assert j != k
+    assert k != i
+    assert i - i == Vector.zero
+    assert i + Vector.zero == i
+    assert i - Vector.zero == i
+    assert Vector.zero != 0
+    assert -Vector.zero == Vector.zero
+
+    v1 = a*i + b*j + c*k
+    v2 = a**2*i + b**2*j + c**2*k
+    v3 = v1 + v2
+    v4 = 2 * v1
+    v5 = a * i
+
+    assert isinstance(v1, VectorAdd)
+    assert v1 - v1 == Vector.zero
+    assert v1 + Vector.zero == v1
+    assert v1.dot(i) == a
+    assert v1.dot(j) == b
+    assert v1.dot(k) == c
+    assert i.dot(v2) == a**2
+    assert j.dot(v2) == b**2
+    assert k.dot(v2) == c**2
+    assert v3.dot(i) == a**2 + a
+    assert v3.dot(j) == b**2 + b
+    assert v3.dot(k) == c**2 + c
+
+    assert v1 + v2 == v2 + v1
+    assert v1 - v2 == -1 * (v2 - v1)
+    assert a * v1 == v1 * a
+
+    assert isinstance(v5, VectorMul)
+    assert v5.base_vector == i
+    assert v5.measure_number == a
+    assert isinstance(v4, Vector)
+    assert isinstance(v4, VectorAdd)
+    assert isinstance(v4, Vector)
+    assert isinstance(Vector.zero, VectorZero)
+    assert isinstance(Vector.zero, Vector)
+    assert isinstance(v1 * 0, VectorZero)
+
+    assert v1.to_matrix(C) == Matrix([[a], [b], [c]])
+
+    assert i.components == {i: 1}
+    assert v5.components == {i: a}
+    assert v1.components == {i: a, j: b, k: c}
+
+    assert VectorAdd(v1, Vector.zero) == v1
+    assert VectorMul(a, v1) == v1*a
+    assert VectorMul(1, i) == i
+    assert VectorAdd(v1, Vector.zero) == v1
+    assert VectorMul(0, Vector.zero) == Vector.zero
+    raises(TypeError, lambda: v1.outer(1))
+    raises(TypeError, lambda: v1.dot(1))
+
+
+def test_vector_magnitude_normalize():
+    assert Vector.zero.magnitude() == 0
+    assert Vector.zero.normalize() == Vector.zero
+
+    assert i.magnitude() == 1
+    assert j.magnitude() == 1
+    assert k.magnitude() == 1
+    assert i.normalize() == i
+    assert j.normalize() == j
+    assert k.normalize() == k
+
+    v1 = a * i
+    assert v1.normalize() == (a/sqrt(a**2))*i
+    assert v1.magnitude() == sqrt(a**2)
+
+    v2 = a*i + b*j + c*k
+    assert v2.magnitude() == sqrt(a**2 + b**2 + c**2)
+    assert v2.normalize() == v2 / v2.magnitude()
+
+    v3 = i + j
+    assert v3.normalize() == (sqrt(2)/2)*C.i + (sqrt(2)/2)*C.j
+
+
+def test_vector_simplify():
+    A, s, k, m = symbols('A, s, k, m')
+
+    test1 = (1 / a + 1 / b) * i
+    assert (test1 & i) != (a + b) / (a * b)
+    test1 = simplify(test1)
+    assert (test1 & i) == (a + b) / (a * b)
+    assert test1.simplify() == simplify(test1)
+
+    test2 = (A**2 * s**4 / (4 * pi * k * m**3)) * i
+    test2 = simplify(test2)
+    assert (test2 & i) == (A**2 * s**4 / (4 * pi * k * m**3))
+
+    test3 = ((4 + 4 * a - 2 * (2 + 2 * a)) / (2 + 2 * a)) * i
+    test3 = simplify(test3)
+    assert (test3 & i) == 0
+
+    test4 = ((-4 * a * b**2 - 2 * b**3 - 2 * a**2 * b) / (a + b)**2) * i
+    test4 = simplify(test4)
+    assert (test4 & i) == -2 * b
+
+    v = (sin(a)+cos(a))**2*i - j
+    assert trigsimp(v) == (2*sin(a + pi/4)**2)*i + (-1)*j
+    assert trigsimp(v) == v.trigsimp()
+
+    assert simplify(Vector.zero) == Vector.zero
+
+
+def test_vector_dot():
+    assert i.dot(Vector.zero) == 0
+    assert Vector.zero.dot(i) == 0
+    assert i & Vector.zero == 0
+
+    assert i.dot(i) == 1
+    assert i.dot(j) == 0
+    assert i.dot(k) == 0
+    assert i & i == 1
+    assert i & j == 0
+    assert i & k == 0
+
+    assert j.dot(i) == 0
+    assert j.dot(j) == 1
+    assert j.dot(k) == 0
+    assert j & i == 0
+    assert j & j == 1
+    assert j & k == 0
+
+    assert k.dot(i) == 0
+    assert k.dot(j) == 0
+    assert k.dot(k) == 1
+    assert k & i == 0
+    assert k & j == 0
+    assert k & k == 1
+
+    raises(TypeError, lambda: k.dot(1))
+
+
+def test_vector_cross():
+    assert i.cross(Vector.zero) == Vector.zero
+    assert Vector.zero.cross(i) == Vector.zero
+
+    assert i.cross(i) == Vector.zero
+    assert i.cross(j) == k
+    assert i.cross(k) == -j
+    assert i ^ i == Vector.zero
+    assert i ^ j == k
+    assert i ^ k == -j
+
+    assert j.cross(i) == -k
+    assert j.cross(j) == Vector.zero
+    assert j.cross(k) == i
+    assert j ^ i == -k
+    assert j ^ j == Vector.zero
+    assert j ^ k == i
+
+    assert k.cross(i) == j
+    assert k.cross(j) == -i
+    assert k.cross(k) == Vector.zero
+    assert k ^ i == j
+    assert k ^ j == -i
+    assert k ^ k == Vector.zero
+
+    assert k.cross(1) == Cross(k, 1)
+
+
+def test_projection():
+    v1 = i + j + k
+    v2 = 3*i + 4*j
+    v3 = 0*i + 0*j
+    assert v1.projection(v1) == i + j + k
+    assert v1.projection(v2) == Rational(7, 3)*C.i + Rational(7, 3)*C.j + Rational(7, 3)*C.k
+    assert v1.projection(v1, scalar=True) == 1
+    assert v1.projection(v2, scalar=True) == Rational(7, 3)
+    assert v3.projection(v1) == Vector.zero
+
+
+def test_vector_diff_integrate():
+    f = Function('f')
+    v = f(a)*C.i + a**2*C.j - C.k
+    assert Derivative(v, a) == Derivative((f(a))*C.i +
+                                          a**2*C.j + (-1)*C.k, a)
+    assert (diff(v, a) == v.diff(a) == Derivative(v, a).doit() ==
+            (Derivative(f(a), a))*C.i + 2*a*C.j)
+    assert (Integral(v, a) == (Integral(f(a), a))*C.i +
+            (Integral(a**2, a))*C.j + (Integral(-1, a))*C.k)
+
+
+def test_vector_args():
+    raises(ValueError, lambda: BaseVector(3, C))
+    raises(TypeError, lambda: BaseVector(0, Vector.zero))
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/vector.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/vector.py
new file mode 100644
index 0000000000..0a35b69b78
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/vector.py
@@ -0,0 +1,617 @@
+from typing import Type
+
+from sympy.core.assumptions import StdFactKB
+from sympy.core import S, Pow, sympify
+from sympy.core.expr import AtomicExpr, Expr
+from sympy.core.compatibility import default_sort_key
+from sympy import sqrt, ImmutableMatrix as Matrix, Add
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.vector.basisdependent import (BasisDependent, BasisDependentAdd,
+                                         BasisDependentMul, BasisDependentZero)
+from sympy.vector.dyadic import BaseDyadic, Dyadic, DyadicAdd
+
+
+class Vector(BasisDependent):
+    """
+    Super class for all Vector classes.
+    Ideally, neither this class nor any of its subclasses should be
+    instantiated by the user.
+    """
+
+    is_Vector = True
+    _op_priority = 12.0
+
+    _expr_type = None  # type: Type[Vector]
+    _mul_func = None  # type: Type[Vector]
+    _add_func = None  # type: Type[Vector]
+    _zero_func = None  # type: Type[Vector]
+    _base_func = None  # type: Type[Vector]
+    zero = None  # type: VectorZero
+
+    @property
+    def components(self):
+        """
+        Returns the components of this vector in the form of a
+        Python dictionary mapping BaseVector instances to the
+        corresponding measure numbers.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> C = CoordSys3D('C')
+        >>> v = 3*C.i + 4*C.j + 5*C.k
+        >>> v.components
+        {C.i: 3, C.j: 4, C.k: 5}
+
+        """
+        # The '_components' attribute is defined according to the
+        # subclass of Vector the instance belongs to.
+        return self._components
+
+    def magnitude(self):
+        """
+        Returns the magnitude of this vector.
+        """
+        return sqrt(self & self)
+
+    def normalize(self):
+        """
+        Returns the normalized version of this vector.
+        """
+        return self / self.magnitude()
+
+    def dot(self, other):
+        """
+        Returns the dot product of this Vector, either with another
+        Vector, or a Dyadic, or a Del operator.
+        If 'other' is a Vector, returns the dot product scalar (Sympy
+        expression).
+        If 'other' is a Dyadic, the dot product is returned as a Vector.
+        If 'other' is an instance of Del, returns the directional
+        derivative operator as a Python function. If this function is
+        applied to a scalar expression, it returns the directional
+        derivative of the scalar field wrt this Vector.
+
+        Parameters
+        ==========
+
+        other: Vector/Dyadic/Del
+            The Vector or Dyadic we are dotting with, or a Del operator .
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D, Del
+        >>> C = CoordSys3D('C')
+        >>> delop = Del()
+        >>> C.i.dot(C.j)
+        0
+        >>> C.i & C.i
+        1
+        >>> v = 3*C.i + 4*C.j + 5*C.k
+        >>> v.dot(C.k)
+        5
+        >>> (C.i & delop)(C.x*C.y*C.z)
+        C.y*C.z
+        >>> d = C.i.outer(C.i)
+        >>> C.i.dot(d)
+        C.i
+
+        """
+
+        # Check special cases
+        if isinstance(other, Dyadic):
+            if isinstance(self, VectorZero):
+                return Vector.zero
+            outvec = Vector.zero
+            for k, v in other.components.items():
+                vect_dot = k.args[0].dot(self)
+                outvec += vect_dot * v * k.args[1]
+            return outvec
+        from sympy.vector.deloperator import Del
+        if not isinstance(other, Vector) and not isinstance(other, Del):
+            raise TypeError(str(other) + " is not a vector, dyadic or " +
+                            "del operator")
+
+        # Check if the other is a del operator
+        if isinstance(other, Del):
+            def directional_derivative(field):
+                from sympy.vector.functions import directional_derivative
+                return directional_derivative(field, self)
+            return directional_derivative
+
+        return dot(self, other)
+
+    def __and__(self, other):
+        return self.dot(other)
+
+    __and__.__doc__ = dot.__doc__
+
+    def cross(self, other):
+        """
+        Returns the cross product of this Vector with another Vector or
+        Dyadic instance.
+        The cross product is a Vector, if 'other' is a Vector. If 'other'
+        is a Dyadic, this returns a Dyadic instance.
+
+        Parameters
+        ==========
+
+        other: Vector/Dyadic
+            The Vector or Dyadic we are crossing with.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> C = CoordSys3D('C')
+        >>> C.i.cross(C.j)
+        C.k
+        >>> C.i ^ C.i
+        0
+        >>> v = 3*C.i + 4*C.j + 5*C.k
+        >>> v ^ C.i
+        5*C.j + (-4)*C.k
+        >>> d = C.i.outer(C.i)
+        >>> C.j.cross(d)
+        (-1)*(C.k|C.i)
+
+        """
+
+        # Check special cases
+        if isinstance(other, Dyadic):
+            if isinstance(self, VectorZero):
+                return Dyadic.zero
+            outdyad = Dyadic.zero
+            for k, v in other.components.items():
+                cross_product = self.cross(k.args[0])
+                outer = cross_product.outer(k.args[1])
+                outdyad += v * outer
+            return outdyad
+
+        return cross(self, other)
+
+    def __xor__(self, other):
+        return self.cross(other)
+
+    __xor__.__doc__ = cross.__doc__
+
+    def outer(self, other):
+        """
+        Returns the outer product of this vector with another, in the
+        form of a Dyadic instance.
+
+        Parameters
+        ==========
+
+        other : Vector
+            The Vector with respect to which the outer product is to
+            be computed.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> N = CoordSys3D('N')
+        >>> N.i.outer(N.j)
+        (N.i|N.j)
+
+        """
+
+        # Handle the special cases
+        if not isinstance(other, Vector):
+            raise TypeError("Invalid operand for outer product")
+        elif (isinstance(self, VectorZero) or
+                isinstance(other, VectorZero)):
+            return Dyadic.zero
+
+        # Iterate over components of both the vectors to generate
+        # the required Dyadic instance
+        args = []
+        for k1, v1 in self.components.items():
+            for k2, v2 in other.components.items():
+                args.append((v1 * v2) * BaseDyadic(k1, k2))
+
+        return DyadicAdd(*args)
+
+    def projection(self, other, scalar=False):
+        """
+        Returns the vector or scalar projection of the 'other' on 'self'.
+
+        Examples
+        ========
+
+        >>> from sympy.vector.coordsysrect import CoordSys3D
+        >>> C = CoordSys3D('C')
+        >>> i, j, k = C.base_vectors()
+        >>> v1 = i + j + k
+        >>> v2 = 3*i + 4*j
+        >>> v1.projection(v2)
+        7/3*C.i + 7/3*C.j + 7/3*C.k
+        >>> v1.projection(v2, scalar=True)
+        7/3
+
+        """
+        if self.equals(Vector.zero):
+            return S.zero if scalar else Vector.zero
+
+        if scalar:
+            return self.dot(other) / self.dot(self)
+        else:
+            return self.dot(other) / self.dot(self) * self
+
+    @property
+    def _projections(self):
+        """
+        Returns the components of this vector but the output includes
+        also zero values components.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D, Vector
+        >>> C = CoordSys3D('C')
+        >>> v1 = 3*C.i + 4*C.j + 5*C.k
+        >>> v1._projections
+        (3, 4, 5)
+        >>> v2 = C.x*C.y*C.z*C.i
+        >>> v2._projections
+        (C.x*C.y*C.z, 0, 0)
+        >>> v3 = Vector.zero
+        >>> v3._projections
+        (0, 0, 0)
+        """
+
+        from sympy.vector.operators import _get_coord_sys_from_expr
+        if isinstance(self, VectorZero):
+            return (S.Zero, S.Zero, S.Zero)
+        base_vec = next(iter(_get_coord_sys_from_expr(self))).base_vectors()
+        return tuple([self.dot(i) for i in base_vec])
+
+    def __or__(self, other):
+        return self.outer(other)
+
+    __or__.__doc__ = outer.__doc__
+
+    def to_matrix(self, system):
+        """
+        Returns the matrix form of this vector with respect to the
+        specified coordinate system.
+
+        Parameters
+        ==========
+
+        system : CoordSys3D
+            The system wrt which the matrix form is to be computed
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> C = CoordSys3D('C')
+        >>> from sympy.abc import a, b, c
+        >>> v = a*C.i + b*C.j + c*C.k
+        >>> v.to_matrix(C)
+        Matrix([
+        [a],
+        [b],
+        [c]])
+
+        """
+
+        return Matrix([self.dot(unit_vec) for unit_vec in
+                       system.base_vectors()])
+
+    def separate(self):
+        """
+        The constituents of this vector in different coordinate systems,
+        as per its definition.
+
+        Returns a dict mapping each CoordSys3D to the corresponding
+        constituent Vector.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> R1 = CoordSys3D('R1')
+        >>> R2 = CoordSys3D('R2')
+        >>> v = R1.i + R2.i
+        >>> v.separate() == {R1: R1.i, R2: R2.i}
+        True
+
+        """
+
+        parts = {}
+        for vect, measure in self.components.items():
+            parts[vect.system] = (parts.get(vect.system, Vector.zero) +
+                                  vect * measure)
+        return parts
+
+    def _div_helper(one, other):
+        """ Helper for division involving vectors. """
+        if isinstance(one, Vector) and isinstance(other, Vector):
+            raise TypeError("Cannot divide two vectors")
+        elif isinstance(one, Vector):
+            if other == S.Zero:
+                raise ValueError("Cannot divide a vector by zero")
+            return VectorMul(one, Pow(other, S.NegativeOne))
+        else:
+            raise TypeError("Invalid division involving a vector")
+
+
+class BaseVector(Vector, AtomicExpr):
+    """
+    Class to denote a base vector.
+
+    Unicode pretty forms in Python 2 should use the prefix ``u``.
+
+    """
+
+    def __new__(cls, index, system, pretty_str=None, latex_str=None):
+        if pretty_str is None:
+            pretty_str = "x{}".format(index)
+        if latex_str is None:
+            latex_str = "x_{}".format(index)
+        pretty_str = str(pretty_str)
+        latex_str = str(latex_str)
+        # Verify arguments
+        if index not in range(0, 3):
+            raise ValueError("index must be 0, 1 or 2")
+        if not isinstance(system, CoordSys3D):
+            raise TypeError("system should be a CoordSys3D")
+        name = system._vector_names[index]
+        # Initialize an object
+        obj = super().__new__(cls, S(index), system)
+        # Assign important attributes
+        obj._base_instance = obj
+        obj._components = {obj: S.One}
+        obj._measure_number = S.One
+        obj._name = system._name + '.' + name
+        obj._pretty_form = '' + pretty_str
+        obj._latex_form = latex_str
+        obj._system = system
+        # The _id is used for printing purposes
+        obj._id = (index, system)
+        assumptions = {'commutative': True}
+        obj._assumptions = StdFactKB(assumptions)
+
+        # This attr is used for re-expression to one of the systems
+        # involved in the definition of the Vector. Applies to
+        # VectorMul and VectorAdd too.
+        obj._sys = system
+
+        return obj
+
+    @property
+    def system(self):
+        return self._system
+
+    def _sympystr(self, printer):
+        return self._name
+
+    @property
+    def free_symbols(self):
+        return {self}
+
+
+class VectorAdd(BasisDependentAdd, Vector):
+    """
+    Class to denote sum of Vector instances.
+    """
+
+    def __new__(cls, *args, **options):
+        obj = BasisDependentAdd.__new__(cls, *args, **options)
+        return obj
+
+    def _sympystr(self, printer):
+        ret_str = ''
+        items = list(self.separate().items())
+        items.sort(key=lambda x: x[0].__str__())
+        for system, vect in items:
+            base_vects = system.base_vectors()
+            for x in base_vects:
+                if x in vect.components:
+                    temp_vect = self.components[x] * x
+                    ret_str += printer._print(temp_vect) + " + "
+        return ret_str[:-3]
+
+
+class VectorMul(BasisDependentMul, Vector):
+    """
+    Class to denote products of scalars and BaseVectors.
+    """
+
+    def __new__(cls, *args, **options):
+        obj = BasisDependentMul.__new__(cls, *args, **options)
+        return obj
+
+    @property
+    def base_vector(self):
+        """ The BaseVector involved in the product. """
+        return self._base_instance
+
+    @property
+    def measure_number(self):
+        """ The scalar expression involved in the definition of
+        this VectorMul.
+        """
+        return self._measure_number
+
+
+class VectorZero(BasisDependentZero, Vector):
+    """
+    Class to denote a zero vector
+    """
+
+    _op_priority = 12.1
+    _pretty_form = '0'
+    _latex_form = r'\mathbf{\hat{0}}'
+
+    def __new__(cls):
+        obj = BasisDependentZero.__new__(cls)
+        return obj
+
+
+class Cross(Vector):
+    """
+    Represents unevaluated Cross product.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, Cross
+    >>> R = CoordSys3D('R')
+    >>> v1 = R.i + R.j + R.k
+    >>> v2 = R.x * R.i + R.y * R.j + R.z * R.k
+    >>> Cross(v1, v2)
+    Cross(R.i + R.j + R.k, R.x*R.i + R.y*R.j + R.z*R.k)
+    >>> Cross(v1, v2).doit()
+    (-R.y + R.z)*R.i + (R.x - R.z)*R.j + (-R.x + R.y)*R.k
+
+    """
+
+    def __new__(cls, expr1, expr2):
+        expr1 = sympify(expr1)
+        expr2 = sympify(expr2)
+        if default_sort_key(expr1) > default_sort_key(expr2):
+            return -Cross(expr2, expr1)
+        obj = Expr.__new__(cls, expr1, expr2)
+        obj._expr1 = expr1
+        obj._expr2 = expr2
+        return obj
+
+    def doit(self, **kwargs):
+        return cross(self._expr1, self._expr2)
+
+
+class Dot(Expr):
+    """
+    Represents unevaluated Dot product.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, Dot
+    >>> from sympy import symbols
+    >>> R = CoordSys3D('R')
+    >>> a, b, c = symbols('a b c')
+    >>> v1 = R.i + R.j + R.k
+    >>> v2 = a * R.i + b * R.j + c * R.k
+    >>> Dot(v1, v2)
+    Dot(R.i + R.j + R.k, a*R.i + b*R.j + c*R.k)
+    >>> Dot(v1, v2).doit()
+    a + b + c
+
+    """
+
+    def __new__(cls, expr1, expr2):
+        expr1 = sympify(expr1)
+        expr2 = sympify(expr2)
+        expr1, expr2 = sorted([expr1, expr2], key=default_sort_key)
+        obj = Expr.__new__(cls, expr1, expr2)
+        obj._expr1 = expr1
+        obj._expr2 = expr2
+        return obj
+
+    def doit(self, **kwargs):
+        return dot(self._expr1, self._expr2)
+
+
+def cross(vect1, vect2):
+    """
+    Returns cross product of two vectors.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D
+    >>> from sympy.vector.vector import cross
+    >>> R = CoordSys3D('R')
+    >>> v1 = R.i + R.j + R.k
+    >>> v2 = R.x * R.i + R.y * R.j + R.z * R.k
+    >>> cross(v1, v2)
+    (-R.y + R.z)*R.i + (R.x - R.z)*R.j + (-R.x + R.y)*R.k
+
+    """
+    if isinstance(vect1, Add):
+        return VectorAdd.fromiter(cross(i, vect2) for i in vect1.args)
+    if isinstance(vect2, Add):
+        return VectorAdd.fromiter(cross(vect1, i) for i in vect2.args)
+    if isinstance(vect1, BaseVector) and isinstance(vect2, BaseVector):
+        if vect1._sys == vect2._sys:
+            n1 = vect1.args[0]
+            n2 = vect2.args[0]
+            if n1 == n2:
+                return Vector.zero
+            n3 = ({0,1,2}.difference({n1, n2})).pop()
+            sign = 1 if ((n1 + 1) % 3 == n2) else -1
+            return sign*vect1._sys.base_vectors()[n3]
+        from .functions import express
+        try:
+            v = express(vect1, vect2._sys)
+        except ValueError:
+            return Cross(vect1, vect2)
+        else:
+            return cross(v, vect2)
+    if isinstance(vect1, VectorZero) or isinstance(vect2, VectorZero):
+        return Vector.zero
+    if isinstance(vect1, VectorMul):
+        v1, m1 = next(iter(vect1.components.items()))
+        return m1*cross(v1, vect2)
+    if isinstance(vect2, VectorMul):
+        v2, m2 = next(iter(vect2.components.items()))
+        return m2*cross(vect1, v2)
+
+    return Cross(vect1, vect2)
+
+
+def dot(vect1, vect2):
+    """
+    Returns dot product of two vectors.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D
+    >>> from sympy.vector.vector import dot
+    >>> R = CoordSys3D('R')
+    >>> v1 = R.i + R.j + R.k
+    >>> v2 = R.x * R.i + R.y * R.j + R.z * R.k
+    >>> dot(v1, v2)
+    R.x + R.y + R.z
+
+    """
+    if isinstance(vect1, Add):
+        return Add.fromiter(dot(i, vect2) for i in vect1.args)
+    if isinstance(vect2, Add):
+        return Add.fromiter(dot(vect1, i) for i in vect2.args)
+    if isinstance(vect1, BaseVector) and isinstance(vect2, BaseVector):
+        if vect1._sys == vect2._sys:
+            return S.One if vect1 == vect2 else S.Zero
+        from .functions import express
+        try:
+            v = express(vect2, vect1._sys)
+        except ValueError:
+            return Dot(vect1, vect2)
+        else:
+            return dot(vect1, v)
+    if isinstance(vect1, VectorZero) or isinstance(vect2, VectorZero):
+        return S.Zero
+    if isinstance(vect1, VectorMul):
+        v1, m1 = next(iter(vect1.components.items()))
+        return m1*dot(v1, vect2)
+    if isinstance(vect2, VectorMul):
+        v2, m2 = next(iter(vect2.components.items()))
+        return m2*dot(vect1, v2)
+
+    return Dot(vect1, vect2)
+
+
+Vector._expr_type = Vector
+Vector._mul_func = VectorMul
+Vector._add_func = VectorAdd
+Vector._zero_func = VectorZero
+Vector._base_func = BaseVector
+Vector.zero = VectorZero()
diff --git a/sympy_env/lib64 b/sympy_env/lib64
new file mode 120000
index 0000000000..7951405f85
--- /dev/null
+++ b/sympy_env/lib64
@@ -0,0 +1 @@
+lib
\ No newline at end of file
diff --git a/sympy_env/pyvenv.cfg b/sympy_env/pyvenv.cfg
new file mode 100644
index 0000000000..ef219d5716
--- /dev/null
+++ b/sympy_env/pyvenv.cfg
@@ -0,0 +1,3 @@
+home = /opt/miniconda3/envs/testbed/bin
+include-system-site-packages = false
+version = 3.9.19
diff --git a/test_symbol_dict.py b/test_symbol_dict.py
new file mode 100644
index 0000000000..1a5fac89ae
--- /dev/null
+++ b/test_symbol_dict.py
@@ -0,0 +1,7 @@
+import sympy
+
+s = sympy.Symbol('s')
+try:
+    print(s.__dict__)
+except AttributeError as e:
+    print(e)
\ No newline at end of file
[The command completed with exit code 0.]
[Current working directory: /workspace/sympy__sympy__1.7]
[Python interpreter: /workspace/sympy__sympy__1.7/sympy_env/bin/python]
--END AGENT OBSERVATION--
2025-01-17 08:00:51,536 - INFO - ------------------------------
2025-01-17 08:00:51,536 - INFO - END Runtime Completion Fn
2025-01-17 08:00:51,536 - INFO - ------------------------------
2025-01-17 08:00:51,536 - INFO - Got git diff for instance sympy__sympy-20590:
--------
+
+    for c in (ExtraneousFactors, ExtraneousFactors()):
+        check(c)
+
+    for c in (EvaluationFailed, EvaluationFailed()):
+        check(c)
+
+    for c in (RefinementFailed, RefinementFailed()):
+        check(c)
+
+    for c in (CoercionFailed, CoercionFailed()):
+        check(c)
+
+    for c in (NotInvertible, NotInvertible()):
+        check(c)
+
+    for c in (NotReversible, NotReversible()):
+        check(c)
+
+    for c in (NotAlgebraic, NotAlgebraic()):
+        check(c)
+
+    for c in (DomainError, DomainError()):
+        check(c)
+
+    for c in (PolynomialError, PolynomialError()):
+        check(c)
+
+    for c in (UnificationFailed, UnificationFailed()):
+        check(c)
+
+    for c in (GeneratorsError, GeneratorsError()):
+        check(c)
+
+    for c in (GeneratorsNeeded, GeneratorsNeeded()):
+        check(c)
+
+    # TODO: PicklingError: Can't pickle <function <lambda> at 0x38578c0>: it's not found as __main__.<lambda>
+    # for c in (ComputationFailed, ComputationFailed(lambda t: t, 3, None)):
+    #    check(c)
+
+    for c in (UnivariatePolynomialError, UnivariatePolynomialError()):
+        check(c)
+
+    for c in (MultivariatePolynomialError, MultivariatePolynomialError()):
+        check(c)
+
+    # TODO: TypeError: __init__() takes at least 3 arguments (1 given)
+    # for c in (PolificationFailed, PolificationFailed({}, x, x, False)):
+    #    check(c)
+
+    for c in (OptionError, OptionError()):
+        check(c)
+
+    for c in (FlagError, FlagError()):
+        check(c)
+
+#def test_pickling_polys_options():
+    #from sympy.polys.polyoptions import Options
+
+    # TODO: fix pickling of `symbols' flag
+    # for c in (Options, Options((), dict(domain='ZZ', polys=False))):
+    #    check(c)
+
+# TODO: def test_pickling_polys_rootisolation():
+#    RealInterval
+#    ComplexInterval
+
+def test_pickling_polys_rootoftools():
+    from sympy.polys.rootoftools import CRootOf, RootSum
+
+    x = Symbol('x')
+    f = x**3 + x + 3
+
+    for c in (CRootOf, CRootOf(f, 0)):
+        check(c)
+
+    for c in (RootSum, RootSum(f, exp)):
+        check(c)
+
+#================== printing ====================
+from sympy.printing.latex import LatexPrinter
+from sympy.printing.mathml import MathMLContentPrinter, MathMLPresentationPrinter
+from sympy.printing.pretty.pretty import PrettyPrinter
+from sympy.printing.pretty.stringpict import prettyForm, stringPict
+from sympy.printing.printer import Printer
+from sympy.printing.python import PythonPrinter
+
+
+def test_printing():
+    for c in (LatexPrinter, LatexPrinter(), MathMLContentPrinter,
+              MathMLPresentationPrinter, PrettyPrinter, prettyForm, stringPict,
+              stringPict("a"), Printer, Printer(), PythonPrinter,
+              PythonPrinter()):
+        check(c)
+
+
+@XFAIL
+def test_printing1():
+    check(MathMLContentPrinter())
+
+
+@XFAIL
+def test_printing2():
+    check(MathMLPresentationPrinter())
+
+
+@XFAIL
+def test_printing3():
+    check(PrettyPrinter())
+
+#================== series ======================
+from sympy.series.limits import Limit
+from sympy.series.order import Order
+
+
+def test_series():
+    e = Symbol("e")
+    x = Symbol("x")
+    for c in (Limit, Limit(e, x, 1), Order, Order(e)):
+        check(c)
+
+#================== concrete ==================
+from sympy.concrete.products import Product
+from sympy.concrete.summations import Sum
+
+
+def test_concrete():
+    x = Symbol("x")
+    for c in (Product, Product(x, (x, 2, 4)), Sum, Sum(x, (x, 2, 4))):
+        check(c)
+
+def test_deprecation_warning():
+    w = SymPyDeprecationWarning('value', 'feature', issue=12345, deprecated_since_version='1.0')
+    check(w)
+
+def test_issue_18438():
+    assert pickle.loads(pickle.dumps(S.Half)) == 1/2
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_source.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_source.py
new file mode 100644
index 0000000000..d4df63c09b
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_source.py
@@ -0,0 +1,30 @@
+import sys
+
+from sympy.utilities.source import get_mod_func, get_class, source
+from sympy.testing.pytest import warns_deprecated_sympy
+from sympy.geometry import point
+
+def test_source():
+    # Dummy stdout
+    class StdOut:
+        def write(self, x):
+            pass
+
+    # Test SymPyDeprecationWarning from source()
+    with warns_deprecated_sympy():
+        # Redirect stdout temporarily so print out is not seen
+        stdout = sys.stdout
+        try:
+            sys.stdout = StdOut()
+            source(point)
+        finally:
+            sys.stdout = stdout
+
+def test_get_mod_func():
+    assert get_mod_func(
+        'sympy.core.basic.Basic') == ('sympy.core.basic', 'Basic')
+
+
+def test_get_class():
+    _basic = get_class('sympy.core.basic.Basic')
+    assert _basic.__name__ == 'Basic'
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_timeutils.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_timeutils.py
new file mode 100644
index 0000000000..edaf66f919
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_timeutils.py
@@ -0,0 +1,10 @@
+"""Tests for simple tools for timing functions' execution. """
+
+from sympy.utilities.timeutils import timed
+
+def test_timed():
+    result = timed(lambda: 1 + 1, limit=100000)
+    assert result[0] == 100000 and result[3] == "ns"
+
+    result = timed("1 + 1", limit=100000)
+    assert result[0] == 100000 and result[3] == "ns"
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_wester.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_wester.py
new file mode 100644
index 0000000000..02b3dc6eb3
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tests/test_wester.py
@@ -0,0 +1,3043 @@
+""" Tests from Michael Wester's 1999 paper "Review of CAS mathematical
+capabilities".
+
+http://www.math.unm.edu/~wester/cas/book/Wester.pdf
+See also http://math.unm.edu/~wester/cas_review.html for detailed output of
+each tested system.
+"""
+
+from sympy import (Rational, symbols, Dummy, factorial, sqrt, log, exp, oo, zoo,
+    product, binomial, rf, pi, gamma, igcd, factorint, radsimp, combsimp,
+    npartitions, totient, primerange, factor, simplify, gcd, resultant, expand,
+    I, trigsimp, tan, sin, cos, cot, diff, nan, limit, EulerGamma, polygamma,
+    bernoulli, hyper, hyperexpand, besselj, asin, assoc_legendre, Function, re,
+    im, DiracDelta, chebyshevt, legendre_poly, polylog, series, O,
+    atan, sinh, cosh, tanh, floor, ceiling, solve, asinh, acot, csc, sec,
+    LambertW, N, apart, sqrtdenest, factorial2, powdenest, Mul, S, ZZ,
+    Poly, expand_func, E, Q, And, Lt, Min, ask, refine, AlgebraicNumber,
+    continued_fraction_iterator as cf_i, continued_fraction_periodic as cf_p,
+    continued_fraction_convergents as cf_c, continued_fraction_reduce as cf_r,
+    FiniteSet, elliptic_e, elliptic_f, powsimp, hessian, wronskian, fibonacci,
+    sign, Lambda, Piecewise, Subs, residue, Derivative, logcombine, Symbol,
+    Intersection, Union, EmptySet, Interval, idiff, ImageSet, acos, Max,
+    MatMul, conjugate)
+
+import mpmath
+from sympy.functions.combinatorial.numbers import stirling
+from sympy.functions.special.delta_functions import Heaviside
+from sympy.functions.special.error_functions import Ci, Si, erf
+from sympy.functions.special.zeta_functions import zeta
+from sympy.testing.pytest import (XFAIL, slow, SKIP, skip, ON_TRAVIS,
+    raises)
+from sympy.utilities.iterables import partitions
+from mpmath import mpi, mpc
+from sympy.matrices import Matrix, GramSchmidt, eye
+from sympy.matrices.expressions.blockmatrix import BlockMatrix, block_collapse
+from sympy.matrices.expressions import MatrixSymbol, ZeroMatrix
+from sympy.physics.quantum import Commutator
+from sympy.assumptions import assuming
+from sympy.polys.rings import PolyRing
+from sympy.polys.fields import FracField
+from sympy.polys.solvers import solve_lin_sys
+from sympy.concrete import Sum
+from sympy.concrete.products import Product
+from sympy.integrals import integrate
+from sympy.integrals.transforms import laplace_transform,\
+    inverse_laplace_transform, LaplaceTransform, fourier_transform,\
+    mellin_transform
+from sympy.solvers.recurr import rsolve
+from sympy.solvers.solveset import solveset, solveset_real, linsolve
+from sympy.solvers.ode import dsolve
+from sympy.core.relational import Equality
+from itertools import islice, takewhile
+from sympy.series.formal import fps
+from sympy.series.fourier import fourier_series
+from sympy.calculus.util import minimum
+
+
+R = Rational
+x, y, z = symbols('x y z')
+i, j, k, l, m, n = symbols('i j k l m n', integer=True)
+f = Function('f')
+g = Function('g')
+
+# A. Boolean Logic and Quantifier Elimination
+#   Not implemented.
+
+# B. Set Theory
+
+
+def test_B1():
+    assert (FiniteSet(i, j, j, k, k, k) | FiniteSet(l, k, j) |
+            FiniteSet(j, m, j)) == FiniteSet(i, j, k, l, m)
+
+
+def test_B2():
+    assert (FiniteSet(i, j, j, k, k, k) & FiniteSet(l, k, j) &
+            FiniteSet(j, m, j)) == Intersection({j, m}, {i, j, k}, {j, k, l})
+    # Previous output below. Not sure why that should be the expected output.
+    # There should probably be a way to rewrite Intersections that way but I
+    # don't see why an Intersection should evaluate like that:
+    #
+    # == Union({j}, Intersection({m}, Union({j, k}, Intersection({i}, {l}))))
+
+
+def test_B3():
+    assert (FiniteSet(i, j, k, l, m) - FiniteSet(j) ==
+            FiniteSet(i, k, l, m))
+
+
+def test_B4():
+    assert (FiniteSet(*(FiniteSet(i, j)*FiniteSet(k, l))) ==
+            FiniteSet((i, k), (i, l), (j, k), (j, l)))
+
+
+# C. Numbers
+
+
+def test_C1():
+    assert (factorial(50) ==
+        30414093201713378043612608166064768844377641568960512000000000000)
+
+
+def test_C2():
+    assert (factorint(factorial(50)) == {2: 47, 3: 22, 5: 12, 7: 8,
+        11: 4, 13: 3, 17: 2, 19: 2, 23: 2, 29: 1, 31: 1, 37: 1,
+        41: 1, 43: 1, 47: 1})
+
+
+def test_C3():
+    assert (factorial2(10), factorial2(9)) == (3840, 945)
+
+
+# Base conversions; not really implemented by sympy
+# Whatever. Take credit!
+def test_C4():
+    assert 0xABC == 2748
+
+
+def test_C5():
+    assert 123 == int('234', 7)
+
+
+def test_C6():
+    assert int('677', 8) == int('1BF', 16) == 447
+
+
+def test_C7():
+    assert log(32768, 8) == 5
+
+
+def test_C8():
+    # Modular multiplicative inverse. Would be nice if divmod could do this.
+    assert ZZ.invert(5, 7) == 3
+    assert ZZ.invert(5, 6) == 5
+
+
+def test_C9():
+    assert igcd(igcd(1776, 1554), 5698) == 74
+
+
+def test_C10():
+    x = 0
+    for n in range(2, 11):
+        x += R(1, n)
+    assert x == R(4861, 2520)
+
+
+def test_C11():
+    assert R(1, 7) == S('0.[142857]')
+
+
+def test_C12():
+    assert R(7, 11) * R(22, 7) == 2
+
+
+def test_C13():
+    test = R(10, 7) * (1 + R(29, 1000)) ** R(1, 3)
+    good = 3 ** R(1, 3)
+    assert test == good
+
+
+def test_C14():
+    assert sqrtdenest(sqrt(2*sqrt(3) + 4)) == 1 + sqrt(3)
+
+
+def test_C15():
+    test = sqrtdenest(sqrt(14 + 3*sqrt(3 + 2*sqrt(5 - 12*sqrt(3 - 2*sqrt(2))))))
+    good = sqrt(2) + 3
+    assert test == good
+
+
+def test_C16():
+    test = sqrtdenest(sqrt(10 + 2*sqrt(6) + 2*sqrt(10) + 2*sqrt(15)))
+    good = sqrt(2) + sqrt(3) + sqrt(5)
+    assert test == good
+
+
+def test_C17():
+    test = radsimp((sqrt(3) + sqrt(2)) / (sqrt(3) - sqrt(2)))
+    good = 5 + 2*sqrt(6)
+    assert test == good
+
+
+def test_C18():
+    assert simplify((sqrt(-2 + sqrt(-5)) * sqrt(-2 - sqrt(-5))).expand(complex=True)) == 3
+
+
+@XFAIL
+def test_C19():
+    assert radsimp(simplify((90 + 34*sqrt(7)) ** R(1, 3))) == 3 + sqrt(7)
+
+
+def test_C20():
+    inside = (135 + 78*sqrt(3))
+    test = AlgebraicNumber((inside**R(2, 3) + 3) * sqrt(3) / inside**R(1, 3))
+    assert simplify(test) == AlgebraicNumber(12)
+
+
+def test_C21():
+    assert simplify(AlgebraicNumber((41 + 29*sqrt(2)) ** R(1, 5))) == \
+        AlgebraicNumber(1 + sqrt(2))
+
+
+@XFAIL
+def test_C22():
+    test = simplify(((6 - 4*sqrt(2))*log(3 - 2*sqrt(2)) + (3 - 2*sqrt(2))*log(17
+        - 12*sqrt(2)) + 32 - 24*sqrt(2)) / (48*sqrt(2) - 72))
+    good = sqrt(2)/3 - log(sqrt(2) - 1)/3
+    assert test == good
+
+
+def test_C23():
+    assert 2 * oo - 3 is oo
+
+
+@XFAIL
+def test_C24():
+    raise NotImplementedError("2**aleph_null == aleph_1")
+
+# D. Numerical Analysis
+
+
+def test_D1():
+    assert 0.0 / sqrt(2) == 0.0
+
+
+def test_D2():
+    assert str(exp(-1000000).evalf()) == '3.29683147808856e-434295'
+
+
+def test_D3():
+    assert exp(pi*sqrt(163)).evalf(50).num.ae(262537412640768744)
+
+
+def test_D4():
+    assert floor(R(-5, 3)) == -2
+    assert ceiling(R(-5, 3)) == -1
+
+
+@XFAIL
+def test_D5():
+    raise NotImplementedError("cubic_spline([1, 2, 4, 5], [1, 4, 2, 3], x)(3) == 27/8")
+
+
+@XFAIL
+def test_D6():
+    raise NotImplementedError("translate sum(a[i]*x**i, (i,1,n)) to FORTRAN")
+
+
+@XFAIL
+def test_D7():
+    raise NotImplementedError("translate sum(a[i]*x**i, (i,1,n)) to C")
+
+
+@XFAIL
+def test_D8():
+    # One way is to cheat by converting the sum to a string,
+    # and replacing the '[' and ']' with ''.
+    # E.g., horner(S(str(_).replace('[','').replace(']','')))
+    raise NotImplementedError("apply Horner's rule to sum(a[i]*x**i, (i,1,5))")
+
+
+@XFAIL
+def test_D9():
+    raise NotImplementedError("translate D8 to FORTRAN")
+
+
+@XFAIL
+def test_D10():
+    raise NotImplementedError("translate D8 to C")
+
+
+@XFAIL
+def test_D11():
+    #Is there a way to use count_ops?
+    raise NotImplementedError("flops(sum(product(f[i][k], (i,1,k)), (k,1,n)))")
+
+
+@XFAIL
+def test_D12():
+    assert (mpi(-4, 2) * x + mpi(1, 3)) ** 2 == mpi(-8, 16)*x**2 + mpi(-24, 12)*x + mpi(1, 9)
+
+
+@XFAIL
+def test_D13():
+    raise NotImplementedError("discretize a PDE: diff(f(x,t),t) == diff(diff(f(x,t),x),x)")
+
+# E. Statistics
+#   See scipy; all of this is numerical.
+
+# F. Combinatorial Theory.
+
+
+def test_F1():
+    assert rf(x, 3) == x*(1 + x)*(2 + x)
+
+
+def test_F2():
+    assert expand_func(binomial(n, 3)) == n*(n - 1)*(n - 2)/6
+
+
+@XFAIL
+def test_F3():
+    assert combsimp(2**n * factorial(n) * factorial2(2*n - 1)) == factorial(2*n)
+
+
+@XFAIL
+def test_F4():
+    assert combsimp(2**n * factorial(n) * product(2*k - 1, (k, 1, n))) == factorial(2*n)
+
+
+@XFAIL
+def test_F5():
+    assert gamma(n + R(1, 2)) / sqrt(pi) / factorial(n) == factorial(2*n)/2**(2*n)/factorial(n)**2
+
+
+def test_F6():
+    partTest = [p.copy() for p in partitions(4)]
+    partDesired = [{4: 1}, {1: 1, 3: 1}, {2: 2}, {1: 2, 2:1}, {1: 4}]
+    assert partTest == partDesired
+
+
+def test_F7():
+    assert npartitions(4) == 5
+
+
+def test_F8():
+    assert stirling(5, 2, signed=True) == -50  # if signed, then kind=1
+
+
+def test_F9():
+    assert totient(1776) == 576
+
+# G. Number Theory
+
+
+def test_G1():
+    assert list(primerange(999983, 1000004)) == [999983, 1000003]
+
+
+@XFAIL
+def test_G2():
+    raise NotImplementedError("find the primitive root of 191 == 19")
+
+
+@XFAIL
+def test_G3():
+    raise NotImplementedError("(a+b)**p mod p == a**p + b**p mod p; p prime")
+
+# ... G14 Modular equations are not implemented.
+
+def test_G15():
+    assert Rational(sqrt(3).evalf()).limit_denominator(15) == R(26, 15)
+    assert list(takewhile(lambda x: x.q <= 15, cf_c(cf_i(sqrt(3)))))[-1] == \
+        R(26, 15)
+
+
+def test_G16():
+    assert list(islice(cf_i(pi),10)) == [3, 7, 15, 1, 292, 1, 1, 1, 2, 1]
+
+
+def test_G17():
+    assert cf_p(0, 1, 23) == [4, [1, 3, 1, 8]]
+
+
+def test_G18():
+    assert cf_p(1, 2, 5) == [[1]]
+    assert cf_r([[1]]).expand() == S.Half + sqrt(5)/2
+
+
+@XFAIL
+def test_G19():
+    s = symbols('s', integer=True, positive=True)
+    it = cf_i((exp(1/s) - 1)/(exp(1/s) + 1))
+    assert list(islice(it, 5)) == [0, 2*s, 6*s, 10*s, 14*s]
+
+
+def test_G20():
+    s = symbols('s', integer=True, positive=True)
+    # Wester erroneously has this as -s + sqrt(s**2 + 1)
+    assert cf_r([[2*s]]) == s + sqrt(s**2 + 1)
+
+
+@XFAIL
+def test_G20b():
+    s = symbols('s', integer=True, positive=True)
+    assert cf_p(s, 1, s**2 + 1) == [[2*s]]
+
+
+# H. Algebra
+
+
+def test_H1():
+    assert simplify(2*2**n) == simplify(2**(n + 1))
+    assert powdenest(2*2**n) == simplify(2**(n + 1))
+
+
+def test_H2():
+    assert powsimp(4 * 2**n) == 2**(n + 2)
+
+
+def test_H3():
+    assert (-1)**(n*(n + 1)) == 1
+
+
+def test_H4():
+    expr = factor(6*x - 10)
+    assert type(expr) is Mul
+    assert expr.args[0] == 2
+    assert expr.args[1] == 3*x - 5
+
+p1 = 64*x**34 - 21*x**47 - 126*x**8 - 46*x**5 - 16*x**60 - 81
+p2 = 72*x**60 - 25*x**25 - 19*x**23 - 22*x**39 - 83*x**52 + 54*x**10 + 81
+q = 34*x**19 - 25*x**16 + 70*x**7 + 20*x**3 - 91*x - 86
+
+
+def test_H5():
+    assert gcd(p1, p2, x) == 1
+
+
+def test_H6():
+    assert gcd(expand(p1 * q), expand(p2 * q)) == q
+
+
+def test_H7():
+    p1 = 24*x*y**19*z**8 - 47*x**17*y**5*z**8 + 6*x**15*y**9*z**2 - 3*x**22 + 5
+    p2 = 34*x**5*y**8*z**13 + 20*x**7*y**7*z**7 + 12*x**9*y**16*z**4 + 80*y**14*z
+    assert gcd(p1, p2, x, y, z) == 1
+
+
+def test_H8():
+    p1 = 24*x*y**19*z**8 - 47*x**17*y**5*z**8 + 6*x**15*y**9*z**2 - 3*x**22 + 5
+    p2 = 34*x**5*y**8*z**13 + 20*x**7*y**7*z**7 + 12*x**9*y**16*z**4 + 80*y**14*z
+    q = 11*x**12*y**7*z**13 - 23*x**2*y**8*z**10 + 47*x**17*y**5*z**8
+    assert gcd(p1 * q, p2 * q, x, y, z) == q
+
+
+def test_H9():
+    p1 = 2*x**(n + 4) - x**(n + 2)
+    p2 = 4*x**(n + 1) + 3*x**n
+    assert gcd(p1, p2) == x**n
+
+
+def test_H10():
+    p1 = 3*x**4 + 3*x**3 + x**2 - x - 2
+    p2 = x**3 - 3*x**2 + x + 5
+    assert resultant(p1, p2, x) == 0
+
+
+def test_H11():
+    assert resultant(p1 * q, p2 * q, x) == 0
+
+
+def test_H12():
+    num = x**2 - 4
+    den = x**2 + 4*x + 4
+    assert simplify(num/den) == (x - 2)/(x + 2)
+
+
+@XFAIL
+def test_H13():
+    assert simplify((exp(x) - 1) / (exp(x/2) + 1)) == exp(x/2) - 1
+
+
+def test_H14():
+    p = (x + 1) ** 20
+    ep = expand(p)
+    assert ep == (1 + 20*x + 190*x**2 + 1140*x**3 + 4845*x**4 + 15504*x**5
+        + 38760*x**6 + 77520*x**7 + 125970*x**8 + 167960*x**9 + 184756*x**10
+        + 167960*x**11 + 125970*x**12 + 77520*x**13 + 38760*x**14 + 15504*x**15
+        + 4845*x**16 + 1140*x**17 + 190*x**18 + 20*x**19 + x**20)
+    dep = diff(ep, x)
+    assert dep == (20 + 380*x + 3420*x**2 + 19380*x**3 + 77520*x**4
+        + 232560*x**5 + 542640*x**6 + 1007760*x**7 + 1511640*x**8 + 1847560*x**9
+        + 1847560*x**10 + 1511640*x**11 + 1007760*x**12 + 542640*x**13
+        + 232560*x**14 + 77520*x**15 + 19380*x**16 + 3420*x**17 + 380*x**18
+        + 20*x**19)
+    assert factor(dep) == 20*(1 + x)**19
+
+
+def test_H15():
+    assert simplify(Mul(*[x - r for r in solveset(x**3 + x**2 - 7)])) == x**3 + x**2 - 7
+
+
+def test_H16():
+    assert factor(x**100 - 1) == ((x - 1)*(x + 1)*(x**2 + 1)*(x**4 - x**3
+        + x**2 - x + 1)*(x**4 + x**3 + x**2 + x + 1)*(x**8 - x**6 + x**4
+        - x**2 + 1)*(x**20 - x**15 + x**10 - x**5 + 1)*(x**20 + x**15 + x**10
+        + x**5 + 1)*(x**40 - x**30 + x**20 - x**10 + 1))
+
+
+def test_H17():
+    assert simplify(factor(expand(p1 * p2)) - p1*p2) == 0
+
+
+@XFAIL
+def test_H18():
+    # Factor over complex rationals.
+    test = factor(4*x**4 + 8*x**3 + 77*x**2 + 18*x + 153)
+    good = (2*x + 3*I)*(2*x - 3*I)*(x + 1 - 4*I)*(x + 1 + 4*I)
+    assert test == good
+
+
+def test_H19():
+    a = symbols('a')
+    # The idea is to let a**2 == 2, then solve 1/(a-1). Answer is a+1")
+    assert Poly(a - 1).invert(Poly(a**2 - 2)) == a + 1
+
+
+@XFAIL
+def test_H20():
+    raise NotImplementedError("let a**2==2; (x**3 + (a-2)*x**2 - "
+        + "(2*a+3)*x - 3*a) / (x**2-2) = (x**2 - 2*x - 3) / (x-a)")
+
+
+@XFAIL
+def test_H21():
+    raise NotImplementedError("evaluate (b+c)**4 assuming b**3==2, c**2==3. \
+                              Answer is 2*b + 8*c + 18*b**2 + 12*b*c + 9")
+
+
+def test_H22():
+    assert factor(x**4 - 3*x**2 + 1, modulus=5) == (x - 2)**2 * (x + 2)**2
+
+
+def test_H23():
+    f = x**11 + x + 1
+    g = (x**2 + x + 1) * (x**9 - x**8 + x**6 - x**5 + x**3 - x**2 + 1)
+    assert factor(f, modulus=65537) == g
+
+
+def test_H24():
+    phi = AlgebraicNumber(S.GoldenRatio.expand(func=True), alias='phi')
+    assert factor(x**4 - 3*x**2 + 1, extension=phi) == \
+        (x - phi)*(x + 1 - phi)*(x - 1 + phi)*(x + phi)
+
+
+def test_H25():
+    e = (x - 2*y**2 + 3*z**3) ** 20
+    assert factor(expand(e)) == e
+
+
+def test_H26():
+    g = expand((sin(x) - 2*cos(y)**2 + 3*tan(z)**3)**20)
+    assert factor(g, expand=False) == (-sin(x) + 2*cos(y)**2 - 3*tan(z)**3)**20
+
+
+def test_H27():
+    f = 24*x*y**19*z**8 - 47*x**17*y**5*z**8 + 6*x**15*y**9*z**2 - 3*x**22 + 5
+    g = 34*x**5*y**8*z**13 + 20*x**7*y**7*z**7 + 12*x**9*y**16*z**4 + 80*y**14*z
+    h = -2*z*y**7 \
+        *(6*x**9*y**9*z**3 + 10*x**7*z**6 + 17*y*x**5*z**12 + 40*y**7) \
+        *(3*x**22 + 47*x**17*y**5*z**8 - 6*x**15*y**9*z**2 - 24*x*y**19*z**8 - 5)
+    assert factor(expand(f*g)) == h
+
+
+@XFAIL
+def test_H28():
+    raise NotImplementedError("expand ((1 - c**2)**5 * (1 - s**2)**5 * "
+        + "(c**2 + s**2)**10) with c**2 + s**2 = 1. Answer is c**10*s**10.")
+
+
+@XFAIL
+def test_H29():
+    assert factor(4*x**2 - 21*x*y + 20*y**2, modulus=3) == (x + y)*(x - y)
+
+
+def test_H30():
+    test = factor(x**3 + y**3, extension=sqrt(-3))
+    answer = (x + y)*(x + y*(-R(1, 2) - sqrt(3)/2*I))*(x + y*(-R(1, 2) + sqrt(3)/2*I))
+    assert answer == test
+
+
+def test_H31():
+    f = (x**2 + 2*x + 3)/(x**3 + 4*x**2 + 5*x + 2)
+    g = 2 / (x + 1)**2 - 2 / (x + 1) + 3 / (x + 2)
+    assert apart(f) == g
+
+
+@XFAIL
+def test_H32():  # issue 6558
+    raise NotImplementedError("[A*B*C - (A*B*C)**(-1)]*A*C*B (product \
+                              of a non-commuting product and its inverse)")
+
+
+def test_H33():
+    A, B, C = symbols('A, B, C', commutative=False)
+    assert (Commutator(A, Commutator(B, C))
+        + Commutator(B, Commutator(C, A))
+        + Commutator(C, Commutator(A, B))).doit().expand() == 0
+
+
+# I. Trigonometry
+
+def test_I1():
+    assert tan(pi*R(7, 10)) == -sqrt(1 + 2/sqrt(5))
+
+
+@XFAIL
+def test_I2():
+    assert sqrt((1 + cos(6))/2) == -cos(3)
+
+
+def test_I3():
+    assert cos(n*pi) + sin((4*n - 1)*pi/2) == (-1)**n - 1
+
+
+def test_I4():
+    assert refine(cos(pi*cos(n*pi)) + sin(pi/2*cos(n*pi)), Q.integer(n)) == (-1)**n - 1
+
+
+@XFAIL
+def test_I5():
+    assert sin((n**5/5 + n**4/2 + n**3/3 - n/30) * pi) == 0
+
+
+@XFAIL
+def test_I6():
+    raise NotImplementedError("assuming -3*pi<x<-5*pi/2, abs(cos(x)) == -cos(x), abs(sin(x)) == -sin(x)")
+
+
+@XFAIL
+def test_I7():
+    assert cos(3*x)/cos(x) == cos(x)**2 - 3*sin(x)**2
+
+
+@XFAIL
+def test_I8():
+    assert cos(3*x)/cos(x) == 2*cos(2*x) - 1
+
+
+@XFAIL
+def test_I9():
+    # Supposed to do this with rewrite rules.
+    assert cos(3*x)/cos(x) == cos(x)**2 - 3*sin(x)**2
+
+
+def test_I10():
+    assert trigsimp((tan(x)**2 + 1 - cos(x)**-2) / (sin(x)**2 + cos(x)**2 - 1)) is nan
+
+
+@SKIP("hangs")
+@XFAIL
+def test_I11():
+    assert limit((tan(x)**2 + 1 - cos(x)**-2) / (sin(x)**2 + cos(x)**2 - 1), x, 0) != 0
+
+
+@XFAIL
+def test_I12():
+    # This should fail or return nan or something.
+    res = diff((tan(x)**2 + 1 - cos(x)**-2) / (sin(x)**2 + cos(x)**2 - 1), x)
+    assert res is nan # trigsimp(res) gives nan
+
+# J. Special functions.
+
+
+def test_J1():
+    assert bernoulli(16) == R(-3617, 510)
+
+
+def test_J2():
+    assert diff(elliptic_e(x, y**2), y) == (elliptic_e(x, y**2) - elliptic_f(x, y**2))/y
+
+
+@XFAIL
+def test_J3():
+    raise NotImplementedError("Jacobi elliptic functions: diff(dn(u,k), u) == -k**2*sn(u,k)*cn(u,k)")
+
+
+def test_J4():
+    assert gamma(R(-1, 2)) == -2*sqrt(pi)
+
+
+def test_J5():
+    assert polygamma(0, R(1, 3)) == -log(3) - sqrt(3)*pi/6 - EulerGamma - log(sqrt(3))
+
+
+def test_J6():
+    assert mpmath.besselj(2, 1 + 1j).ae(mpc('0.04157988694396212', '0.24739764151330632'))
+
+
+def test_J7():
+    assert simplify(besselj(R(-5,2), pi/2)) == 12/(pi**2)
+
+
+def test_J8():
+    p = besselj(R(3,2), z)
+    q = (sin(z)/z - cos(z))/sqrt(pi*z/2)
+    assert simplify(expand_func(p) -q) == 0
+
+
+def test_J9():
+    assert besselj(0, z).diff(z) == - besselj(1, z)
+
+
+def test_J10():
+    mu, nu = symbols('mu, nu', integer=True)
+    assert assoc_legendre(nu, mu, 0) == 2**mu*sqrt(pi)/gamma((nu - mu)/2 + 1)/gamma((-nu - mu + 1)/2)
+
+
+def test_J11():
+    assert simplify(assoc_legendre(3, 1, x)) == simplify(-R(3, 2)*sqrt(1 - x**2)*(5*x**2 - 1))
+
+
+@slow
+def test_J12():
+    assert simplify(chebyshevt(1008, x) - 2*x*chebyshevt(1007, x) + chebyshevt(1006, x)) == 0
+
+
+def test_J13():
+    a = symbols('a', integer=True, negative=False)
+    assert chebyshevt(a, -1) == (-1)**a
+
+
+def test_J14():
+    p = hyper([S.Half, S.Half], [R(3, 2)], z**2)
+    assert hyperexpand(p) == asin(z)/z
+
+
+@XFAIL
+def test_J15():
+    raise NotImplementedError("F((n+2)/2,-(n-2)/2,R(3,2),sin(z)**2) == sin(n*z)/(n*sin(z)*cos(z)); F(.) is hypergeometric function")
+
+
+@XFAIL
+def test_J16():
+    raise NotImplementedError("diff(zeta(x), x) @ x=0 == -log(2*pi)/2")
+
+
+def test_J17():
+    assert integrate(f((x + 2)/5)*DiracDelta((x - 2)/3) - g(x)*diff(DiracDelta(x - 1), x), (x, 0, 3)) == 3*f(R(4, 5)) + Subs(Derivative(g(x), x), x, 1)
+
+
+@XFAIL
+def test_J18():
+    raise NotImplementedError("define an antisymmetric function")
+
+
+# K. The Complex Domain
+
+def test_K1():
+    z1, z2 = symbols('z1, z2', complex=True)
+    assert re(z1 + I*z2) == -im(z2) + re(z1)
+    assert im(z1 + I*z2) == im(z1) + re(z2)
+
+
+def test_K2():
+    assert abs(3 - sqrt(7) + I*sqrt(6*sqrt(7) - 15)) == 1
+
+
+@XFAIL
+def test_K3():
+    a, b = symbols('a, b', real=True)
+    assert simplify(abs(1/(a + I/a + I*b))) == 1/sqrt(a**2 + (I/a + b)**2)
+
+
+def test_K4():
+    assert log(3 + 4*I).expand(complex=True) == log(5) + I*atan(R(4, 3))
+
+
+def test_K5():
+    x, y = symbols('x, y', real=True)
+    assert tan(x + I*y).expand(complex=True) == (sin(2*x)/(cos(2*x) +
+        cosh(2*y)) + I*sinh(2*y)/(cos(2*x) + cosh(2*y)))
+
+
+def test_K6():
+    assert sqrt(x*y*abs(z)**2)/(sqrt(x)*abs(z)) == sqrt(x*y)/sqrt(x)
+    assert sqrt(x*y*abs(z)**2)/(sqrt(x)*abs(z)) != sqrt(y)
+
+
+def test_K7():
+    y = symbols('y', real=True, negative=False)
+    expr = sqrt(x*y*abs(z)**2)/(sqrt(x)*abs(z))
+    sexpr = simplify(expr)
+    assert sexpr == sqrt(y)
+
+
+def test_K8():
+    z = symbols('z', complex=True)
+    assert simplify(sqrt(1/z) - 1/sqrt(z)) != 0  # Passes
+    z = symbols('z', complex=True, negative=False)
+    assert simplify(sqrt(1/z) - 1/sqrt(z)) == 0  # Fails
+
+
+def test_K9():
+    z = symbols('z', real=True, positive=True)
+    assert simplify(sqrt(1/z) - 1/sqrt(z)) == 0
+
+
+def test_K10():
+    z = symbols('z', real=True, negative=True)
+    assert simplify(sqrt(1/z) + 1/sqrt(z)) == 0
+
+# This goes up to K25
+
+# L. Determining Zero Equivalence
+
+
+def test_L1():
+    assert sqrt(997) - (997**3)**R(1, 6) == 0
+
+
+def test_L2():
+    assert sqrt(999983) - (999983**3)**R(1, 6) == 0
+
+
+def test_L3():
+    assert simplify((2**R(1, 3) + 4**R(1, 3))**3 - 6*(2**R(1, 3) + 4**R(1, 3)) - 6) == 0
+
+
+def test_L4():
+    assert trigsimp(cos(x)**3 + cos(x)*sin(x)**2 - cos(x)) == 0
+
+
+@XFAIL
+def test_L5():
+    assert log(tan(R(1, 2)*x + pi/4)) - asinh(tan(x)) == 0
+
+
+def test_L6():
+    assert (log(tan(x/2 + pi/4)) - asinh(tan(x))).diff(x).subs({x: 0}) == 0
+
+
+@XFAIL
+def test_L7():
+    assert simplify(log((2*sqrt(x) + 1)/(sqrt(4*x + 4*sqrt(x) + 1)))) == 0
+
+
+@XFAIL
+def test_L8():
+    assert simplify((4*x + 4*sqrt(x) + 1)**(sqrt(x)/(2*sqrt(x) + 1)) \
+        *(2*sqrt(x) + 1)**(1/(2*sqrt(x) + 1)) - 2*sqrt(x) - 1) == 0
+
+
+@XFAIL
+def test_L9():
+    z = symbols('z', complex=True)
+    assert simplify(2**(1 - z)*gamma(z)*zeta(z)*cos(z*pi/2) - pi**2*zeta(1 - z)) == 0
+
+# M. Equations
+
+
+@XFAIL
+def test_M1():
+    assert Equality(x, 2)/2 + Equality(1, 1) == Equality(x/2 + 1, 2)
+
+
+def test_M2():
+    # The roots of this equation should all be real. Note that this
+    # doesn't test that they are correct.
+    sol = solveset(3*x**3 - 18*x**2 + 33*x - 19, x)
+    assert all(s.expand(complex=True).is_real for s in sol)
+
+
+@XFAIL
+def test_M5():
+    assert solveset(x**6 - 9*x**4 - 4*x**3 + 27*x**2 - 36*x - 23, x) == FiniteSet(2**(1/3) + sqrt(3), 2**(1/3) - sqrt(3), +sqrt(3) - 1/2**(2/3) + I*sqrt(3)/2**(2/3), +sqrt(3) - 1/2**(2/3) - I*sqrt(3)/2**(2/3), -sqrt(3) - 1/2**(2/3) + I*sqrt(3)/2**(2/3), -sqrt(3) - 1/2**(2/3) - I*sqrt(3)/2**(2/3))
+
+
+def test_M6():
+    assert set(solveset(x**7 - 1, x)) == \
+        {cos(n*pi*R(2, 7)) + I*sin(n*pi*R(2, 7)) for n in range(0, 7)}
+    # The paper asks for exp terms, but sin's and cos's may be acceptable;
+    # if the results are simplified, exp terms appear for all but
+    # -sin(pi/14) - I*cos(pi/14) and -sin(pi/14) + I*cos(pi/14) which
+    # will simplify if you apply the transformation foo.rewrite(exp).expand()
+
+
+def test_M7():
+    # TODO: Replace solve with solveset, as of now test fails for solveset
+    sol = solve(x**8 - 8*x**7 + 34*x**6 - 92*x**5 + 175*x**4 - 236*x**3 +
+        226*x**2 - 140*x + 46, x)
+    assert [s.simplify() for s in sol] == [
+        1 - sqrt(-6 - 2*I*sqrt(3 + 4*sqrt(3)))/2,
+        1 + sqrt(-6 - 2*I*sqrt(3 + 4*sqrt(3)))/2,
+        1 - sqrt(-6 + 2*I*sqrt(3 + 4*sqrt(3)))/2,
+        1 + sqrt(-6 + 2*I*sqrt(3 + 4*sqrt (3)))/2,
+        1 - sqrt(-6 + 2*sqrt(-3 + 4*sqrt(3)))/2,
+        1 + sqrt(-6 + 2*sqrt(-3 + 4*sqrt(3)))/2,
+        1 - sqrt(-6 - 2*sqrt(-3 + 4*sqrt(3)))/2,
+        1 + sqrt(-6 - 2*sqrt(-3 + 4*sqrt(3)))/2]
+
+
+@XFAIL  # There are an infinite number of solutions.
+def test_M8():
+    x = Symbol('x')
+    z = symbols('z', complex=True)
+    assert solveset(exp(2*x) + 2*exp(x) + 1 - z, x, S.Reals) == \
+        FiniteSet(log(1 + z - 2*sqrt(z))/2, log(1 + z + 2*sqrt(z))/2)
+    # This one could be simplified better (the 1/2 could be pulled into the log
+    # as a sqrt, and the function inside the log can be factored as a square,
+    # giving [log(sqrt(z) - 1), log(sqrt(z) + 1)]). Also, there should be an
+    # infinite number of solutions.
+    # x = {log(sqrt(z) - 1), log(sqrt(z) + 1) + i pi} [+ n 2 pi i, + n 2 pi i]
+    # where n is an arbitrary integer.  See url of detailed output above.
+
+
+@XFAIL
+def test_M9():
+    # x = symbols('x')
+    raise NotImplementedError("solveset(exp(2-x**2)-exp(-x),x) has complex solutions.")
+
+
+def test_M10():
+    # TODO: Replace solve with solveset, as of now test fails for solveset
+    assert solve(exp(x) - x, x) == [-LambertW(-1)]
+
+
+@XFAIL
+def test_M11():
+    assert solveset(x**x - x, x) == FiniteSet(-1, 1)
+
+
+def test_M12():
+    # TODO: x = [-1, 2*(+/-asinh(1)*I + n*pi}, 3*(pi/6 + n*pi/3)]
+    # TODO: Replace solve with solveset, as of now test fails for solveset
+    assert solve((x + 1)*(sin(x)**2 + 1)**2*cos(3*x)**3, x) == [
+        -1, pi/6, pi/2,
+           - I*log(1 + sqrt(2)),      I*log(1 + sqrt(2)),
+        pi - I*log(1 + sqrt(2)), pi + I*log(1 + sqrt(2)),
+    ]
+
+
+@XFAIL
+def test_M13():
+    n = Dummy('n')
+    assert solveset_real(sin(x) - cos(x), x) == ImageSet(Lambda(n, n*pi - pi*R(7, 4)), S.Integers)
+
+
+@XFAIL
+def test_M14():
+    n = Dummy('n')
+    assert solveset_real(tan(x) - 1, x) == ImageSet(Lambda(n, n*pi + pi/4), S.Integers)
+
+
+def test_M15():
+    n = Dummy('n')
+    got = solveset(sin(x) - S.Half)
+    assert any(got.dummy_eq(i) for i in (
+        Union(ImageSet(Lambda(n, 2*n*pi + pi/6), S.Integers),
+        ImageSet(Lambda(n, 2*n*pi + pi*R(5, 6)), S.Integers)),
+        Union(ImageSet(Lambda(n, 2*n*pi + pi*R(5, 6)), S.Integers),
+        ImageSet(Lambda(n, 2*n*pi + pi/6), S.Integers))))
+
+
+@XFAIL
+def test_M16():
+    n = Dummy('n')
+    assert solveset(sin(x) - tan(x), x) == ImageSet(Lambda(n, n*pi), S.Integers)
+
+
+@XFAIL
+def test_M17():
+    assert solveset_real(asin(x) - atan(x), x) == FiniteSet(0)
+
+
+@XFAIL
+def test_M18():
+    assert solveset_real(acos(x) - atan(x), x) == FiniteSet(sqrt((sqrt(5) - 1)/2))
+
+
+def test_M19():
+    # TODO: Replace solve with solveset, as of now test fails for solveset
+    assert solve((x - 2)/x**R(1, 3), x) == [2]
+
+
+def test_M20():
+    assert solveset(sqrt(x**2 + 1) - x + 2, x) == EmptySet
+
+
+def test_M21():
+    assert solveset(x + sqrt(x) - 2) == FiniteSet(1)
+
+
+def test_M22():
+    assert solveset(2*sqrt(x) + 3*x**R(1, 4) - 2) == FiniteSet(R(1, 16))
+
+
+def test_M23():
+    x = symbols('x', complex=True)
+    # TODO: Replace solve with solveset, as of now test fails for solveset
+    assert solve(x - 1/sqrt(1 + x**2)) == [
+        -I*sqrt(S.Half + sqrt(5)/2), sqrt(Rational(-1, 2) + sqrt(5)/2)]
+
+
+def test_M24():
+    # TODO: Replace solve with solveset, as of now test fails for solveset
+    solution = solve(1 - binomial(m, 2)*2**k, k)
+    answer = log(2/(m*(m - 1)), 2)
+    assert solution[0].expand() == answer.expand()
+
+
+def test_M25():
+    a, b, c, d = symbols(':d', positive=True)
+    x = symbols('x')
+    # TODO: Replace solve with solveset, as of now test fails for solveset
+    assert solve(a*b**x - c*d**x, x)[0].expand() == (log(c/a)/log(b/d)).expand()
+
+
+def test_M26():
+    # TODO: Replace solve with solveset, as of now test fails for solveset
+    assert solve(sqrt(log(x)) - log(sqrt(x))) == [1, exp(4)]
+
+
+def test_M27():
+    x = symbols('x', real=True)
+    b = symbols('b', real=True)
+    with assuming(Q.is_true(sin(cos(1/E**2) + 1) + b > 0)):
+        # TODO: Replace solve with solveset
+        solve(log(acos(asin(x**R(2, 3) - b) - 1)) + 2, x) == [-b - sin(1 + cos(1/E**2))**R(3/2), b + sin(1 + cos(1/E**2))**R(3/2)]
+
+
+@XFAIL
+def test_M28():
+    assert solveset_real(5*x + exp((x - 5)/2) - 8*x**3, x, assume=Q.real(x)) == [-0.784966, -0.016291, 0.802557]
+
+
+def test_M29():
+    x = symbols('x')
+    assert solveset(abs(x - 1) - 2, domain=S.Reals) == FiniteSet(-1, 3)
+
+
+def test_M30():
+    # TODO: Replace solve with solveset, as of now
+    # solveset doesn't supports assumptions
+    # assert solve(abs(2*x + 5) - abs(x - 2),x, assume=Q.real(x)) == [-1, -7]
+    assert solveset_real(abs(2*x + 5) - abs(x - 2), x) == FiniteSet(-1, -7)
+
+
+def test_M31():
+    # TODO: Replace solve with solveset, as of now
+    # solveset doesn't supports assumptions
+    # assert solve(1 - abs(x) - max(-x - 2, x - 2),x, assume=Q.real(x)) == [-3/2, 3/2]
+    assert solveset_real(1 - abs(x) - Max(-x - 2, x - 2), x) == FiniteSet(R(-3, 2), R(3, 2))
+
+
+@XFAIL
+def test_M32():
+    # TODO: Replace solve with solveset, as of now
+    # solveset doesn't supports assumptions
+    assert solveset_real(Max(2 - x**2, x)- Max(-x, (x**3)/9), x) == FiniteSet(-1, 3)
+
+
+@XFAIL
+def test_M33():
+    # TODO: Replace solve with solveset, as of now
+    # solveset doesn't supports assumptions
+
+    # Second answer can be written in another form. The second answer is the root of x**3 + 9*x**2 - 18 = 0 in the interval (-2, -1).
+    assert solveset_real(Max(2 - x**2, x) - x**3/9, x) == FiniteSet(-3, -1.554894, 3)
+
+
+@XFAIL
+def test_M34():
+    z = symbols('z', complex=True)
+    assert solveset((1 + I) * z + (2 - I) * conjugate(z) + 3*I, z) == FiniteSet(2 + 3*I)
+
+
+def test_M35():
+    x, y = symbols('x y', real=True)
+    assert linsolve((3*x - 2*y - I*y + 3*I).as_real_imag(), y, x) == FiniteSet((3, 2))
+
+
+def test_M36():
+    # TODO: Replace solve with solveset, as of now
+    # solveset doesn't supports solving for function
+    # assert solve(f**2 + f - 2, x) == [Eq(f(x), 1), Eq(f(x), -2)]
+    assert solveset(f(x)**2 + f(x) - 2, f(x)) == FiniteSet(-2, 1)
+
+
+def test_M37():
+    assert linsolve([x + y + z - 6, 2*x + y + 2*z - 10, x + 3*y + z - 10 ], x, y, z) == \
+        FiniteSet((-z + 4, 2, z))
+
+
+def test_M38():
+    a, b, c = symbols('a, b, c')
+    domain = FracField([a, b, c], ZZ).to_domain()
+    ring = PolyRing('k1:50', domain)
+    (k1, k2, k3, k4, k5, k6, k7, k8, k9, k10,
+    k11, k12, k13, k14, k15, k16, k17, k18, k19, k20,
+    k21, k22, k23, k24, k25, k26, k27, k28, k29, k30,
+    k31, k32, k33, k34, k35, k36, k37, k38, k39, k40,
+    k41, k42, k43, k44, k45, k46, k47, k48, k49) = ring.gens
+
+    system = [
+        -b*k8/a + c*k8/a, -b*k11/a + c*k11/a, -b*k10/a + c*k10/a + k2, -k3 - b*k9/a + c*k9/a,
+        -b*k14/a + c*k14/a, -b*k15/a + c*k15/a, -b*k18/a + c*k18/a - k2, -b*k17/a + c*k17/a,
+        -b*k16/a + c*k16/a + k4, -b*k13/a + c*k13/a - b*k21/a + c*k21/a + b*k5/a - c*k5/a,
+        b*k44/a - c*k44/a, -b*k45/a + c*k45/a, -b*k20/a + c*k20/a, -b*k44/a + c*k44/a,
+        b*k46/a - c*k46/a, b**2*k47/a**2 - 2*b*c*k47/a**2 + c**2*k47/a**2, k3, -k4,
+        -b*k12/a + c*k12/a - a*k6/b + c*k6/b, -b*k19/a + c*k19/a + a*k7/c - b*k7/c,
+        b*k45/a - c*k45/a, -b*k46/a + c*k46/a, -k48 + c*k48/a + c*k48/b - c**2*k48/(a*b),
+        -k49 + b*k49/a + b*k49/c - b**2*k49/(a*c), a*k1/b - c*k1/b, a*k4/b - c*k4/b,
+        a*k3/b - c*k3/b + k9, -k10 + a*k2/b - c*k2/b, a*k7/b - c*k7/b, -k9, k11,
+        b*k12/a - c*k12/a + a*k6/b - c*k6/b, a*k15/b - c*k15/b, k10 + a*k18/b - c*k18/b,
+        -k11 + a*k17/b - c*k17/b, a*k16/b - c*k16/b, -a*k13/b + c*k13/b + a*k21/b - c*k21/b + a*k5/b - c*k5/b,
+        -a*k44/b + c*k44/b, a*k45/b - c*k45/b, a*k14/c - b*k14/c + a*k20/b - c*k20/b,
+        a*k44/b - c*k44/b, -a*k46/b + c*k46/b, -k47 + c*k47/a + c*k47/b - c**2*k47/(a*b),
+        a*k19/b - c*k19/b, -a*k45/b + c*k45/b, a*k46/b - c*k46/b, a**2*k48/b**2 - 2*a*c*k48/b**2 + c**2*k48/b**2,
+        -k49 + a*k49/b + a*k49/c - a**2*k49/(b*c), k16, -k17, -a*k1/c + b*k1/c,
+        -k16 - a*k4/c + b*k4/c, -a*k3/c + b*k3/c, k18 - a*k2/c + b*k2/c, b*k19/a - c*k19/a - a*k7/c + b*k7/c,
+        -a*k6/c + b*k6/c, -a*k8/c + b*k8/c, -a*k11/c + b*k11/c + k17, -a*k10/c + b*k10/c - k18,
+        -a*k9/c + b*k9/c, -a*k14/c + b*k14/c - a*k20/b + c*k20/b, -a*k13/c + b*k13/c + a*k21/c - b*k21/c - a*k5/c + b*k5/c,
+        a*k44/c - b*k44/c, -a*k45/c + b*k45/c, -a*k44/c + b*k44/c, a*k46/c - b*k46/c,
+        -k47 + b*k47/a + b*k47/c - b**2*k47/(a*c), -a*k12/c + b*k12/c, a*k45/c - b*k45/c,
+        -a*k46/c + b*k46/c, -k48 + a*k48/b + a*k48/c - a**2*k48/(b*c),
+        a**2*k49/c**2 - 2*a*b*k49/c**2 + b**2*k49/c**2, k8, k11, -k15, k10 - k18,
+        -k17, k9, -k16, -k29, k14 - k32, -k21 + k23 - k31, -k24 - k30, -k35, k44,
+        -k45, k36, k13 - k23 + k39, -k20 + k38, k25 + k37, b*k26/a - c*k26/a - k34 + k42,
+        -2*k44, k45, k46, b*k47/a - c*k47/a, k41, k44, -k46, -b*k47/a + c*k47/a,
+        k12 + k24, -k19 - k25, -a*k27/b + c*k27/b - k33, k45, -k46, -a*k48/b + c*k48/b,
+        a*k28/c - b*k28/c + k40, -k45, k46, a*k48/b - c*k48/b, a*k49/c - b*k49/c,
+        -a*k49/c + b*k49/c, -k1, -k4, -k3, k15, k18 - k2, k17, k16, k22, k25 - k7,
+        k24 + k30, k21 + k23 - k31, k28, -k44, k45, -k30 - k6, k20 + k32, k27 + b*k33/a - c*k33/a,
+        k44, -k46, -b*k47/a + c*k47/a, -k36, k31 - k39 - k5, -k32 - k38, k19 - k37,
+        k26 - a*k34/b + c*k34/b - k42, k44, -2*k45, k46, a*k48/b - c*k48/b,
+        a*k35/c - b*k35/c - k41, -k44, k46, b*k47/a - c*k47/a, -a*k49/c + b*k49/c,
+        -k40, k45, -k46, -a*k48/b + c*k48/b, a*k49/c - b*k49/c, k1, k4, k3, -k8,
+        -k11, -k10 + k2, -k9, k37 + k7, -k14 - k38, -k22, -k25 - k37, -k24 + k6,
+        -k13 - k23 + k39, -k28 + b*k40/a - c*k40/a, k44, -k45, -k27, -k44, k46,
+        b*k47/a - c*k47/a, k29, k32 + k38, k31 - k39 + k5, -k12 + k30, k35 - a*k41/b + c*k41/b,
+        -k44, k45, -k26 + k34 + a*k42/c - b*k42/c, k44, k45, -2*k46, -b*k47/a + c*k47/a,
+        -a*k48/b + c*k48/b, a*k49/c - b*k49/c, k33, -k45, k46, a*k48/b - c*k48/b,
+        -a*k49/c + b*k49/c
+        ]
+    solution = {
+        k49: 0, k48: 0, k47: 0, k46: 0, k45: 0, k44: 0, k41: 0, k40: 0,
+        k38: 0, k37: 0, k36: 0, k35: 0, k33: 0, k32: 0, k30: 0, k29: 0,
+        k28: 0, k27: 0, k25: 0, k24: 0, k22: 0, k21: 0, k20: 0, k19: 0,
+        k18: 0, k17: 0, k16: 0, k15: 0, k14: 0, k13: 0, k12: 0, k11: 0,
+        k10: 0, k9:  0, k8:  0, k7:  0, k6:  0, k5:  0, k4:  0, k3:  0,
+        k2:  0, k1:  0,
+        k34: b/c*k42, k31: k39, k26: a/c*k42, k23: k39
+    }
+    assert solve_lin_sys(system, ring) == solution
+
+
+def test_M39():
+    x, y, z = symbols('x y z', complex=True)
+    # TODO: Replace solve with solveset, as of now
+    # solveset doesn't supports non-linear multivariate
+    assert solve([x**2*y + 3*y*z - 4, -3*x**2*z + 2*y**2 + 1, 2*y*z**2 - z**2 - 1 ]) ==\
+            [{y: 1, z: 1, x: -1}, {y: 1, z: 1, x: 1},\
+             {y: sqrt(2)*I, z: R(1,3) - sqrt(2)*I/3, x: -sqrt(-1 - sqrt(2)*I)},\
+             {y: sqrt(2)*I, z: R(1,3) - sqrt(2)*I/3, x: sqrt(-1 - sqrt(2)*I)},\
+             {y: -sqrt(2)*I, z: R(1,3) + sqrt(2)*I/3, x: -sqrt(-1 + sqrt(2)*I)},\
+             {y: -sqrt(2)*I, z: R(1,3) + sqrt(2)*I/3, x: sqrt(-1 + sqrt(2)*I)}]
+
+# N. Inequalities
+
+
+def test_N1():
+    assert ask(Q.is_true(E**pi > pi**E))
+
+
+@XFAIL
+def test_N2():
+    x = symbols('x', real=True)
+    assert ask(Q.is_true(x**4 - x + 1 > 0)) is True
+    assert ask(Q.is_true(x**4 - x + 1 > 1)) is False
+
+
+@XFAIL
+def test_N3():
+    x = symbols('x', real=True)
+    assert ask(Q.is_true(And(Lt(-1, x), Lt(x, 1))), Q.is_true(abs(x) < 1 ))
+
+@XFAIL
+def test_N4():
+    x, y = symbols('x y', real=True)
+    assert ask(Q.is_true(2*x**2 > 2*y**2), Q.is_true((x > y) & (y > 0))) is True
+
+
+@XFAIL
+def test_N5():
+    x, y, k = symbols('x y k', real=True)
+    assert ask(Q.is_true(k*x**2 > k*y**2), Q.is_true((x > y) & (y > 0) & (k > 0))) is True
+
+
+@XFAIL
+def test_N6():
+    x, y, k, n = symbols('x y k n', real=True)
+    assert ask(Q.is_true(k*x**n > k*y**n), Q.is_true((x > y) & (y > 0) & (k > 0) & (n > 0))) is True
+
+
+@XFAIL
+def test_N7():
+    x, y = symbols('x y', real=True)
+    assert ask(Q.is_true(y > 0), Q.is_true((x > 1) & (y >= x - 1))) is True
+
+
+@XFAIL
+def test_N8():
+    x, y, z = symbols('x y z', real=True)
+    assert ask(Q.is_true((x == y) & (y == z)),
+               Q.is_true((x >= y) & (y >= z) & (z >= x)))
+
+
+def test_N9():
+    x = Symbol('x')
+    assert solveset(abs(x - 1) > 2, domain=S.Reals) == Union(Interval(-oo, -1, False, True),
+                                             Interval(3, oo, True))
+
+
+def test_N10():
+    x = Symbol('x')
+    p = (x - 1)*(x - 2)*(x - 3)*(x - 4)*(x - 5)
+    assert solveset(expand(p) < 0, domain=S.Reals) == Union(Interval(-oo, 1, True, True),
+                                            Interval(2, 3, True, True),
+                                            Interval(4, 5, True, True))
+
+
+def test_N11():
+    x = Symbol('x')
+    assert solveset(6/(x - 3) <= 3, domain=S.Reals) == Union(Interval(-oo, 3, True, True), Interval(5, oo))
+
+
+def test_N12():
+    x = Symbol('x')
+    assert solveset(sqrt(x) < 2, domain=S.Reals) == Interval(0, 4, False, True)
+
+
+def test_N13():
+    x = Symbol('x')
+    assert solveset(sin(x) < 2, domain=S.Reals) == S.Reals
+
+
+@XFAIL
+def test_N14():
+    x = Symbol('x')
+    # Gives 'Union(Interval(Integer(0), Mul(Rational(1, 2), pi), false, true),
+    #        Interval(Mul(Rational(1, 2), pi), Mul(Integer(2), pi), true, false))'
+    # which is not the correct answer, but the provided also seems wrong.
+    assert solveset(sin(x) < 1, x, domain=S.Reals) == Union(Interval(-oo, pi/2, True, True),
+                                         Interval(pi/2, oo, True, True))
+
+
+def test_N15():
+    r, t = symbols('r t')
+    # raises NotImplementedError: only univariate inequalities are supported
+    solveset(abs(2*r*(cos(t) - 1) + 1) <= 1, r, S.Reals)
+
+
+def test_N16():
+    r, t = symbols('r t')
+    solveset((r**2)*((cos(t) - 4)**2)*sin(t)**2 < 9, r, S.Reals)
+
+
+@XFAIL
+def test_N17():
+    # currently only univariate inequalities are supported
+    assert solveset((x + y > 0, x - y < 0), (x, y)) == (abs(x) < y)
+
+
+def test_O1():
+    M = Matrix((1 + I, -2, 3*I))
+    assert sqrt(expand(M.dot(M.H))) == sqrt(15)
+
+
+def test_O2():
+    assert Matrix((2, 2, -3)).cross(Matrix((1, 3, 1))) == Matrix([[11],
+                                                                  [-5],
+                                                                  [4]])
+
+# The vector module has no way of representing vectors symbolically (without
+# respect to a basis)
+@XFAIL
+def test_O3():
+    # assert (va ^ vb) | (vc ^ vd) == -(va | vc)*(vb | vd) + (va | vd)*(vb | vc)
+    raise NotImplementedError("""The vector module has no way of representing
+        vectors symbolically (without respect to a basis)""")
+
+def test_O4():
+    from sympy.vector import CoordSys3D, Del
+    N = CoordSys3D("N")
+    delop = Del()
+    i, j, k = N.base_vectors()
+    x, y, z = N.base_scalars()
+    F = i*(x*y*z) + j*((x*y*z)**2) + k*((y**2)*(z**3))
+    assert delop.cross(F).doit() == (-2*x**2*y**2*z + 2*y*z**3)*i + x*y*j + (2*x*y**2*z**2 - x*z)*k
+
+@XFAIL
+def test_O5():
+    #assert grad|(f^g)-g|(grad^f)+f|(grad^g)  == 0
+    raise NotImplementedError("""The vector module has no way of representing
+        vectors symbolically (without respect to a basis)""")
+
+#testO8-O9 MISSING!!
+
+
+def test_O10():
+    L = [Matrix([2, 3, 5]), Matrix([3, 6, 2]), Matrix([8, 3, 6])]
+    assert GramSchmidt(L) == [Matrix([
+                              [2],
+                              [3],
+                              [5]]),
+                              Matrix([
+                              [R(23, 19)],
+                              [R(63, 19)],
+                              [R(-47, 19)]]),
+                              Matrix([
+                              [R(1692, 353)],
+                              [R(-1551, 706)],
+                              [R(-423, 706)]])]
+
+
+def test_P1():
+    assert Matrix(3, 3, lambda i, j: j - i).diagonal(-1) == Matrix(
+        1, 2, [-1, -1])
+
+
+def test_P2():
+    M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
+    M.row_del(1)
+    M.col_del(2)
+    assert M == Matrix([[1, 2],
+                        [7, 8]])
+
+
+def test_P3():
+    A = Matrix([
+        [11, 12, 13, 14],
+        [21, 22, 23, 24],
+        [31, 32, 33, 34],
+        [41, 42, 43, 44]])
+
+    A11 = A[0:3, 1:4]
+    A12 = A[(0, 1, 3), (2, 0, 3)]
+    A21 = A
+    A221 = -A[0:2, 2:4]
+    A222 = -A[(3, 0), (2, 1)]
+    A22 = BlockMatrix([[A221, A222]]).T
+    rows = [[-A11, A12], [A21, A22]]
+    raises(ValueError, lambda: BlockMatrix(rows))
+    B = Matrix(rows)
+    assert B == Matrix([
+        [-12, -13, -14, 13, 11, 14],
+        [-22, -23, -24, 23, 21, 24],
+        [-32, -33, -34, 43, 41, 44],
+        [11, 12, 13, 14, -13, -23],
+        [21, 22, 23, 24, -14, -24],
+        [31, 32, 33, 34, -43, -13],
+        [41, 42, 43, 44, -42, -12]])
+
+
+@XFAIL
+def test_P4():
+    raise NotImplementedError("Block matrix diagonalization not supported")
+
+
+def test_P5():
+    M = Matrix([[7, 11],
+                [3, 8]])
+    assert  M % 2 == Matrix([[1, 1],
+                             [1, 0]])
+
+
+def test_P6():
+    M = Matrix([[cos(x), sin(x)],
+                [-sin(x), cos(x)]])
+    assert M.diff(x, 2) == Matrix([[-cos(x), -sin(x)],
+                                   [sin(x), -cos(x)]])
+
+
+def test_P7():
+    M = Matrix([[x, y]])*(
+        z*Matrix([[1, 3, 5],
+                  [2, 4, 6]]) + Matrix([[7, -9, 11],
+                                        [-8, 10, -12]]))
+    assert M == Matrix([[x*(z + 7) + y*(2*z - 8), x*(3*z - 9) + y*(4*z + 10),
+                         x*(5*z + 11) + y*(6*z - 12)]])
+
+
+def test_P8():
+    M = Matrix([[1, -2*I],
+                [-3*I, 4]])
+    assert M.norm(ord=S.Infinity) == 7
+
+
+def test_P9():
+    a, b, c = symbols('a b c', nonzero=True)
+    M = Matrix([[a/(b*c), 1/c, 1/b],
+                [1/c, b/(a*c), 1/a],
+                [1/b, 1/a, c/(a*b)]])
+    assert factor(M.norm('fro')) == (a**2 + b**2 + c**2)/(abs(a)*abs(b)*abs(c))
+
+
+@XFAIL
+def test_P10():
+    M = Matrix([[1, 2 + 3*I],
+                [f(4 - 5*I), 6]])
+    # conjugate(f(4 - 5*i)) is not simplified to f(4+5*I)
+    assert M.H == Matrix([[1, f(4 + 5*I)],
+                          [2 + 3*I, 6]])
+
+
+@XFAIL
+def test_P11():
+    # raises NotImplementedError("Matrix([[x,y],[1,x*y]]).inv()
+    #   not simplifying to extract common factor")
+    assert Matrix([[x, y],
+                   [1, x*y]]).inv() == (1/(x**2 - 1))*Matrix([[x, -1],
+                                                              [-1/y, x/y]])
+
+
+def test_P11_workaround():
+    # This test was changed to inverse method ADJ because it depended on the
+    # specific form of inverse returned from the 'GE' method which has changed.
+    M = Matrix([[x, y], [1, x*y]]).inv('ADJ')
+    c = gcd(tuple(M))
+    assert MatMul(c, M/c, evaluate=False) == MatMul(c, Matrix([
+        [x*y, -y],
+        [ -1,  x]]), evaluate=False)
+
+
+def test_P12():
+    A11 = MatrixSymbol('A11', n, n)
+    A12 = MatrixSymbol('A12', n, n)
+    A22 = MatrixSymbol('A22', n, n)
+    B = BlockMatrix([[A11, A12],
+                     [ZeroMatrix(n, n), A22]])
+    assert block_collapse(B.I) == BlockMatrix([[A11.I, (-1)*A11.I*A12*A22.I],
+                                               [ZeroMatrix(n, n), A22.I]])
+
+
+def test_P13():
+    M = Matrix([[1,     x - 2,                         x - 3],
+                [x - 1, x**2 - 3*x + 6,       x**2 - 3*x - 2],
+                [x - 2, x**2 - 8,       2*(x**2) - 12*x + 14]])
+    L, U, _ = M.LUdecomposition()
+    assert simplify(L) == Matrix([[1,     0,     0],
+                                  [x - 1, 1,     0],
+                                  [x - 2, x - 3, 1]])
+    assert simplify(U) == Matrix([[1, x - 2, x - 3],
+                                  [0,     4, x - 5],
+                                  [0,     0, x - 7]])
+
+
+def test_P14():
+    M = Matrix([[1, 2, 3, 1, 3],
+                [3, 2, 1, 1, 7],
+                [0, 2, 4, 1, 1],
+                [1, 1, 1, 1, 4]])
+    R, _ = M.rref()
+    assert R == Matrix([[1, 0, -1, 0,  2],
+                        [0, 1,  2, 0, -1],
+                        [0, 0,  0, 1,  3],
+                        [0, 0,  0, 0,  0]])
+
+
+def test_P15():
+    M = Matrix([[-1, 3,  7, -5],
+                [4, -2,  1,  3],
+                [2,  4, 15, -7]])
+    assert M.rank() == 2
+
+
+def test_P16():
+    M = Matrix([[2*sqrt(2), 8],
+                [6*sqrt(6), 24*sqrt(3)]])
+    assert M.rank() == 1
+
+
+def test_P17():
+    t = symbols('t', real=True)
+    M=Matrix([
+        [sin(2*t), cos(2*t)],
+        [2*(1 - (cos(t)**2))*cos(t), (1 - 2*(sin(t)**2))*sin(t)]])
+    assert M.rank() == 1
+
+
+def test_P18():
+    M = Matrix([[1,  0, -2, 0],
+                [-2, 1,  0, 3],
+                [-1, 2, -6, 6]])
+    assert M.nullspace() == [Matrix([[2],
+                                     [4],
+                                     [1],
+                                     [0]]),
+                             Matrix([[0],
+                                     [-3],
+                                     [0],
+                                     [1]])]
+
+
+def test_P19():
+    w = symbols('w')
+    M = Matrix([[1,    1,    1,    1],
+                [w,    x,    y,    z],
+                [w**2, x**2, y**2, z**2],
+                [w**3, x**3, y**3, z**3]])
+    assert M.det() == (w**3*x**2*y   - w**3*x**2*z - w**3*x*y**2 + w**3*x*z**2
+                       + w**3*y**2*z - w**3*y*z**2 - w**2*x**3*y + w**2*x**3*z
+                       + w**2*x*y**3 - w**2*x*z**3 - w**2*y**3*z + w**2*y*z**3
+                       + w*x**3*y**2 - w*x**3*z**2 - w*x**2*y**3 + w*x**2*z**3
+                       + w*y**3*z**2 - w*y**2*z**3 - x**3*y**2*z + x**3*y*z**2
+                       + x**2*y**3*z - x**2*y*z**3 - x*y**3*z**2 + x*y**2*z**3
+                       )
+
+
+@XFAIL
+def test_P20():
+    raise NotImplementedError("Matrix minimal polynomial not supported")
+
+
+def test_P21():
+    M = Matrix([[5, -3, -7],
+                [-2, 1,  2],
+                [2, -3, -4]])
+    assert M.charpoly(x).as_expr() == x**3 - 2*x**2 - 5*x + 6
+
+
+def test_P22():
+    d = 100
+    M = (2 - x)*eye(d)
+    assert M.eigenvals() == {-x + 2: d}
+
+
+def test_P23():
+    M = Matrix([
+        [2, 1, 0, 0, 0],
+        [1, 2, 1, 0, 0],
+        [0, 1, 2, 1, 0],
+        [0, 0, 1, 2, 1],
+        [0, 0, 0, 1, 2]])
+    assert M.eigenvals() == {
+        S('1'): 1,
+        S('2'): 1,
+        S('3'): 1,
+        S('sqrt(3) + 2'): 1,
+        S('-sqrt(3) + 2'): 1}
+
+
+def test_P24():
+    M = Matrix([[611,  196, -192,  407,   -8,  -52,  -49,   29],
+                [196,  899,  113, -192,  -71,  -43,   -8,  -44],
+                [-192,  113,  899,  196,   61,   49,    8,   52],
+                [ 407, -192,  196,  611,    8,   44,   59,  -23],
+                [  -8,  -71,   61,    8,  411, -599,  208,  208],
+                [ -52,  -43,   49,   44, -599,  411,  208,  208],
+                [ -49,   -8,    8,   59,  208,  208,   99, -911],
+                [  29,  -44,   52,  -23,  208,  208, -911,   99]])
+    assert M.eigenvals() == {
+        S('0'): 1,
+        S('10*sqrt(10405)'): 1,
+        S('100*sqrt(26) + 510'): 1,
+        S('1000'): 2,
+        S('-100*sqrt(26) + 510'): 1,
+        S('-10*sqrt(10405)'): 1,
+        S('1020'): 1}
+
+
+def test_P25():
+    MF = N(Matrix([[ 611,  196, -192,  407,   -8,  -52,  -49,   29],
+                   [ 196,  899,  113, -192,  -71,  -43,   -8,  -44],
+                   [-192,  113,  899,  196,   61,   49,    8,   52],
+                   [ 407, -192,  196,  611,    8,   44,   59,  -23],
+                   [  -8,  -71,   61,    8,  411, -599,  208,  208],
+                   [ -52,  -43,   49,   44, -599,  411,  208,  208],
+                   [ -49,   -8,    8,   59,  208,  208,   99, -911],
+                   [  29,  -44,   52,  -23,  208,  208, -911,   99]]))
+
+    ev_1 = sorted(MF.eigenvals(multiple=True))
+    ev_2 = sorted(
+        [-1020.0490184299969, 0.0, 0.09804864072151699, 1000.0, 1000.0,
+        1019.9019513592784, 1020.0, 1020.0490184299969])
+
+    for x, y in zip(ev_1, ev_2):
+        assert abs(x - y) < 1e-12
+
+
+def test_P26():
+    a0, a1, a2, a3, a4 = symbols('a0 a1 a2 a3 a4')
+    M = Matrix([[-a4, -a3, -a2, -a1, -a0,  0,  0,  0,  0],
+                [  1,   0,   0,   0,   0,  0,  0,  0,  0],
+                [  0,   1,   0,   0,   0,  0,  0,  0,  0],
+                [  0,   0,   1,   0,   0,  0,  0,  0,  0],
+                [  0,   0,   0,   1,   0,  0,  0,  0,  0],
+                [  0,   0,   0,   0,   0, -1, -1,  0,  0],
+                [  0,   0,   0,   0,   0,  1,  0,  0,  0],
+                [  0,   0,   0,   0,   0,  0,  1, -1, -1],
+                [  0,   0,   0,   0,   0,  0,  0,  1,  0]])
+    assert M.eigenvals(error_when_incomplete=False) == {
+        S('-1/2 - sqrt(3)*I/2'): 2,
+        S('-1/2 + sqrt(3)*I/2'): 2}
+
+
+def test_P27():
+    a = symbols('a')
+    M = Matrix([[a,  0, 0, 0, 0],
+                [0,  0, 0, 0, 1],
+                [0,  0, a, 0, 0],
+                [0,  0, 0, a, 0],
+                [0, -2, 0, 0, 2]])
+
+    assert M.eigenvects() == [
+        (a, 3, [
+            Matrix([1, 0, 0, 0, 0]),
+            Matrix([0, 0, 1, 0, 0]),
+            Matrix([0, 0, 0, 1, 0])
+        ]),
+        (1 - I, 1, [
+            Matrix([0, (1 + I)/2, 0, 0, 1])
+        ]),
+        (1 + I, 1, [
+            Matrix([0, (1 - I)/2, 0, 0, 1])
+        ]),
+    ]
+
+
+@XFAIL
+def test_P28():
+    raise NotImplementedError("Generalized eigenvectors not supported \
+https://github.com/sympy/sympy/issues/5293")
+
+
+@XFAIL
+def test_P29():
+    raise NotImplementedError("Generalized eigenvectors not supported \
+https://github.com/sympy/sympy/issues/5293")
+
+
+def test_P30():
+    M = Matrix([[1,  0,  0,  1, -1],
+                [0,  1, -2,  3, -3],
+                [0,  0, -1,  2, -2],
+                [1, -1,  1,  0,  1],
+                [1, -1,  1, -1,  2]])
+    _, J = M.jordan_form()
+    assert J == Matrix([[-1, 0, 0, 0, 0],
+                        [0,  1, 1, 0, 0],
+                        [0,  0, 1, 0, 0],
+                        [0,  0, 0, 1, 1],
+                        [0,  0, 0, 0, 1]])
+
+
+@XFAIL
+def test_P31():
+    raise NotImplementedError("Smith normal form not implemented")
+
+
+def test_P32():
+    M = Matrix([[1, -2],
+                [2, 1]])
+    assert exp(M).rewrite(cos).simplify() == Matrix([[E*cos(2), -E*sin(2)],
+                                                     [E*sin(2),  E*cos(2)]])
+
+
+def test_P33():
+    w, t = symbols('w t')
+    M = Matrix([[0,    1,      0,   0],
+                [0,    0,      0, 2*w],
+                [0,    0,      0,   1],
+                [0, -2*w, 3*w**2,   0]])
+    assert exp(M*t).rewrite(cos).expand() == Matrix([
+        [1, -3*t + 4*sin(t*w)/w,  6*t*w - 6*sin(t*w), -2*cos(t*w)/w + 2/w],
+        [0,      4*cos(t*w) - 3, -6*w*cos(t*w) + 6*w,          2*sin(t*w)],
+        [0,  2*cos(t*w)/w - 2/w,     -3*cos(t*w) + 4,          sin(t*w)/w],
+        [0,         -2*sin(t*w),        3*w*sin(t*w),            cos(t*w)]])
+
+
+@XFAIL
+def test_P34():
+    a, b, c = symbols('a b c', real=True)
+    M = Matrix([[a, 1, 0, 0, 0, 0],
+                [0, a, 0, 0, 0, 0],
+                [0, 0, b, 0, 0, 0],
+                [0, 0, 0, c, 1, 0],
+                [0, 0, 0, 0, c, 1],
+                [0, 0, 0, 0, 0, c]])
+    # raises exception, sin(M) not supported. exp(M*I) also not supported
+    # https://github.com/sympy/sympy/issues/6218
+    assert sin(M) == Matrix([[sin(a), cos(a), 0, 0, 0, 0],
+                             [0, sin(a), 0, 0, 0, 0],
+                             [0, 0, sin(b), 0, 0, 0],
+                             [0, 0, 0, sin(c), cos(c), -sin(c)/2],
+                             [0, 0, 0, 0, sin(c), cos(c)],
+                             [0, 0, 0, 0, 0, sin(c)]])
+
+
+@XFAIL
+def test_P35():
+    M = pi/2*Matrix([[2, 1, 1],
+                     [2, 3, 2],
+                     [1, 1, 2]])
+    # raises exception, sin(M) not supported. exp(M*I) also not supported
+    # https://github.com/sympy/sympy/issues/6218
+    assert sin(M) == eye(3)
+
+
+@XFAIL
+def test_P36():
+    M = Matrix([[10, 7],
+                [7, 17]])
+    assert sqrt(M) == Matrix([[3, 1],
+                              [1, 4]])
+
+
+def test_P37():
+    M = Matrix([[1, 1, 0],
+                [0, 1, 0],
+                [0, 0, 1]])
+    assert M**S.Half == Matrix([[1, R(1, 2), 0],
+                                        [0, 1,       0],
+                                        [0, 0,       1]])
+
+
+@XFAIL
+def test_P38():
+    M=Matrix([[0, 1, 0],
+              [0, 0, 0],
+              [0, 0, 0]])
+    #raises ValueError: Matrix det == 0; not invertible
+    M**S.Half
+
+
+@XFAIL
+def test_P39():
+    """
+    M=Matrix([
+        [1, 1],
+        [2, 2],
+        [3, 3]])
+    M.SVD()
+    """
+    raise NotImplementedError("Singular value decomposition not implemented")
+
+
+def test_P40():
+    r, t = symbols('r t', real=True)
+    M = Matrix([r*cos(t), r*sin(t)])
+    assert M.jacobian(Matrix([r, t])) == Matrix([[cos(t), -r*sin(t)],
+                                                 [sin(t),  r*cos(t)]])
+
+
+def test_P41():
+    r, t = symbols('r t', real=True)
+    assert hessian(r**2*sin(t),(r,t)) == Matrix([[  2*sin(t),   2*r*cos(t)],
+                                                 [2*r*cos(t), -r**2*sin(t)]])
+
+
+def test_P42():
+    assert wronskian([cos(x), sin(x)], x).simplify() == 1
+
+
+def test_P43():
+    def __my_jacobian(M, Y):
+        return Matrix([M.diff(v).T for v in Y]).T
+    r, t = symbols('r t', real=True)
+    M = Matrix([r*cos(t), r*sin(t)])
+    assert __my_jacobian(M,[r,t]) == Matrix([[cos(t), -r*sin(t)],
+                                             [sin(t),  r*cos(t)]])
+
+
+def test_P44():
+    def __my_hessian(f, Y):
+        V = Matrix([diff(f, v) for v in Y])
+        return  Matrix([V.T.diff(v) for v in Y])
+    r, t = symbols('r t', real=True)
+    assert __my_hessian(r**2*sin(t), (r, t)) == Matrix([
+                                            [  2*sin(t),   2*r*cos(t)],
+                                            [2*r*cos(t), -r**2*sin(t)]])
+
+
+def test_P45():
+    def __my_wronskian(Y, v):
+        M = Matrix([Matrix(Y).T.diff(x, n) for n in range(0, len(Y))])
+        return  M.det()
+    assert __my_wronskian([cos(x), sin(x)], x).simplify() == 1
+
+# Q1-Q6  Tensor tests missing
+
+
+@XFAIL
+def test_R1():
+    i, j, n = symbols('i j n', integer=True, positive=True)
+    xn = MatrixSymbol('xn', n, 1)
+    Sm = Sum((xn[i, 0] - Sum(xn[j, 0], (j, 0, n - 1))/n)**2, (i, 0, n - 1))
+    # sum does not calculate
+    # Unknown result
+    Sm.doit()
+    raise NotImplementedError('Unknown result')
+
+@XFAIL
+def test_R2():
+    m, b = symbols('m b')
+    i, n = symbols('i n', integer=True, positive=True)
+    xn = MatrixSymbol('xn', n, 1)
+    yn = MatrixSymbol('yn', n, 1)
+    f = Sum((yn[i, 0] - m*xn[i, 0] - b)**2, (i, 0, n - 1))
+    f1 = diff(f, m)
+    f2 = diff(f, b)
+    # raises TypeError: solveset() takes at most 2 arguments (3 given)
+    solveset((f1, f2), (m, b), domain=S.Reals)
+
+
+@XFAIL
+def test_R3():
+    n, k = symbols('n k', integer=True, positive=True)
+    sk = ((-1)**k) * (binomial(2*n, k))**2
+    Sm = Sum(sk, (k, 1, oo))
+    T = Sm.doit()
+    T2 = T.combsimp()
+    # returns -((-1)**n*factorial(2*n)
+    #           - (factorial(n))**2)*exp_polar(-I*pi)/(factorial(n))**2
+    assert T2 == (-1)**n*binomial(2*n, n)
+
+
+@XFAIL
+def test_R4():
+# Macsyma indefinite sum test case:
+#(c15) /* Check whether the full Gosper algorithm is implemented
+#   => 1/2^(n + 1) binomial(n, k - 1) */
+#closedform(indefsum(binomial(n, k)/2^n - binomial(n + 1, k)/2^(n + 1), k));
+#Time= 2690 msecs
+#                      (- n + k - 1) binomial(n + 1, k)
+#(d15)               - --------------------------------
+#                                     n
+#                                   2 2  (n + 1)
+#
+#(c16) factcomb(makefact(%));
+#Time= 220 msecs
+#                                 n!
+#(d16)                     ----------------
+#                                n
+#                          2 k! 2  (n - k)!
+# Might be possible after fixing https://github.com/sympy/sympy/pull/1879
+    raise NotImplementedError("Indefinite sum not supported")
+
+
+@XFAIL
+def test_R5():
+    a, b, c, n, k = symbols('a b c n k', integer=True, positive=True)
+    sk = ((-1)**k)*(binomial(a + b, a + k)
+                    *binomial(b + c, b + k)*binomial(c + a, c + k))
+    Sm = Sum(sk, (k, 1, oo))
+    T = Sm.doit()  # hypergeometric series not calculated
+    assert T == factorial(a+b+c)/(factorial(a)*factorial(b)*factorial(c))
+
+
+def test_R6():
+    n, k = symbols('n k', integer=True, positive=True)
+    gn = MatrixSymbol('gn', n + 2, 1)
+    Sm = Sum(gn[k, 0] - gn[k - 1, 0], (k, 1, n + 1))
+    assert Sm.doit() == -gn[0, 0] + gn[n + 1, 0]
+
+
+def test_R7():
+    n, k = symbols('n k', integer=True, positive=True)
+    T = Sum(k**3,(k,1,n)).doit()
+    assert T.factor() == n**2*(n + 1)**2/4
+
+@XFAIL
+def test_R8():
+    n, k = symbols('n k', integer=True, positive=True)
+    Sm = Sum(k**2*binomial(n, k), (k, 1, n))
+    T = Sm.doit() #returns Piecewise function
+    assert T.combsimp() == n*(n + 1)*2**(n - 2)
+
+
+def test_R9():
+    n, k = symbols('n k', integer=True, positive=True)
+    Sm = Sum(binomial(n, k - 1)/k, (k, 1, n + 1))
+    assert Sm.doit().simplify() == (2**(n + 1) - 1)/(n + 1)
+
+
+@XFAIL
+def test_R10():
+    n, m, r, k = symbols('n m r k', integer=True, positive=True)
+    Sm = Sum(binomial(n, k)*binomial(m, r - k), (k, 0, r))
+    T = Sm.doit()
+    T2 = T.combsimp().rewrite(factorial)
+    assert T2 == factorial(m + n)/(factorial(r)*factorial(m + n - r))
+    assert T2 == binomial(m + n, r).rewrite(factorial)
+    # rewrite(binomial) is not working.
+    # https://github.com/sympy/sympy/issues/7135
+    T3 = T2.rewrite(binomial)
+    assert T3 == binomial(m + n, r)
+
+
+@XFAIL
+def test_R11():
+    n, k = symbols('n k', integer=True, positive=True)
+    sk = binomial(n, k)*fibonacci(k)
+    Sm = Sum(sk, (k, 0, n))
+    T = Sm.doit()
+    # Fibonacci simplification not implemented
+    # https://github.com/sympy/sympy/issues/7134
+    assert T == fibonacci(2*n)
+
+
+@XFAIL
+def test_R12():
+    n, k = symbols('n k', integer=True, positive=True)
+    Sm = Sum(fibonacci(k)**2, (k, 0, n))
+    T = Sm.doit()
+    assert T == fibonacci(n)*fibonacci(n + 1)
+
+
+@XFAIL
+def test_R13():
+    n, k = symbols('n k', integer=True, positive=True)
+    Sm = Sum(sin(k*x), (k, 1, n))
+    T = Sm.doit()  # Sum is not calculated
+    assert T.simplify() == cot(x/2)/2 - cos(x*(2*n + 1)/2)/(2*sin(x/2))
+
+
+@XFAIL
+def test_R14():
+    n, k = symbols('n k', integer=True, positive=True)
+    Sm = Sum(sin((2*k - 1)*x), (k, 1, n))
+    T = Sm.doit()  # Sum is not calculated
+    assert T.simplify() == sin(n*x)**2/sin(x)
+
+
+@XFAIL
+def test_R15():
+    n, k = symbols('n k', integer=True, positive=True)
+    Sm = Sum(binomial(n - k, k), (k, 0, floor(n/2)))
+    T = Sm.doit()  # Sum is not calculated
+    assert T.simplify() == fibonacci(n + 1)
+
+
+def test_R16():
+    k = symbols('k', integer=True, positive=True)
+    Sm = Sum(1/k**2 + 1/k**3, (k, 1, oo))
+    assert Sm.doit() == zeta(3) + pi**2/6
+
+
+def test_R17():
+    k = symbols('k', integer=True, positive=True)
+    assert abs(float(Sum(1/k**2 + 1/k**3, (k, 1, oo)))
+               - 2.8469909700078206) < 1e-15
+
+
+def test_R18():
+    k = symbols('k', integer=True, positive=True)
+    Sm = Sum(1/(2**k*k**2), (k, 1, oo))
+    T = Sm.doit()
+    assert T.simplify() == -log(2)**2/2 + pi**2/12
+
+
+@slow
+@XFAIL
+def test_R19():
+    k = symbols('k', integer=True, positive=True)
+    Sm = Sum(1/((3*k + 1)*(3*k + 2)*(3*k + 3)), (k, 0, oo))
+    T = Sm.doit()
+    # assert fails, T not  simplified
+    assert T.simplify() == -log(3)/4 + sqrt(3)*pi/12
+
+
+@XFAIL
+def test_R20():
+    n, k = symbols('n k', integer=True, positive=True)
+    Sm = Sum(binomial(n, 4*k), (k, 0, oo))
+    T = Sm.doit()
+    # assert fails, T not  simplified
+    assert T.simplify() == 2**(n/2)*cos(pi*n/4)/2 + 2**(n - 1)/2
+
+
+@XFAIL
+def test_R21():
+    k = symbols('k', integer=True, positive=True)
+    Sm = Sum(1/(sqrt(k*(k + 1)) * (sqrt(k) + sqrt(k + 1))), (k, 1, oo))
+    T = Sm.doit()  # Sum not calculated
+    assert T.simplify() == 1
+
+
+# test_R22 answer not available in Wester samples
+# Sum(Sum(binomial(n, k)*binomial(n - k, n - 2*k)*x**n*y**(n - 2*k),
+#                 (k, 0, floor(n/2))), (n, 0, oo)) with abs(x*y)<1?
+
+
+@XFAIL
+def test_R23():
+    n, k = symbols('n k', integer=True, positive=True)
+    Sm = Sum(Sum((factorial(n)/(factorial(k)**2*factorial(n - 2*k)))*
+                 (x/y)**k*(x*y)**(n - k), (n, 2*k, oo)), (k, 0, oo))
+    # Missing how to express constraint abs(x*y)<1?
+    T = Sm.doit()  # Sum not calculated
+    assert T == -1/sqrt(x**2*y**2 - 4*x**2 - 2*x*y + 1)
+
+
+def test_R24():
+    m, k = symbols('m k', integer=True, positive=True)
+    Sm = Sum(Product(k/(2*k - 1), (k, 1, m)), (m, 2, oo))
+    assert Sm.doit() == pi/2
+
+
+def test_S1():
+    k = symbols('k', integer=True, positive=True)
+    Pr = Product(gamma(k/3), (k, 1, 8))
+    assert Pr.doit().simplify() == 640*sqrt(3)*pi**3/6561
+
+
+def test_S2():
+    n, k = symbols('n k', integer=True, positive=True)
+    assert Product(k, (k, 1, n)).doit() == factorial(n)
+
+
+def test_S3():
+    n, k = symbols('n k', integer=True, positive=True)
+    assert Product(x**k, (k, 1, n)).doit().simplify() == x**(n*(n + 1)/2)
+
+
+def test_S4():
+    n, k = symbols('n k', integer=True, positive=True)
+    assert Product(1 + 1/k, (k, 1, n -1)).doit().simplify() == n
+
+
+def test_S5():
+    n, k = symbols('n k', integer=True, positive=True)
+    assert (Product((2*k - 1)/(2*k), (k, 1, n)).doit().gammasimp() ==
+            gamma(n + S.Half)/(sqrt(pi)*gamma(n + 1)))
+
+
+@XFAIL
+def test_S6():
+    n, k = symbols('n k', integer=True, positive=True)
+    # Product does not evaluate
+    assert (Product(x**2 -2*x*cos(k*pi/n) + 1, (k, 1, n - 1)).doit().simplify()
+            == (x**(2*n) - 1)/(x**2 - 1))
+
+
+@XFAIL
+def test_S7():
+    k = symbols('k', integer=True, positive=True)
+    Pr = Product((k**3 - 1)/(k**3 + 1), (k, 2, oo))
+    T = Pr.doit()     # Product does not evaluate
+    assert T.simplify() == R(2, 3)
+
+
+@XFAIL
+def test_S8():
+    k = symbols('k', integer=True, positive=True)
+    Pr = Product(1 - 1/(2*k)**2, (k, 1, oo))
+    T = Pr.doit()
+    # Product does not evaluate
+    assert T.simplify() == 2/pi
+
+
+@XFAIL
+def test_S9():
+    k = symbols('k', integer=True, positive=True)
+    Pr = Product(1 + (-1)**(k + 1)/(2*k - 1), (k, 1, oo))
+    T = Pr.doit()
+    # Product produces 0
+    # https://github.com/sympy/sympy/issues/7133
+    assert T.simplify() == sqrt(2)
+
+
+@XFAIL
+def test_S10():
+    k = symbols('k', integer=True, positive=True)
+    Pr = Product((k*(k + 1) + 1 + I)/(k*(k + 1) + 1 - I), (k, 0, oo))
+    T = Pr.doit()
+    # Product does not evaluate
+    assert T.simplify() == -1
+
+
+def test_T1():
+    assert limit((1 + 1/n)**n, n, oo) == E
+    assert limit((1 - cos(x))/x**2, x, 0) == S.Half
+
+
+def test_T2():
+    assert limit((3**x + 5**x)**(1/x), x, oo) == 5
+
+
+def test_T3():
+    assert limit(log(x)/(log(x) + sin(x)), x, oo) == 1
+
+
+def test_T4():
+    assert limit((exp(x*exp(-x)/(exp(-x) + exp(-2*x**2/(x + 1))))
+                 - exp(x))/x, x, oo) == -exp(2)
+
+
+def test_T5():
+    assert  limit(x*log(x)*log(x*exp(x) - x**2)**2/log(log(x**2
+                  + 2*exp(exp(3*x**3*log(x))))), x, oo) == R(1, 3)
+
+
+def test_T6():
+    assert limit(1/n * factorial(n)**(1/n), n, oo) == exp(-1)
+
+
+def test_T7():
+    limit(1/n * gamma(n + 1)**(1/n), n, oo)
+
+
+def test_T8():
+    a, z = symbols('a z', real=True, positive=True)
+    assert limit(gamma(z + a)/gamma(z)*exp(-a*log(z)), z, oo) == 1
+
+
+@XFAIL
+def test_T9():
+    z, k = symbols('z k', real=True, positive=True)
+    # raises NotImplementedError:
+    #           Don't know how to calculate the mrv of '(1, k)'
+    assert limit(hyper((1, k), (1,), z/k), k, oo) == exp(z)
+
+
+@XFAIL
+def test_T10():
+    # No longer raises PoleError, but should return euler-mascheroni constant
+    assert limit(zeta(x) - 1/(x - 1), x, 1) == integrate(-1/x + 1/floor(x), (x, 1, oo))
+
+@XFAIL
+def test_T11():
+    n, k = symbols('n k', integer=True, positive=True)
+    # evaluates to 0
+    assert limit(n**x/(x*product((1 + x/k), (k, 1, n))), n, oo) == gamma(x)
+
+
+def test_T12():
+    x, t = symbols('x t', real=True)
+    # Does not evaluate the limit but returns an expression with erf
+    assert limit(x * integrate(exp(-t**2), (t, 0, x))/(1 - exp(-x**2)),
+                 x, 0) == 1
+
+
+def test_T13():
+    x = symbols('x', real=True)
+    assert [limit(x/abs(x), x, 0, dir='-'),
+            limit(x/abs(x), x, 0, dir='+')] == [-1, 1]
+
+
+def test_T14():
+    x = symbols('x', real=True)
+    assert limit(atan(-log(x)), x, 0, dir='+') == pi/2
+
+
+def test_U1():
+    x = symbols('x', real=True)
+    assert diff(abs(x), x) == sign(x)
+
+
+def test_U2():
+    f = Lambda(x, Piecewise((-x, x < 0), (x, x >= 0)))
+    assert diff(f(x), x) == Piecewise((-1, x < 0), (1, x >= 0))
+
+
+def test_U3():
+    f = Lambda(x, Piecewise((x**2 - 1, x == 1), (x**3, x != 1)))
+    f1 = Lambda(x, diff(f(x), x))
+    assert f1(x) == 3*x**2
+    assert f1(1) == 3
+
+
+@XFAIL
+def test_U4():
+    n = symbols('n', integer=True, positive=True)
+    x = symbols('x', real=True)
+    d = diff(x**n, x, n)
+    assert d.rewrite(factorial) == factorial(n)
+
+
+def test_U5():
+    # issue 6681
+    t = symbols('t')
+    ans = (
+        Derivative(f(g(t)), g(t))*Derivative(g(t), (t, 2)) +
+        Derivative(f(g(t)), (g(t), 2))*Derivative(g(t), t)**2)
+    assert f(g(t)).diff(t, 2) == ans
+    assert ans.doit() == ans
+
+
+def test_U6():
+    h = Function('h')
+    T = integrate(f(y), (y, h(x), g(x)))
+    assert T.diff(x) == (
+        f(g(x))*Derivative(g(x), x) - f(h(x))*Derivative(h(x), x))
+
+
+@XFAIL
+def test_U7():
+    p, t = symbols('p t', real=True)
+    # Exact differential => d(V(P, T)) => dV/dP DP + dV/dT DT
+    # raises ValueError:  Since there is more than one variable in the
+    # expression, the variable(s) of differentiation must be supplied to
+    # differentiate f(p,t)
+    diff(f(p, t))
+
+
+def test_U8():
+    x, y = symbols('x y', real=True)
+    eq = cos(x*y) + x
+    #  If SymPy had implicit_diff() function this hack could be avoided
+    # TODO: Replace solve with solveset, current test fails for solveset
+    assert idiff(y - eq, y, x) == (-y*sin(x*y) + 1)/(x*sin(x*y) + 1)
+
+
+def test_U9():
+    # Wester sample case for Maple:
+    # O29 := diff(f(x, y), x) + diff(f(x, y), y);
+    #                      /d         \   /d         \
+    #                      |-- f(x, y)| + |-- f(x, y)|
+    #                      \dx        /   \dy        /
+    #
+    # O30 := factor(subs(f(x, y) = g(x^2 + y^2), %));
+    #                                2    2
+    #                        2 D(g)(x  + y ) (x + y)
+    x, y = symbols('x y', real=True)
+    su = diff(f(x, y), x) + diff(f(x, y), y)
+    s2 = su.subs(f(x, y), g(x**2 + y**2))
+    s3 = s2.doit().factor()
+    # Subs not performed, s3 = 2*(x + y)*Subs(Derivative(
+    #   g(_xi_1), _xi_1), _xi_1, x**2 + y**2)
+    # Derivative(g(x*2 + y**2), x**2 + y**2) is not valid in SymPy,
+    # and probably will remain that way. You can take derivatives with respect
+    # to other expressions only if they are atomic, like a symbol or a
+    # function.
+    # D operator should be added to SymPy
+    # See https://github.com/sympy/sympy/issues/4719.
+    assert s3 == (x + y)*Subs(Derivative(g(x), x), x, x**2 + y**2)*2
+
+
+def test_U10():
+    # see issue 2519:
+    assert residue((z**3 + 5)/((z**4 - 1)*(z + 1)), z, -1) == R(-9, 4)
+
+@XFAIL
+def test_U11():
+    # assert (2*dx + dz) ^ (3*dx + dy + dz) ^ (dx + dy + 4*dz) == 8*dx ^ dy ^dz
+    raise NotImplementedError
+
+
+@XFAIL
+def test_U12():
+    # Wester sample case:
+    # (c41) /* d(3 x^5 dy /\ dz + 5 x y^2 dz /\ dx + 8 z dx /\ dy)
+    #    => (15 x^4 + 10 x y + 8) dx /\ dy /\ dz */
+    # factor(ext_diff(3*x^5 * dy ~ dz + 5*x*y^2 * dz ~ dx + 8*z * dx ~ dy));
+    #                      4
+    # (d41)              (10 x y + 15 x  + 8) dx dy dz
+    raise NotImplementedError(
+        "External diff of differential form not supported")
+
+
+def test_U13():
+    assert minimum(x**4 - x + 1, x) == -3*2**R(1,3)/8 + 1
+
+
+@XFAIL
+def test_U14():
+    #f = 1/(x**2 + y**2 + 1)
+    #assert [minimize(f), maximize(f)] == [0,1]
+    raise NotImplementedError("minimize(), maximize() not supported")
+
+
+@XFAIL
+def test_U15():
+    raise NotImplementedError("minimize() not supported and also solve does \
+not support multivariate inequalities")
+
+
+@XFAIL
+def test_U16():
+    raise NotImplementedError("minimize() not supported in SymPy and also \
+solve does not support multivariate inequalities")
+
+
+@XFAIL
+def test_U17():
+    raise NotImplementedError("Linear programming, symbolic simplex not \
+supported in SymPy")
+
+
+def test_V1():
+    x = symbols('x', real=True)
+    assert integrate(abs(x), x) == Piecewise((-x**2/2, x <= 0), (x**2/2, True))
+
+
+def test_V2():
+    assert integrate(Piecewise((-x, x < 0), (x, x >= 0)), x
+        ) == Piecewise((-x**2/2, x < 0), (x**2/2, True))
+
+
+def test_V3():
+    assert integrate(1/(x**3 + 2),x).diff().simplify() == 1/(x**3 + 2)
+
+
+def test_V4():
+    assert integrate(2**x/sqrt(1 + 4**x), x) == asinh(2**x)/log(2)
+
+
+@XFAIL
+def test_V5():
+    # Returns (-45*x**2 + 80*x - 41)/(5*sqrt(2*x - 1)*(4*x**2 - 4*x + 1))
+    assert (integrate((3*x - 5)**2/(2*x - 1)**R(7, 2), x).simplify() ==
+            (-41 + 80*x - 45*x**2)/(5*(2*x - 1)**R(5, 2)))
+
+
+@XFAIL
+def test_V6():
+    # returns RootSum(40*_z**2 - 1, Lambda(_i, _i*log(-4*_i + exp(-m*x))))/m
+    assert (integrate(1/(2*exp(m*x) - 5*exp(-m*x)), x) == sqrt(10)*(
+            log(2*exp(m*x) - sqrt(10)) - log(2*exp(m*x) + sqrt(10)))/(20*m))
+
+
+def test_V7():
+    r1 = integrate(sinh(x)**4/cosh(x)**2)
+    assert r1.simplify() == x*R(-3, 2) + sinh(x)**3/(2*cosh(x)) + 3*tanh(x)/2
+
+
+@XFAIL
+def test_V8_V9():
+#Macsyma test case:
+#(c27) /* This example involves several symbolic parameters
+#   => 1/sqrt(b^2 - a^2) log([sqrt(b^2 - a^2) tan(x/2) + a + b]/
+#                            [sqrt(b^2 - a^2) tan(x/2) - a - b])   (a^2 < b^2)
+#      [Gradshteyn and Ryzhik 2.553(3)] */
+#assume(b^2 > a^2)$
+#(c28) integrate(1/(a + b*cos(x)), x);
+#(c29) trigsimp(ratsimp(diff(%, x)));
+#                        1
+#(d29)             ------------
+#                  b cos(x) + a
+    raise NotImplementedError(
+        "Integrate with assumption not supported")
+
+
+def test_V10():
+    assert integrate(1/(3 + 3*cos(x) + 4*sin(x)), x) == log(tan(x/2) + R(3, 4))/4
+
+
+def test_V11():
+    r1 = integrate(1/(4 + 3*cos(x) + 4*sin(x)), x)
+    r2 = factor(r1)
+    assert (logcombine(r2, force=True) ==
+            log(((tan(x/2) + 1)/(tan(x/2) + 7))**R(1, 3)))
+
+
+def test_V12():
+    r1 = integrate(1/(5 + 3*cos(x) + 4*sin(x)), x)
+    assert r1 == -1/(tan(x/2) + 2)
+
+
+@XFAIL
+def test_V13():
+    r1 = integrate(1/(6 + 3*cos(x) + 4*sin(x)), x)
+    # expression not simplified, returns: -sqrt(11)*I*log(tan(x/2) + 4/3
+    #   - sqrt(11)*I/3)/11 + sqrt(11)*I*log(tan(x/2) + 4/3 + sqrt(11)*I/3)/11
+    assert r1.simplify() == 2*sqrt(11)*atan(sqrt(11)*(3*tan(x/2) + 4)/11)/11
+
+
+@slow
+@XFAIL
+def test_V14():
+    r1 = integrate(log(abs(x**2 - y**2)), x)
+    # Piecewise result does not simplify to the desired result.
+    assert (r1.simplify() == x*log(abs(x**2  - y**2))
+                            + y*log(x + y) - y*log(x - y) - 2*x)
+
+
+def test_V15():
+    r1 = integrate(x*acot(x/y), x)
+    assert simplify(r1 - (x*y + (x**2 + y**2)*acot(x/y))/2) == 0
+
+
+@XFAIL
+def test_V16():
+    # Integral not calculated
+    assert integrate(cos(5*x)*Ci(2*x), x) == Ci(2*x)*sin(5*x)/5 - (Si(3*x) + Si(7*x))/10
+
+@XFAIL
+def test_V17():
+    r1 = integrate((diff(f(x), x)*g(x)
+                   - f(x)*diff(g(x), x))/(f(x)**2 - g(x)**2), x)
+    # integral not calculated
+    assert simplify(r1 - (f(x) - g(x))/(f(x) + g(x))/2) == 0
+
+
+@XFAIL
+def test_W1():
+    # The function has a pole at y.
+    # The integral has a Cauchy principal value of zero but SymPy returns -I*pi
+    # https://github.com/sympy/sympy/issues/7159
+    assert integrate(1/(x - y), (x, y - 1, y + 1)) == 0
+
+
+@XFAIL
+def test_W2():
+    # The function has a pole at y.
+    # The integral is divergent but SymPy returns -2
+    # https://github.com/sympy/sympy/issues/7160
+    # Test case in Macsyma:
+    # (c6) errcatch(integrate(1/(x - a)^2, x, a - 1, a + 1));
+    # Integral is divergent
+    assert integrate(1/(x - y)**2, (x, y - 1, y + 1)) is zoo
+
+
+@XFAIL
+@slow
+def test_W3():
+    # integral is not  calculated
+    # https://github.com/sympy/sympy/issues/7161
+    assert integrate(sqrt(x + 1/x - 2), (x, 0, 1)) == R(4, 3)
+
+
+@XFAIL
+@slow
+def test_W4():
+    # integral is not  calculated
+    assert integrate(sqrt(x + 1/x - 2), (x, 1, 2)) == -2*sqrt(2)/3 + R(4, 3)
+
+
+@XFAIL
+@slow
+def test_W5():
+    # integral is not  calculated
+    assert integrate(sqrt(x + 1/x - 2), (x, 0, 2)) == -2*sqrt(2)/3 + R(8, 3)
+
+
+@XFAIL
+@slow
+def test_W6():
+    # integral is not  calculated
+    assert integrate(sqrt(2 - 2*cos(2*x))/2, (x, pi*R(-3, 4), -pi/4)) == sqrt(2)
+
+
+def test_W7():
+    a = symbols('a', real=True, positive=True)
+    r1 = integrate(cos(x)/(x**2 + a**2), (x, -oo, oo))
+    assert r1.simplify() == pi*exp(-a)/a
+
+
+@XFAIL
+def test_W8():
+    # Test case in Mathematica:
+    # In[19]:= Integrate[t^(a - 1)/(1 + t), {t, 0, Infinity},
+    #                    Assumptions -> 0 < a < 1]
+    # Out[19]= Pi Csc[a Pi]
+    raise NotImplementedError(
+        "Integrate with assumption 0 < a < 1 not supported")
+
+
+@XFAIL
+def test_W9():
+    # Integrand with a residue at infinity => -2 pi [sin(pi/5) + sin(2pi/5)]
+    # (principal value)   [Levinson and Redheffer, p. 234] *)
+    r1 = integrate(5*x**3/(1 + x + x**2 + x**3 + x**4), (x, -oo, oo))
+    r2 = r1.doit()
+    assert r2 == -2*pi*(sqrt(-sqrt(5)/8 + 5/8) + sqrt(sqrt(5)/8 + 5/8))
+
+
+@XFAIL
+def test_W10():
+    # integrate(1/[1 + x + x^2 + ... + x^(2 n)], x = -infinity..infinity) =
+    #        2 pi/(2 n + 1) [1 + cos(pi/[2 n + 1])] csc(2 pi/[2 n + 1])
+    # [Levinson and Redheffer, p. 255] => 2 pi/5 [1 + cos(pi/5)] csc(2 pi/5) */
+    r1 = integrate(x/(1 + x + x**2 + x**4), (x, -oo, oo))
+    r2 = r1.doit()
+    assert r2 == 2*pi*(sqrt(5)/4 + 5/4)*csc(pi*R(2, 5))/5
+
+
+@XFAIL
+def test_W11():
+    # integral not calculated
+    assert (integrate(sqrt(1 - x**2)/(1 + x**2), (x, -1, 1)) ==
+            pi*(-1 + sqrt(2)))
+
+
+def test_W12():
+    p = symbols('p', real=True, positive=True)
+    q = symbols('q', real=True)
+    r1 = integrate(x*exp(-p*x**2 + 2*q*x), (x, -oo, oo))
+    assert r1.simplify() == sqrt(pi)*q*exp(q**2/p)/p**R(3, 2)
+
+
+@XFAIL
+def test_W13():
+    # Integral not calculated. Expected result is 2*(Euler_mascheroni_constant)
+    r1 = integrate(1/log(x) + 1/(1 - x) - log(log(1/x)), (x, 0, 1))
+    assert r1 == 2*EulerGamma
+
+
+def test_W14():
+    assert integrate(sin(x)/x*exp(2*I*x), (x, -oo, oo)) == 0
+
+
+@XFAIL
+def test_W15():
+    # integral not calculated
+    assert integrate(log(gamma(x))*cos(6*pi*x), (x, 0, 1)) == R(1, 12)
+
+
+def test_W16():
+    assert integrate((1 + x)**3*legendre_poly(1, x)*legendre_poly(2, x),
+                     (x, -1, 1)) == R(36, 35)
+
+
+def test_W17():
+    a, b = symbols('a b', real=True, positive=True)
+    assert integrate(exp(-a*x)*besselj(0, b*x),
+                 (x, 0, oo)) == 1/(b*sqrt(a**2/b**2 + 1))
+
+
+def test_W18():
+    assert integrate((besselj(1, x)/x)**2, (x, 0, oo)) == 4/(3*pi)
+
+
+@XFAIL
+def test_W19():
+    # Integral not calculated
+    # Expected result is (cos 7 - 1)/7   [Gradshteyn and Ryzhik 6.782(3)]
+    assert integrate(Ci(x)*besselj(0, 2*sqrt(7*x)), (x, 0, oo)) == (cos(7) - 1)/7
+
+
+@XFAIL
+def test_W20():
+    # integral not calculated
+    assert (integrate(x**2*polylog(3, 1/(x + 1)), (x, 0, 1)) ==
+            -pi**2/36 - R(17, 108) + zeta(3)/4 +
+            (-pi**2/2 - 4*log(2) + log(2)**2 + 35/3)*log(2)/9)
+
+
+def test_W21():
+    assert abs(N(integrate(x**2*polylog(3, 1/(x + 1)), (x, 0, 1)))
+        - 0.210882859565594) < 1e-15
+
+
+def test_W22():
+    t, u = symbols('t u', real=True)
+    s = Lambda(x, Piecewise((1, And(x >= 1, x <= 2)), (0, True)))
+    assert integrate(s(t)*cos(t), (t, 0, u)) == Piecewise(
+        (0, u < 0),
+        (-sin(Min(1, u)) + sin(Min(2, u)), True))
+
+
+@slow
+def test_W23():
+    a, b = symbols('a b', real=True, positive=True)
+    r1 = integrate(integrate(x/(x**2 + y**2), (x, a, b)), (y, -oo, oo))
+    assert r1.collect(pi) == pi*(-a + b)
+
+
+def test_W23b():
+    # like W23 but limits are reversed
+    a, b = symbols('a b', real=True, positive=True)
+    r2 = integrate(integrate(x/(x**2 + y**2), (y, -oo, oo)), (x, a, b))
+    assert r2.collect(pi) == pi*(-a + b)
+
+
+@XFAIL
+@slow
+def test_W24():
+    if ON_TRAVIS:
+        skip("Too slow for travis.")
+    # Not that slow, but does not fully evaluate so simplify is slow.
+    # Maybe also require doit()
+    x, y = symbols('x y', real=True)
+    r1 = integrate(integrate(sqrt(x**2 + y**2), (x, 0, 1)), (y, 0, 1))
+    assert (r1 - (sqrt(2) + asinh(1))/3).simplify() == 0
+
+
+@XFAIL
+@slow
+def test_W25():
+    if ON_TRAVIS:
+        skip("Too slow for travis.")
+    a, x, y = symbols('a x y', real=True)
+    i1 = integrate(
+        sin(a)*sin(y)/sqrt(1 - sin(a)**2*sin(x)**2*sin(y)**2),
+        (x, 0, pi/2))
+    i2 = integrate(i1, (y, 0, pi/2))
+    assert (i2 - pi*a/2).simplify() == 0
+
+
+
+def test_W26():
+    x, y = symbols('x y', real=True)
+    assert integrate(integrate(abs(y - x**2), (y, 0, 2)),
+                     (x, -1, 1)) == R(46, 15)
+
+
+def test_W27():
+    a, b, c = symbols('a b c')
+    assert integrate(integrate(integrate(1, (z, 0, c*(1 - x/a - y/b))),
+                               (y, 0, b*(1 - x/a))),
+                     (x, 0, a)) == a*b*c/6
+
+
+def test_X1():
+    v, c = symbols('v c', real=True)
+    assert (series(1/sqrt(1 - (v/c)**2), v, x0=0, n=8) ==
+            5*v**6/(16*c**6) + 3*v**4/(8*c**4) + v**2/(2*c**2) + 1 + O(v**8))
+
+
+def test_X2():
+    v, c = symbols('v c', real=True)
+    s1 = series(1/sqrt(1 - (v/c)**2), v, x0=0, n=8)
+    assert (1/s1**2).series(v, x0=0, n=8) == -v**2/c**2 + 1 + O(v**8)
+
+
+def test_X3():
+    s1 = (sin(x).series()/cos(x).series()).series()
+    s2 = tan(x).series()
+    assert s2 == x + x**3/3 + 2*x**5/15 + O(x**6)
+    assert s1 == s2
+
+
+def test_X4():
+    s1 = log(sin(x)/x).series()
+    assert s1 == -x**2/6 - x**4/180 + O(x**6)
+    assert log(series(sin(x)/x)).series() == s1
+
+
+@XFAIL
+def test_X5():
+    # test case in Mathematica syntax:
+    # In[21]:= (* => [a f'(a d) + g(b d) + integrate(h(c y), y = 0..d)]
+    #       + [a^2 f''(a d) + b g'(b d) + h(c d)] (x - d) *)
+    # In[22]:= D[f[a*x], x] + g[b*x] + Integrate[h[c*y], {y, 0, x}]
+    # Out[22]= g[b x] + Integrate[h[c y], {y, 0, x}] + a f'[a x]
+    # In[23]:= Series[%, {x, d, 1}]
+    # Out[23]= (g[b d] + Integrate[h[c y], {y, 0, d}] + a f'[a d]) +
+    #                                    2                               2
+    #             (h[c d] + b g'[b d] + a  f''[a d]) (-d + x) + O[-d + x]
+    h = Function('h')
+    a, b, c, d = symbols('a b c d', real=True)
+    # series() raises NotImplementedError:
+    # The _eval_nseries method should be added to <class
+    # 'sympy.core.function.Subs'> to give terms up to O(x**n) at x=0
+    series(diff(f(a*x), x) + g(b*x) + integrate(h(c*y), (y, 0, x)),
+           x, x0=d, n=2)
+    # assert missing, until exception is removed
+
+
+def test_X6():
+    # Taylor series of nonscalar objects (noncommutative multiplication)
+    # expected result => (B A - A B) t^2/2 + O(t^3)   [Stanly Steinberg]
+    a, b = symbols('a b', commutative=False, scalar=False)
+    assert (series(exp((a + b)*x) - exp(a*x) * exp(b*x), x, x0=0, n=3) ==
+              x**2*(-a*b/2 + b*a/2) + O(x**3))
+
+
+def test_X7():
+    # => sum( Bernoulli[k]/k! x^(k - 2), k = 1..infinity )
+    #    = 1/x^2 - 1/(2 x) + 1/12 - x^2/720 + x^4/30240 + O(x^6)
+    #    [Levinson and Redheffer, p. 173]
+    assert (series(1/(x*(exp(x) - 1)), x, 0, 7) == x**(-2) - 1/(2*x) +
+            R(1, 12) - x**2/720 + x**4/30240 - x**6/1209600 + O(x**7))
+
+
+def test_X8():
+    # Puiseux series (terms with fractional degree):
+    # => 1/sqrt(x - 3/2 pi) + (x - 3/2 pi)^(3/2) / 12 + O([x - 3/2 pi]^(7/2))
+
+    # see issue 7167:
+    x = symbols('x', real=True)
+    assert (series(sqrt(sec(x)), x, x0=pi*3/2, n=4) ==
+            1/sqrt(x - pi*R(3, 2)) + (x - pi*R(3, 2))**R(3, 2)/12 +
+            (x - pi*R(3, 2))**R(7, 2)/160 + O((x - pi*R(3, 2))**4, (x, pi*R(3, 2))))
+
+
+def test_X9():
+    assert (series(x**x, x, x0=0, n=4) == 1 + x*log(x) + x**2*log(x)**2/2 +
+            x**3*log(x)**3/6 + O(x**4*log(x)**4))
+
+
+def test_X10():
+    z, w = symbols('z w')
+    assert (series(log(sinh(z)) + log(cosh(z + w)), z, x0=0, n=2) ==
+            log(cosh(w)) + log(z) + z*sinh(w)/cosh(w) + O(z**2))
+
+
+def test_X11():
+    z, w = symbols('z w')
+    assert (series(log(sinh(z) * cosh(z + w)), z, x0=0, n=2) ==
+            log(cosh(w)) + log(z) + z*sinh(w)/cosh(w) + O(z**2))
+
+
+@XFAIL
+def test_X12():
+    # Look at the generalized Taylor series around x = 1
+    # Result => (x - 1)^a/e^b [1 - (a + 2 b) (x - 1) / 2 + O((x - 1)^2)]
+    a, b, x = symbols('a b x', real=True)
+    # series returns O(log(x-1)**2)
+    # https://github.com/sympy/sympy/issues/7168
+    assert (series(log(x)**a*exp(-b*x), x, x0=1, n=2) ==
+            (x - 1)**a/exp(b)*(1 - (a + 2*b)*(x - 1)/2 + O((x - 1)**2)))
+
+
+def test_X13():
+    assert series(sqrt(2*x**2 + 1), x, x0=oo, n=1) == sqrt(2)*x + O(1/x, (x, oo))
+
+
+@XFAIL
+def test_X14():
+    # Wallis' product => 1/sqrt(pi n) + ...   [Knopp, p. 385]
+    assert series(1/2**(2*n)*binomial(2*n, n),
+                  n, x==oo, n=1) == 1/(sqrt(pi)*sqrt(n)) + O(1/x, (x, oo))
+
+
+@SKIP("https://github.com/sympy/sympy/issues/7164")
+def test_X15():
+    # => 0!/x - 1!/x^2 + 2!/x^3 - 3!/x^4 + O(1/x^5)   [Knopp, p. 544]
+    x, t = symbols('x t', real=True)
+    # raises RuntimeError: maximum recursion depth exceeded
+    # https://github.com/sympy/sympy/issues/7164
+    # 2019-02-17: Raises
+    # PoleError:
+    # Asymptotic expansion of Ei around [-oo] is not implemented.
+    e1 = integrate(exp(-t)/t, (t, x, oo))
+    assert (series(e1, x, x0=oo, n=5) ==
+            6/x**4 + 2/x**3 - 1/x**2 + 1/x + O(x**(-5), (x, oo)))
+
+
+def test_X16():
+    # Multivariate Taylor series expansion => 1 - (x^2 + 2 x y + y^2)/2 + O(x^4)
+    assert (series(cos(x + y), x + y, x0=0, n=4) == 1 - (x + y)**2/2 +
+            O(x**4 + x**3*y + x**2*y**2 + x*y**3 + y**4, x, y))
+
+
+@XFAIL
+def test_X17():
+    # Power series (compute the general formula)
+    # (c41) powerseries(log(sin(x)/x), x, 0);
+    # /aquarius/data2/opt/local/macsyma_422/library1/trgred.so being loaded.
+    #              inf
+    #              ====     i1  2 i1          2 i1
+    #              \        (- 1)   2      bern(2 i1) x
+    # (d41)         >        ------------------------------
+    #              /             2 i1 (2 i1)!
+    #              ====
+    #              i1 = 1
+    # fps does not calculate
+    assert fps(log(sin(x)/x)) == \
+        Sum((-1)**k*2**(2*k - 1)*bernoulli(2*k)*x**(2*k)/(k*factorial(2*k)), (k, 1, oo))
+
+
+@XFAIL
+def test_X18():
+    # Power series (compute the general formula). Maple FPS:
+    # > FormalPowerSeries(exp(-x)*sin(x), x = 0);
+    #                        infinity
+    #                         -----    (1/2 k)                k
+    #                          \      2        sin(3/4 k Pi) x
+    #                           )     -------------------------
+    #                          /                 k!
+    #                         -----
+    #
+    # Now, sympy returns
+    #      oo
+    #    _____
+    #    \    `
+    #     \        /          k             k\
+    #      \     k |I*(-1 - I)    I*(-1 + I) |
+    #       \   x *|----------- - -----------|
+    #       /      \     2             2     /
+    #      /    ------------------------------
+    #     /                   k!
+    #    /____,
+    #    k = 0
+    k = Dummy('k')
+    assert fps(exp(-x)*sin(x)) == \
+        Sum(2**(S.Half*k)*sin(R(3, 4)*k*pi)*x**k/factorial(k), (k, 0, oo))
+
+
+@XFAIL
+def test_X19():
+    # (c45) /* Derive an explicit Taylor series solution of y as a function of
+    # x from the following implicit relation:
+    #    y = x - 1 + (x - 1)^2/2 + 2/3 (x - 1)^3 + (x - 1)^4 +
+    #        17/10 (x - 1)^5 + ...
+    #    */
+    # x = sin(y) + cos(y);
+    # Time= 0 msecs
+    # (d45)                   x = sin(y) + cos(y)
+    #
+    # (c46) taylor_revert(%, y, 7);
+    raise NotImplementedError("Solve using series not supported. \
+Inverse Taylor series expansion also not supported")
+
+
+@XFAIL
+def test_X20():
+    # Pade (rational function) approximation => (2 - x)/(2 + x)
+    # > numapprox[pade](exp(-x), x = 0, [1, 1]);
+    # bytes used=9019816, alloc=3669344, time=13.12
+    #                                    1 - 1/2 x
+    #                                    ---------
+    #                                    1 + 1/2 x
+    # mpmath support numeric Pade approximant but there is
+    # no symbolic implementation in SymPy
+    # https://en.wikipedia.org/wiki/Pad%C3%A9_approximant
+    raise NotImplementedError("Symbolic Pade approximant not supported")
+
+
+def test_X21():
+    """
+    Test whether `fourier_series` of x periodical on the [-p, p] interval equals
+    `- (2 p / pi) sum( (-1)^n / n sin(n pi x / p), n = 1..infinity )`.
+    """
+    p = symbols('p', positive=True)
+    n = symbols('n', positive=True, integer=True)
+    s = fourier_series(x, (x, -p, p))
+
+    # All cosine coefficients are equal to 0
+    assert s.an.formula == 0
+
+    # Check for sine coefficients
+    assert s.bn.formula.subs(s.bn.variables[0], 0) == 0
+    assert s.bn.formula.subs(s.bn.variables[0], n) == \
+        -2*p/pi * (-1)**n / n * sin(n*pi*x/p)
+
+
+@XFAIL
+def test_X22():
+    # (c52) /* => p / 2
+    #    - (2 p / pi^2) sum( [1 - (-1)^n] cos(n pi x / p) / n^2,
+    #                        n = 1..infinity ) */
+    # fourier_series(abs(x), x, p);
+    #                       p
+    # (e52)                      a  = -
+    #                       0      2
+    #
+    #                       %nn
+    #                   (2 (- 1)    - 2) p
+    # (e53)                a    = ------------------
+    #                 %nn         2    2
+    #                       %pi  %nn
+    #
+    # (e54)                     b    = 0
+    #                      %nn
+    #
+    # Time= 5290 msecs
+    #            inf           %nn            %pi %nn x
+    #            ====       (2 (- 1)    - 2) cos(---------)
+    #            \                    p
+    #          p  >       -------------------------------
+    #            /               2
+    #            ====                %nn
+    #            %nn = 1                     p
+    # (d54)          ----------------------------------------- + -
+    #                       2                 2
+    #                    %pi
+    raise NotImplementedError("Fourier series not supported")
+
+
+def test_Y1():
+    t = symbols('t', real=True, positive=True)
+    w = symbols('w', real=True)
+    s = symbols('s')
+    F, _, _ = laplace_transform(cos((w - 1)*t), t, s)
+    assert F == s/(s**2 + (w - 1)**2)
+
+
+def test_Y2():
+    t = symbols('t', real=True, positive=True)
+    w = symbols('w', real=True)
+    s = symbols('s')
+    f = inverse_laplace_transform(s/(s**2 + (w - 1)**2), s, t)
+    assert f == cos(t*w - t)
+
+
+def test_Y3():
+    t = symbols('t', real=True, positive=True)
+    w = symbols('w', real=True)
+    s = symbols('s')
+    F, _, _ = laplace_transform(sinh(w*t)*cosh(w*t), t, s)
+    assert F == w/(s**2 - 4*w**2)
+
+
+def test_Y4():
+    t = symbols('t', real=True, positive=True)
+    s = symbols('s')
+    F, _, _ = laplace_transform(erf(3/sqrt(t)), t, s)
+    assert F == (1 - exp(-6*sqrt(s)))/s
+
+
+@XFAIL
+def test_Y5_Y6():
+# Solve y'' + y = 4 [H(t - 1) - H(t - 2)], y(0) = 1, y'(0) = 0 where H is the
+# Heaviside (unit step) function (the RHS describes a pulse of magnitude 4 and
+# duration 1).  See David A. Sanchez, Richard C. Allen, Jr. and Walter T.
+# Kyner, _Differential Equations: An Introduction_, Addison-Wesley Publishing
+# Company, 1983, p. 211.  First, take the Laplace transform of the ODE
+# => s^2 Y(s) - s + Y(s) = 4/s [e^(-s) - e^(-2 s)]
+# where Y(s) is the Laplace transform of y(t)
+    t = symbols('t', real=True, positive=True)
+    s = symbols('s')
+    y = Function('y')
+    F, _, _ = laplace_transform(diff(y(t), t, 2)
+                                + y(t)
+                                - 4*(Heaviside(t - 1)
+                                - Heaviside(t - 2)), t, s)
+    # Laplace transform for diff() not calculated
+    # https://github.com/sympy/sympy/issues/7176
+    assert (F == s**2*LaplaceTransform(y(t), t, s) - s
+            + LaplaceTransform(y(t), t, s) - 4*exp(-s)/s + 4*exp(-2*s)/s)
+# TODO implement second part of test case
+# Now, solve for Y(s) and then take the inverse Laplace transform
+#   => Y(s) = s/(s^2 + 1) + 4 [1/s - s/(s^2 + 1)] [e^(-s) - e^(-2 s)]
+#   => y(t) = cos t + 4 {[1 - cos(t - 1)] H(t - 1) - [1 - cos(t - 2)] H(t - 2)}
+
+
+@XFAIL
+def test_Y7():
+    # What is the Laplace transform of an infinite square wave?
+    # => 1/s + 2 sum( (-1)^n e^(- s n a)/s, n = 1..infinity )
+    #    [Sanchez, Allen and Kyner, p. 213]
+    t = symbols('t', real=True, positive=True)
+    a = symbols('a', real=True)
+    s = symbols('s')
+    F, _, _ = laplace_transform(1 + 2*Sum((-1)**n*Heaviside(t - n*a),
+                                          (n, 1, oo)), t, s)
+    # returns 2*LaplaceTransform(Sum((-1)**n*Heaviside(-a*n + t),
+    #                                (n, 1, oo)), t, s) + 1/s
+    # https://github.com/sympy/sympy/issues/7177
+    assert F == 2*Sum((-1)**n*exp(-a*n*s)/s, (n, 1, oo)) + 1/s
+
+
+@XFAIL
+def test_Y8():
+    assert fourier_transform(1, x, z) == DiracDelta(z)
+
+
+def test_Y9():
+    assert (fourier_transform(exp(-9*x**2), x, z) ==
+            sqrt(pi)*exp(-pi**2*z**2/9)/3)
+
+
+def test_Y10():
+    assert (fourier_transform(abs(x)*exp(-3*abs(x)), x, z).cancel() ==
+            (-8*pi**2*z**2 + 18)/(16*pi**4*z**4 + 72*pi**2*z**2 + 81))
+
+
+@SKIP("https://github.com/sympy/sympy/issues/7181")
+@slow
+def test_Y11():
+    # => pi cot(pi s)   (0 < Re s < 1)   [Gradshteyn and Ryzhik 17.43(5)]
+    x, s = symbols('x s')
+    # raises RuntimeError: maximum recursion depth exceeded
+    # https://github.com/sympy/sympy/issues/7181
+    # Update 2019-02-17 raises:
+    # TypeError: cannot unpack non-iterable MellinTransform object
+    F, _, _ =  mellin_transform(1/(1 - x), x, s)
+    assert F == pi*cot(pi*s)
+
+
+@XFAIL
+def test_Y12():
+    # => 2^(s - 4) gamma(s/2)/gamma(4 - s/2)   (0 < Re s < 1)
+    # [Gradshteyn and Ryzhik 17.43(16)]
+    x, s = symbols('x s')
+    # returns Wrong value -2**(s - 4)*gamma(s/2 - 3)/gamma(-s/2 + 1)
+    # https://github.com/sympy/sympy/issues/7182
+    F, _, _ = mellin_transform(besselj(3, x)/x**3, x, s)
+    assert F == -2**(s - 4)*gamma(s/2)/gamma(-s/2 + 4)
+
+
+@XFAIL
+def test_Y13():
+# Z[H(t - m T)] => z/[z^m (z - 1)]   (H is the Heaviside (unit step) function)                                                 z
+    raise NotImplementedError("z-transform not supported")
+
+
+@XFAIL
+def test_Y14():
+# Z[H(t - m T)] => z/[z^m (z - 1)]   (H is the Heaviside (unit step) function)
+    raise NotImplementedError("z-transform not supported")
+
+
+def test_Z1():
+    r = Function('r')
+    assert (rsolve(r(n + 2) - 2*r(n + 1) + r(n) - 2, r(n),
+                   {r(0): 1, r(1): m}).simplify() == n**2 + n*(m - 2) + 1)
+
+
+def test_Z2():
+    r = Function('r')
+    assert (rsolve(r(n) - (5*r(n - 1) - 6*r(n - 2)), r(n), {r(0): 0, r(1): 1})
+            == -2**n + 3**n)
+
+
+def test_Z3():
+    # => r(n) = Fibonacci[n + 1]   [Cohen, p. 83]
+    r = Function('r')
+    # recurrence solution is correct, Wester expects it to be simplified to
+    # fibonacci(n+1), but that is quite hard
+    expected = ((S(1)/2 - sqrt(5)/2)**n*(S(1)/2 - sqrt(5)/10)
+              + (S(1)/2 + sqrt(5)/2)**n*(sqrt(5)/10 + S(1)/2))
+    sol = rsolve(r(n) - (r(n - 1) + r(n - 2)), r(n), {r(1): 1, r(2): 2})
+    assert sol == expected
+
+
+@XFAIL
+def test_Z4():
+# => [c^(n+1) [c^(n+1) - 2 c - 2] + (n+1) c^2 + 2 c - n] / [(c-1)^3 (c+1)]
+#    [Joan Z. Yu and Robert Israel in sci.math.symbolic]
+    r = Function('r')
+    c = symbols('c')
+    # raises ValueError: Polynomial or rational function expected,
+    #     got '(c**2 - c**n)/(c - c**n)
+    s = rsolve(r(n) - ((1 + c - c**(n-1) - c**(n+1))/(1 - c**n)*r(n - 1)
+                   - c*(1 - c**(n-2))/(1 - c**(n-1))*r(n - 2) + 1),
+           r(n), {r(1): 1, r(2): (2 + 2*c + c**2)/(1 + c)})
+    assert (s - (c*(n + 1)*(c*(n + 1) - 2*c - 2) +
+             (n + 1)*c**2 + 2*c - n)/((c-1)**3*(c+1)) == 0)
+
+
+@XFAIL
+def test_Z5():
+    # Second order ODE with initial conditions---solve directly
+    # transform: f(t) = sin(2 t)/8 - t cos(2 t)/4
+    C1, C2 = symbols('C1 C2')
+    # initial conditions not supported, this is a manual workaround
+    # https://github.com/sympy/sympy/issues/4720
+    eq = Derivative(f(x), x, 2) + 4*f(x) - sin(2*x)
+    sol = dsolve(eq, f(x))
+    f0 = Lambda(x, sol.rhs)
+    assert f0(x) == C2*sin(2*x) + (C1 - x/4)*cos(2*x)
+    f1 = Lambda(x, diff(f0(x), x))
+    # TODO: Replace solve with solveset, when it works for solveset
+    const_dict = solve((f0(0), f1(0)))
+    result = f0(x).subs(C1, const_dict[C1]).subs(C2, const_dict[C2])
+    assert result == -x*cos(2*x)/4 + sin(2*x)/8
+    # Result is OK, but ODE solving with initial conditions should be
+    # supported without all this manual work
+    raise NotImplementedError('ODE solving with initial conditions \
+not supported')
+
+
+@XFAIL
+def test_Z6():
+    # Second order ODE with initial conditions---solve  using Laplace
+    # transform: f(t) = sin(2 t)/8 - t cos(2 t)/4
+    t = symbols('t', real=True, positive=True)
+    s = symbols('s')
+    eq = Derivative(f(t), t, 2) + 4*f(t) - sin(2*t)
+    F, _, _ = laplace_transform(eq, t, s)
+    # Laplace transform for diff() not calculated
+    # https://github.com/sympy/sympy/issues/7176
+    assert (F == s**2*LaplaceTransform(f(t), t, s) +
+            4*LaplaceTransform(f(t), t, s) - 2/(s**2 + 4))
+    # rest of test case not implemented
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/timeutils.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/timeutils.py
new file mode 100644
index 0000000000..cef6de95ba
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/timeutils.py
@@ -0,0 +1,76 @@
+"""Simple tools for timing functions' execution, when IPython is not available. """
+
+
+import timeit
+import math
+
+
+_scales = [1e0, 1e3, 1e6, 1e9]
+_units = ['s', 'ms', '\N{GREEK SMALL LETTER MU}s', 'ns']
+
+
+def timed(func, setup="pass", limit=None):
+    """Adaptively measure execution time of a function. """
+    timer = timeit.Timer(func, setup=setup)
+    repeat, number = 3, 1
+
+    for i in range(1, 10):
+        if timer.timeit(number) >= 0.2:
+            break
+        elif limit is not None and number >= limit:
+            break
+        else:
+            number *= 10
+
+    time = min(timer.repeat(repeat, number)) / number
+
+    if time > 0.0:
+        order = min(-int(math.floor(math.log10(time)) // 3), 3)
+    else:
+        order = 3
+
+    return (number, time, time*_scales[order], _units[order])
+
+
+# Code for doing inline timings of recursive algorithms.
+
+def __do_timings():
+    import os
+    res = os.getenv('SYMPY_TIMINGS', '')
+    res = [x.strip() for x in res.split(',')]
+    return set(res)
+
+_do_timings = __do_timings()
+_timestack = None
+
+
+def _print_timestack(stack, level=1):
+    print('-'*level, '%.2f %s%s' % (stack[2], stack[0], stack[3]))
+    for s in stack[1]:
+        _print_timestack(s, level + 1)
+
+
+def timethis(name):
+    def decorator(func):
+        global _do_timings
+        if not name in _do_timings:
+            return func
+
+        def wrapper(*args, **kwargs):
+            from time import time
+            global _timestack
+            oldtimestack = _timestack
+            _timestack = [func.func_name, [], 0, args]
+            t1 = time()
+            r = func(*args, **kwargs)
+            t2 = time()
+            _timestack[2] = t2 - t1
+            if oldtimestack is not None:
+                oldtimestack[1].append(_timestack)
+                _timestack = oldtimestack
+            else:
+                _print_timestack(_timestack)
+                _timestack = None
+            return r
+        return wrapper
+    return decorator
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tmpfiles.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tmpfiles.py
new file mode 100644
index 0000000000..09a406deaa
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/utilities/tmpfiles.py
@@ -0,0 +1,9 @@
+from sympy.utilities.exceptions import SymPyDeprecationWarning
+
+SymPyDeprecationWarning(
+    feature="Import sympy.utilities.tmpfiles",
+    useinstead="Import from sympy.testing.tmpfiles",
+    issue=18095,
+    deprecated_since_version="1.6").warn()
+
+from sympy.testing.tmpfiles import *  # noqa:F401
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/__init__.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/__init__.py
new file mode 100644
index 0000000000..bdf9e615c7
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/__init__.py
@@ -0,0 +1,47 @@
+from sympy.vector.coordsysrect import CoordSys3D, CoordSysCartesian
+from sympy.vector.vector import (Vector, VectorAdd, VectorMul,
+                                 BaseVector, VectorZero, Cross, Dot, cross, dot)
+from sympy.vector.dyadic import (Dyadic, DyadicAdd, DyadicMul,
+                                 BaseDyadic, DyadicZero)
+from sympy.vector.scalar import BaseScalar
+from sympy.vector.deloperator import Del
+from sympy.vector.functions import (express, matrix_to_vector,
+                                    laplacian, is_conservative,
+                                    is_solenoidal, scalar_potential,
+                                    directional_derivative,
+                                    scalar_potential_difference)
+from sympy.vector.point import Point
+from sympy.vector.orienters import (AxisOrienter, BodyOrienter,
+                                    SpaceOrienter, QuaternionOrienter)
+from sympy.vector.operators import Gradient, Divergence, Curl, Laplacian, gradient, curl, divergence
+from sympy.vector.implicitregion import ImplicitRegion
+from sympy.vector.parametricregion import (ParametricRegion, parametric_region_list)
+from sympy.vector.integrals import (ParametricIntegral, vector_integrate)
+
+__all__ = [
+    'Vector', 'VectorAdd', 'VectorMul', 'BaseVector', 'VectorZero', 'Cross',
+    'Dot', 'cross', 'dot',
+
+    'Dyadic', 'DyadicAdd', 'DyadicMul', 'BaseDyadic', 'DyadicZero',
+
+    'BaseScalar',
+
+    'Del',
+
+    'CoordSys3D', 'CoordSysCartesian',
+
+    'express', 'matrix_to_vector', 'laplacian', 'is_conservative',
+    'is_solenoidal', 'scalar_potential', 'directional_derivative',
+    'scalar_potential_difference',
+
+    'Point',
+
+    'AxisOrienter', 'BodyOrienter', 'SpaceOrienter', 'QuaternionOrienter',
+
+    'Gradient', 'Divergence', 'Curl', 'Laplacian', 'gradient', 'curl',
+    'divergence',
+
+    'ParametricRegion', 'parametric_region_list', 'ImplicitRegion',
+
+    'ParametricIntegral', 'vector_integrate',
+]
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/basisdependent.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/basisdependent.py
new file mode 100644
index 0000000000..4b18188a79
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/basisdependent.py
@@ -0,0 +1,358 @@
+from typing import Any, Dict
+
+from sympy.simplify import simplify as simp, trigsimp as tsimp
+from sympy.core.decorators import call_highest_priority, _sympifyit
+from sympy.core.assumptions import StdFactKB
+from sympy import factor as fctr, diff as df, Integral
+from sympy.core import S, Add, Mul
+from sympy.core.expr import Expr
+
+
+class BasisDependent(Expr):
+    """
+    Super class containing functionality common to vectors and
+    dyadics.
+    Named so because the representation of these quantities in
+    sympy.vector is dependent on the basis they are expressed in.
+    """
+
+    @call_highest_priority('__radd__')
+    def __add__(self, other):
+        return self._add_func(self, other)
+
+    @call_highest_priority('__add__')
+    def __radd__(self, other):
+        return self._add_func(other, self)
+
+    @call_highest_priority('__rsub__')
+    def __sub__(self, other):
+        return self._add_func(self, -other)
+
+    @call_highest_priority('__sub__')
+    def __rsub__(self, other):
+        return self._add_func(other, -self)
+
+    @_sympifyit('other', NotImplemented)
+    @call_highest_priority('__rmul__')
+    def __mul__(self, other):
+        return self._mul_func(self, other)
+
+    @_sympifyit('other', NotImplemented)
+    @call_highest_priority('__mul__')
+    def __rmul__(self, other):
+        return self._mul_func(other, self)
+
+    def __neg__(self):
+        return self._mul_func(S.NegativeOne, self)
+
+    @_sympifyit('other', NotImplemented)
+    @call_highest_priority('__rtruediv__')
+    def __truediv__(self, other):
+        return self._div_helper(other)
+
+    @call_highest_priority('__truediv__')
+    def __rtruediv__(self, other):
+        return TypeError("Invalid divisor for division")
+
+    def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):
+        """
+        Implements the SymPy evalf routine for this quantity.
+
+        evalf's documentation
+        =====================
+
+        """
+        options = {'subs':subs, 'maxn':maxn, 'chop':chop, 'strict':strict,
+                'quad':quad, 'verbose':verbose}
+        vec = self.zero
+        for k, v in self.components.items():
+            vec += v.evalf(n, **options) * k
+        return vec
+
+    evalf.__doc__ += Expr.evalf.__doc__  # type: ignore
+
+    n = evalf
+
+    def simplify(self, **kwargs):
+        """
+        Implements the SymPy simplify routine for this quantity.
+
+        simplify's documentation
+        ========================
+
+        """
+        simp_components = [simp(v, **kwargs) * k for
+                           k, v in self.components.items()]
+        return self._add_func(*simp_components)
+
+    simplify.__doc__ += simp.__doc__  # type: ignore
+
+    def trigsimp(self, **opts):
+        """
+        Implements the SymPy trigsimp routine, for this quantity.
+
+        trigsimp's documentation
+        ========================
+
+        """
+        trig_components = [tsimp(v, **opts) * k for
+                           k, v in self.components.items()]
+        return self._add_func(*trig_components)
+
+    trigsimp.__doc__ += tsimp.__doc__  # type: ignore
+
+    def _eval_simplify(self, **kwargs):
+        return self.simplify(**kwargs)
+
+    def _eval_trigsimp(self, **opts):
+        return self.trigsimp(**opts)
+
+    def _eval_derivative(self, wrt):
+        return self.diff(wrt)
+
+    def _eval_Integral(self, *symbols, **assumptions):
+        integral_components = [Integral(v, *symbols, **assumptions) * k
+                               for k, v in self.components.items()]
+        return self._add_func(*integral_components)
+
+    def as_numer_denom(self):
+        """
+        Returns the expression as a tuple wrt the following
+        transformation -
+
+        expression -> a/b -> a, b
+
+        """
+        return self, S.One
+
+    def factor(self, *args, **kwargs):
+        """
+        Implements the SymPy factor routine, on the scalar parts
+        of a basis-dependent expression.
+
+        factor's documentation
+        ========================
+
+        """
+        fctr_components = [fctr(v, *args, **kwargs) * k for
+                           k, v in self.components.items()]
+        return self._add_func(*fctr_components)
+
+    factor.__doc__ += fctr.__doc__  # type: ignore
+
+    def as_coeff_Mul(self, rational=False):
+        """Efficiently extract the coefficient of a product. """
+        return (S.One, self)
+
+    def as_coeff_add(self, *deps):
+        """Efficiently extract the coefficient of a summation. """
+        l = [x * self.components[x] for x in self.components]
+        return 0, tuple(l)
+
+    def diff(self, *args, **kwargs):
+        """
+        Implements the SymPy diff routine, for vectors.
+
+        diff's documentation
+        ========================
+
+        """
+        for x in args:
+            if isinstance(x, BasisDependent):
+                raise TypeError("Invalid arg for differentiation")
+        diff_components = [df(v, *args, **kwargs) * k for
+                           k, v in self.components.items()]
+        return self._add_func(*diff_components)
+
+    diff.__doc__ += df.__doc__  # type: ignore
+
+    def doit(self, **hints):
+        """Calls .doit() on each term in the Dyadic"""
+        doit_components = [self.components[x].doit(**hints) * x
+                           for x in self.components]
+        return self._add_func(*doit_components)
+
+
+class BasisDependentAdd(BasisDependent, Add):
+    """
+    Denotes sum of basis dependent quantities such that they cannot
+    be expressed as base or Mul instances.
+    """
+
+    def __new__(cls, *args, **options):
+        components = {}
+
+        # Check each arg and simultaneously learn the components
+        for i, arg in enumerate(args):
+            if not isinstance(arg, cls._expr_type):
+                if isinstance(arg, Mul):
+                    arg = cls._mul_func(*(arg.args))
+                elif isinstance(arg, Add):
+                    arg = cls._add_func(*(arg.args))
+                else:
+                    raise TypeError(str(arg) +
+                                    " cannot be interpreted correctly")
+            # If argument is zero, ignore
+            if arg == cls.zero:
+                continue
+            # Else, update components accordingly
+            if hasattr(arg, "components"):
+                for x in arg.components:
+                    components[x] = components.get(x, 0) + arg.components[x]
+
+        temp = list(components.keys())
+        for x in temp:
+            if components[x] == 0:
+                del components[x]
+
+        # Handle case of zero vector
+        if len(components) == 0:
+            return cls.zero
+
+        # Build object
+        newargs = [x * components[x] for x in components]
+        obj = super().__new__(cls, *newargs, **options)
+        if isinstance(obj, Mul):
+            return cls._mul_func(*obj.args)
+        assumptions = {'commutative': True}
+        obj._assumptions = StdFactKB(assumptions)
+        obj._components = components
+        obj._sys = (list(components.keys()))[0]._sys
+
+        return obj
+
+
+class BasisDependentMul(BasisDependent, Mul):
+    """
+    Denotes product of base- basis dependent quantity with a scalar.
+    """
+
+    def __new__(cls, *args, **options):
+        from sympy.vector import Cross, Dot, Curl, Gradient
+        count = 0
+        measure_number = S.One
+        zeroflag = False
+        extra_args = []
+
+        # Determine the component and check arguments
+        # Also keep a count to ensure two vectors aren't
+        # being multiplied
+        for arg in args:
+            if isinstance(arg, cls._zero_func):
+                count += 1
+                zeroflag = True
+            elif arg == S.Zero:
+                zeroflag = True
+            elif isinstance(arg, (cls._base_func, cls._mul_func)):
+                count += 1
+                expr = arg._base_instance
+                measure_number *= arg._measure_number
+            elif isinstance(arg, cls._add_func):
+                count += 1
+                expr = arg
+            elif isinstance(arg, (Cross, Dot, Curl, Gradient)):
+                extra_args.append(arg)
+            else:
+                measure_number *= arg
+        # Make sure incompatible types weren't multiplied
+        if count > 1:
+            raise ValueError("Invalid multiplication")
+        elif count == 0:
+            return Mul(*args, **options)
+        # Handle zero vector case
+        if zeroflag:
+            return cls.zero
+
+        # If one of the args was a VectorAdd, return an
+        # appropriate VectorAdd instance
+        if isinstance(expr, cls._add_func):
+            newargs = [cls._mul_func(measure_number, x) for
+                       x in expr.args]
+            return cls._add_func(*newargs)
+
+        obj = super().__new__(cls, measure_number,
+                              expr._base_instance,
+                              *extra_args,
+                              **options)
+        if isinstance(obj, Add):
+            return cls._add_func(*obj.args)
+        obj._base_instance = expr._base_instance
+        obj._measure_number = measure_number
+        assumptions = {'commutative': True}
+        obj._assumptions = StdFactKB(assumptions)
+        obj._components = {expr._base_instance: measure_number}
+        obj._sys = expr._base_instance._sys
+
+        return obj
+
+    def _sympystr(self, printer):
+        measure_str = printer._print(self._measure_number)
+        if ('(' in measure_str or '-' in measure_str or
+                '+' in measure_str):
+            measure_str = '(' + measure_str + ')'
+        return measure_str + '*' + printer._print(self._base_instance)
+
+
+class BasisDependentZero(BasisDependent):
+    """
+    Class to denote a zero basis dependent instance.
+    """
+    # XXX: Can't type the keys as BaseVector because of cyclic import
+    # problems.
+    components = {}  # type: Dict[Any, Expr]
+
+    def __new__(cls):
+        obj = super().__new__(cls)
+        # Pre-compute a specific hash value for the zero vector
+        # Use the same one always
+        obj._hash = tuple([S.Zero, cls]).__hash__()
+        return obj
+
+    def __hash__(self):
+        return self._hash
+
+    @call_highest_priority('__req__')
+    def __eq__(self, other):
+        return isinstance(other, self._zero_func)
+
+    __req__ = __eq__
+
+    @call_highest_priority('__radd__')
+    def __add__(self, other):
+        if isinstance(other, self._expr_type):
+            return other
+        else:
+            raise TypeError("Invalid argument types for addition")
+
+    @call_highest_priority('__add__')
+    def __radd__(self, other):
+        if isinstance(other, self._expr_type):
+            return other
+        else:
+            raise TypeError("Invalid argument types for addition")
+
+    @call_highest_priority('__rsub__')
+    def __sub__(self, other):
+        if isinstance(other, self._expr_type):
+            return -other
+        else:
+            raise TypeError("Invalid argument types for subtraction")
+
+    @call_highest_priority('__sub__')
+    def __rsub__(self, other):
+        if isinstance(other, self._expr_type):
+            return other
+        else:
+            raise TypeError("Invalid argument types for subtraction")
+
+    def __neg__(self):
+        return self
+
+    def normalize(self):
+        """
+        Returns the normalized version of this vector.
+        """
+        return self
+
+    def _sympystr(self, printer):
+        return '0'
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/coordsysrect.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/coordsysrect.py
new file mode 100644
index 0000000000..7040110642
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/coordsysrect.py
@@ -0,0 +1,1050 @@
+from sympy.utilities.exceptions import SymPyDeprecationWarning
+from sympy.core.basic import Basic
+from sympy.core.compatibility import Callable
+from sympy.core.cache import cacheit
+from sympy.core import S, Dummy, Lambda
+from sympy.core.symbol import Str
+from sympy import symbols, MatrixBase, ImmutableDenseMatrix
+from sympy.solvers import solve
+from sympy.vector.scalar import BaseScalar
+from sympy import eye, trigsimp, ImmutableMatrix as Matrix, sin, cos,\
+    sqrt, diff, Tuple, acos, atan2, simplify
+import sympy.vector
+from sympy.vector.orienters import (Orienter, AxisOrienter, BodyOrienter,
+                                    SpaceOrienter, QuaternionOrienter)
+
+
+def CoordSysCartesian(*args, **kwargs):
+    SymPyDeprecationWarning(
+        feature="CoordSysCartesian",
+        useinstead="CoordSys3D",
+        issue=12865,
+        deprecated_since_version="1.1"
+    ).warn()
+    return CoordSys3D(*args, **kwargs)
+
+
+class CoordSys3D(Basic):
+    """
+    Represents a coordinate system in 3-D space.
+    """
+
+    def __new__(cls, name, transformation=None, parent=None, location=None,
+                rotation_matrix=None, vector_names=None, variable_names=None):
+        """
+        The orientation/location parameters are necessary if this system
+        is being defined at a certain orientation or location wrt another.
+
+        Parameters
+        ==========
+
+        name : str
+            The name of the new CoordSys3D instance.
+
+        transformation : Lambda, Tuple, str
+            Transformation defined by transformation equations or chosen
+            from predefined ones.
+
+        location : Vector
+            The position vector of the new system's origin wrt the parent
+            instance.
+
+        rotation_matrix : SymPy ImmutableMatrix
+            The rotation matrix of the new coordinate system with respect
+            to the parent. In other words, the output of
+            new_system.rotation_matrix(parent).
+
+        parent : CoordSys3D
+            The coordinate system wrt which the orientation/location
+            (or both) is being defined.
+
+        vector_names, variable_names : iterable(optional)
+            Iterables of 3 strings each, with custom names for base
+            vectors and base scalars of the new system respectively.
+            Used for simple str printing.
+
+        """
+
+        name = str(name)
+        Vector = sympy.vector.Vector
+        Point = sympy.vector.Point
+
+        if not isinstance(name, str):
+            raise TypeError("name should be a string")
+
+        if transformation is not None:
+            if (location is not None) or (rotation_matrix is not None):
+                raise ValueError("specify either `transformation` or "
+                                 "`location`/`rotation_matrix`")
+            if isinstance(transformation, (Tuple, tuple, list)):
+                if isinstance(transformation[0], MatrixBase):
+                    rotation_matrix = transformation[0]
+                    location = transformation[1]
+                else:
+                    transformation = Lambda(transformation[0],
+                                            transformation[1])
+            elif isinstance(transformation, Callable):
+                x1, x2, x3 = symbols('x1 x2 x3', cls=Dummy)
+                transformation = Lambda((x1, x2, x3),
+                                        transformation(x1, x2, x3))
+            elif isinstance(transformation, str):
+                transformation = Str(transformation)
+            elif isinstance(transformation, (Str, Lambda)):
+                pass
+            else:
+                raise TypeError("transformation: "
+                                "wrong type {}".format(type(transformation)))
+
+        # If orientation information has been provided, store
+        # the rotation matrix accordingly
+        if rotation_matrix is None:
+            rotation_matrix = ImmutableDenseMatrix(eye(3))
+        else:
+            if not isinstance(rotation_matrix, MatrixBase):
+                raise TypeError("rotation_matrix should be an Immutable" +
+                                "Matrix instance")
+            rotation_matrix = rotation_matrix.as_immutable()
+
+        # If location information is not given, adjust the default
+        # location as Vector.zero
+        if parent is not None:
+            if not isinstance(parent, CoordSys3D):
+                raise TypeError("parent should be a " +
+                                "CoordSys3D/None")
+            if location is None:
+                location = Vector.zero
+            else:
+                if not isinstance(location, Vector):
+                    raise TypeError("location should be a Vector")
+                # Check that location does not contain base
+                # scalars
+                for x in location.free_symbols:
+                    if isinstance(x, BaseScalar):
+                        raise ValueError("location should not contain" +
+                                         " BaseScalars")
+            origin = parent.origin.locate_new(name + '.origin',
+                                              location)
+        else:
+            location = Vector.zero
+            origin = Point(name + '.origin')
+
+        if transformation is None:
+            transformation = Tuple(rotation_matrix, location)
+
+        if isinstance(transformation, Tuple):
+            lambda_transformation = CoordSys3D._compose_rotation_and_translation(
+                transformation[0],
+                transformation[1],
+                parent
+            )
+            r, l = transformation
+            l = l._projections
+            lambda_lame = CoordSys3D._get_lame_coeff('cartesian')
+            lambda_inverse = lambda x, y, z: r.inv()*Matrix(
+                [x-l[0], y-l[1], z-l[2]])
+        elif isinstance(transformation, Str):
+            trname = transformation.name
+            lambda_transformation = CoordSys3D._get_transformation_lambdas(trname)
+            if parent is not None:
+                if parent.lame_coefficients() != (S.One, S.One, S.One):
+                    raise ValueError('Parent for pre-defined coordinate '
+                                 'system should be Cartesian.')
+            lambda_lame = CoordSys3D._get_lame_coeff(trname)
+            lambda_inverse = CoordSys3D._set_inv_trans_equations(trname)
+        elif isinstance(transformation, Lambda):
+            if not CoordSys3D._check_orthogonality(transformation):
+                raise ValueError("The transformation equation does not "
+                                 "create orthogonal coordinate system")
+            lambda_transformation = transformation
+            lambda_lame = CoordSys3D._calculate_lame_coeff(lambda_transformation)
+            lambda_inverse = None
+        else:
+            lambda_transformation = lambda x, y, z: transformation(x, y, z)
+            lambda_lame = CoordSys3D._get_lame_coeff(transformation)
+            lambda_inverse = None
+
+        if variable_names is None:
+            if isinstance(transformation, Lambda):
+                variable_names = ["x1", "x2", "x3"]
+            elif isinstance(transformation, Str):
+                if transformation.name == 'spherical':
+                    variable_names = ["r", "theta", "phi"]
+                elif transformation.name == 'cylindrical':
+                    variable_names = ["r", "theta", "z"]
+                else:
+                    variable_names = ["x", "y", "z"]
+            else:
+                variable_names = ["x", "y", "z"]
+        if vector_names is None:
+            vector_names = ["i", "j", "k"]
+
+        # All systems that are defined as 'roots' are unequal, unless
+        # they have the same name.
+        # Systems defined at same orientation/position wrt the same
+        # 'parent' are equal, irrespective of the name.
+        # This is true even if the same orientation is provided via
+        # different methods like Axis/Body/Space/Quaternion.
+        # However, coincident systems may be seen as unequal if
+        # positioned/oriented wrt different parents, even though
+        # they may actually be 'coincident' wrt the root system.
+        if parent is not None:
+            obj = super().__new__(
+                cls, Str(name), transformation, parent)
+        else:
+            obj = super().__new__(
+                cls, Str(name), transformation)
+        obj._name = name
+        # Initialize the base vectors
+
+        _check_strings('vector_names', vector_names)
+        vector_names = list(vector_names)
+        latex_vects = [(r'\mathbf{\hat{%s}_{%s}}' % (x, name)) for
+                           x in vector_names]
+        pretty_vects = ['%s_%s' % (x, name) for x in vector_names]
+
+        obj._vector_names = vector_names
+
+        v1 = BaseVector(0, obj, pretty_vects[0], latex_vects[0])
+        v2 = BaseVector(1, obj, pretty_vects[1], latex_vects[1])
+        v3 = BaseVector(2, obj, pretty_vects[2], latex_vects[2])
+
+        obj._base_vectors = (v1, v2, v3)
+
+        # Initialize the base scalars
+
+        _check_strings('variable_names', vector_names)
+        variable_names = list(variable_names)
+        latex_scalars = [(r"\mathbf{{%s}_{%s}}" % (x, name)) for
+                         x in variable_names]
+        pretty_scalars = ['%s_%s' % (x, name) for x in variable_names]
+
+        obj._variable_names = variable_names
+        obj._vector_names = vector_names
+
+        x1 = BaseScalar(0, obj, pretty_scalars[0], latex_scalars[0])
+        x2 = BaseScalar(1, obj, pretty_scalars[1], latex_scalars[1])
+        x3 = BaseScalar(2, obj, pretty_scalars[2], latex_scalars[2])
+
+        obj._base_scalars = (x1, x2, x3)
+
+        obj._transformation = transformation
+        obj._transformation_lambda = lambda_transformation
+        obj._lame_coefficients = lambda_lame(x1, x2, x3)
+        obj._transformation_from_parent_lambda = lambda_inverse
+
+        setattr(obj, variable_names[0], x1)
+        setattr(obj, variable_names[1], x2)
+        setattr(obj, variable_names[2], x3)
+
+        setattr(obj, vector_names[0], v1)
+        setattr(obj, vector_names[1], v2)
+        setattr(obj, vector_names[2], v3)
+
+        # Assign params
+        obj._parent = parent
+        if obj._parent is not None:
+            obj._root = obj._parent._root
+        else:
+            obj._root = obj
+
+        obj._parent_rotation_matrix = rotation_matrix
+        obj._origin = origin
+
+        # Return the instance
+        return obj
+
+    def _sympystr(self, printer):
+        return self._name
+
+    def __iter__(self):
+        return iter(self.base_vectors())
+
+    @staticmethod
+    def _check_orthogonality(equations):
+        """
+        Helper method for _connect_to_cartesian. It checks if
+        set of transformation equations create orthogonal curvilinear
+        coordinate system
+
+        Parameters
+        ==========
+
+        equations : Lambda
+            Lambda of transformation equations
+
+        """
+
+        x1, x2, x3 = symbols("x1, x2, x3", cls=Dummy)
+        equations = equations(x1, x2, x3)
+        v1 = Matrix([diff(equations[0], x1),
+                     diff(equations[1], x1), diff(equations[2], x1)])
+
+        v2 = Matrix([diff(equations[0], x2),
+                     diff(equations[1], x2), diff(equations[2], x2)])
+
+        v3 = Matrix([diff(equations[0], x3),
+                     diff(equations[1], x3), diff(equations[2], x3)])
+
+        if any(simplify(i[0] + i[1] + i[2]) == 0 for i in (v1, v2, v3)):
+            return False
+        else:
+            if simplify(v1.dot(v2)) == 0 and simplify(v2.dot(v3)) == 0 \
+                and simplify(v3.dot(v1)) == 0:
+                return True
+            else:
+                return False
+
+    @staticmethod
+    def _set_inv_trans_equations(curv_coord_name):
+        """
+        Store information about inverse transformation equations for
+        pre-defined coordinate systems.
+
+        Parameters
+        ==========
+
+        curv_coord_name : str
+            Name of coordinate system
+
+        """
+        if curv_coord_name == 'cartesian':
+            return lambda x, y, z: (x, y, z)
+
+        if curv_coord_name == 'spherical':
+            return lambda x, y, z: (
+                sqrt(x**2 + y**2 + z**2),
+                acos(z/sqrt(x**2 + y**2 + z**2)),
+                atan2(y, x)
+            )
+        if curv_coord_name == 'cylindrical':
+            return lambda x, y, z: (
+                sqrt(x**2 + y**2),
+                atan2(y, x),
+                z
+            )
+        raise ValueError('Wrong set of parameters.'
+                         'Type of coordinate system is defined')
+
+    def _calculate_inv_trans_equations(self):
+        """
+        Helper method for set_coordinate_type. It calculates inverse
+        transformation equations for given transformations equations.
+
+        """
+        x1, x2, x3 = symbols("x1, x2, x3", cls=Dummy, reals=True)
+        x, y, z = symbols("x, y, z", cls=Dummy)
+
+        equations = self._transformation(x1, x2, x3)
+
+        solved = solve([equations[0] - x,
+                        equations[1] - y,
+                        equations[2] - z], (x1, x2, x3), dict=True)[0]
+        solved = solved[x1], solved[x2], solved[x3]
+        self._transformation_from_parent_lambda = \
+            lambda x1, x2, x3: tuple(i.subs(list(zip((x, y, z), (x1, x2, x3)))) for i in solved)
+
+    @staticmethod
+    def _get_lame_coeff(curv_coord_name):
+        """
+        Store information about Lame coefficients for pre-defined
+        coordinate systems.
+
+        Parameters
+        ==========
+
+        curv_coord_name : str
+            Name of coordinate system
+
+        """
+        if isinstance(curv_coord_name, str):
+            if curv_coord_name == 'cartesian':
+                return lambda x, y, z: (S.One, S.One, S.One)
+            if curv_coord_name == 'spherical':
+                return lambda r, theta, phi: (S.One, r, r*sin(theta))
+            if curv_coord_name == 'cylindrical':
+                return lambda r, theta, h: (S.One, r, S.One)
+            raise ValueError('Wrong set of parameters.'
+                             ' Type of coordinate system is not defined')
+        return CoordSys3D._calculate_lame_coefficients(curv_coord_name)
+
+    @staticmethod
+    def _calculate_lame_coeff(equations):
+        """
+        It calculates Lame coefficients
+        for given transformations equations.
+
+        Parameters
+        ==========
+
+        equations : Lambda
+            Lambda of transformation equations.
+
+        """
+        return lambda x1, x2, x3: (
+                          sqrt(diff(equations(x1, x2, x3)[0], x1)**2 +
+                               diff(equations(x1, x2, x3)[1], x1)**2 +
+                               diff(equations(x1, x2, x3)[2], x1)**2),
+                          sqrt(diff(equations(x1, x2, x3)[0], x2)**2 +
+                               diff(equations(x1, x2, x3)[1], x2)**2 +
+                               diff(equations(x1, x2, x3)[2], x2)**2),
+                          sqrt(diff(equations(x1, x2, x3)[0], x3)**2 +
+                               diff(equations(x1, x2, x3)[1], x3)**2 +
+                               diff(equations(x1, x2, x3)[2], x3)**2)
+                      )
+
+    def _inverse_rotation_matrix(self):
+        """
+        Returns inverse rotation matrix.
+        """
+        return simplify(self._parent_rotation_matrix**-1)
+
+    @staticmethod
+    def _get_transformation_lambdas(curv_coord_name):
+        """
+        Store information about transformation equations for pre-defined
+        coordinate systems.
+
+        Parameters
+        ==========
+
+        curv_coord_name : str
+            Name of coordinate system
+
+        """
+        if isinstance(curv_coord_name, str):
+            if curv_coord_name == 'cartesian':
+                return lambda x, y, z: (x, y, z)
+            if curv_coord_name == 'spherical':
+                return lambda r, theta, phi: (
+                    r*sin(theta)*cos(phi),
+                    r*sin(theta)*sin(phi),
+                    r*cos(theta)
+                )
+            if curv_coord_name == 'cylindrical':
+                return lambda r, theta, h: (
+                    r*cos(theta),
+                    r*sin(theta),
+                    h
+                )
+            raise ValueError('Wrong set of parameters.'
+                             'Type of coordinate system is defined')
+
+    @classmethod
+    def _rotation_trans_equations(cls, matrix, equations):
+        """
+        Returns the transformation equations obtained from rotation matrix.
+
+        Parameters
+        ==========
+
+        matrix : Matrix
+            Rotation matrix
+
+        equations : tuple
+            Transformation equations
+
+        """
+        return tuple(matrix * Matrix(equations))
+
+    @property
+    def origin(self):
+        return self._origin
+
+    @property
+    def delop(self):
+        SymPyDeprecationWarning(
+            feature="coord_system.delop has been replaced.",
+            useinstead="Use the Del() class",
+            deprecated_since_version="1.1",
+            issue=12866,
+        ).warn()
+        from sympy.vector.deloperator import Del
+        return Del()
+
+    def base_vectors(self):
+        return self._base_vectors
+
+    def base_scalars(self):
+        return self._base_scalars
+
+    def lame_coefficients(self):
+        return self._lame_coefficients
+
+    def transformation_to_parent(self):
+        return self._transformation_lambda(*self.base_scalars())
+
+    def transformation_from_parent(self):
+        if self._parent is None:
+            raise ValueError("no parent coordinate system, use "
+                             "`transformation_from_parent_function()`")
+        return self._transformation_from_parent_lambda(
+                            *self._parent.base_scalars())
+
+    def transformation_from_parent_function(self):
+        return self._transformation_from_parent_lambda
+
+    def rotation_matrix(self, other):
+        """
+        Returns the direction cosine matrix(DCM), also known as the
+        'rotation matrix' of this coordinate system with respect to
+        another system.
+
+        If v_a is a vector defined in system 'A' (in matrix format)
+        and v_b is the same vector defined in system 'B', then
+        v_a = A.rotation_matrix(B) * v_b.
+
+        A SymPy Matrix is returned.
+
+        Parameters
+        ==========
+
+        other : CoordSys3D
+            The system which the DCM is generated to.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import symbols
+        >>> q1 = symbols('q1')
+        >>> N = CoordSys3D('N')
+        >>> A = N.orient_new_axis('A', q1, N.i)
+        >>> N.rotation_matrix(A)
+        Matrix([
+        [1,       0,        0],
+        [0, cos(q1), -sin(q1)],
+        [0, sin(q1),  cos(q1)]])
+
+        """
+        from sympy.vector.functions import _path
+        if not isinstance(other, CoordSys3D):
+            raise TypeError(str(other) +
+                            " is not a CoordSys3D")
+        # Handle special cases
+        if other == self:
+            return eye(3)
+        elif other == self._parent:
+            return self._parent_rotation_matrix
+        elif other._parent == self:
+            return other._parent_rotation_matrix.T
+        # Else, use tree to calculate position
+        rootindex, path = _path(self, other)
+        result = eye(3)
+        i = -1
+        for i in range(rootindex):
+            result *= path[i]._parent_rotation_matrix
+        i += 2
+        while i < len(path):
+            result *= path[i]._parent_rotation_matrix.T
+            i += 1
+        return result
+
+    @cacheit
+    def position_wrt(self, other):
+        """
+        Returns the position vector of the origin of this coordinate
+        system with respect to another Point/CoordSys3D.
+
+        Parameters
+        ==========
+
+        other : Point/CoordSys3D
+            If other is a Point, the position of this system's origin
+            wrt it is returned. If its an instance of CoordSyRect,
+            the position wrt its origin is returned.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> N = CoordSys3D('N')
+        >>> N1 = N.locate_new('N1', 10 * N.i)
+        >>> N.position_wrt(N1)
+        (-10)*N.i
+
+        """
+        return self.origin.position_wrt(other)
+
+    def scalar_map(self, other):
+        """
+        Returns a dictionary which expresses the coordinate variables
+        (base scalars) of this frame in terms of the variables of
+        otherframe.
+
+        Parameters
+        ==========
+
+        otherframe : CoordSys3D
+            The other system to map the variables to.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import Symbol
+        >>> A = CoordSys3D('A')
+        >>> q = Symbol('q')
+        >>> B = A.orient_new_axis('B', q, A.k)
+        >>> A.scalar_map(B)
+        {A.x: B.x*cos(q) - B.y*sin(q), A.y: B.x*sin(q) + B.y*cos(q), A.z: B.z}
+
+        """
+
+        relocated_scalars = []
+        origin_coords = tuple(self.position_wrt(other).to_matrix(other))
+        for i, x in enumerate(other.base_scalars()):
+            relocated_scalars.append(x - origin_coords[i])
+
+        vars_matrix = (self.rotation_matrix(other) *
+                       Matrix(relocated_scalars))
+        mapping = {}
+        for i, x in enumerate(self.base_scalars()):
+            mapping[x] = trigsimp(vars_matrix[i])
+        return mapping
+
+    def locate_new(self, name, position, vector_names=None,
+                   variable_names=None):
+        """
+        Returns a CoordSys3D with its origin located at the given
+        position wrt this coordinate system's origin.
+
+        Parameters
+        ==========
+
+        name : str
+            The name of the new CoordSys3D instance.
+
+        position : Vector
+            The position vector of the new system's origin wrt this
+            one.
+
+        vector_names, variable_names : iterable(optional)
+            Iterables of 3 strings each, with custom names for base
+            vectors and base scalars of the new system respectively.
+            Used for simple str printing.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> A = CoordSys3D('A')
+        >>> B = A.locate_new('B', 10 * A.i)
+        >>> B.origin.position_wrt(A.origin)
+        10*A.i
+
+        """
+        if variable_names is None:
+            variable_names = self._variable_names
+        if vector_names is None:
+            vector_names = self._vector_names
+
+        return CoordSys3D(name, location=position,
+                          vector_names=vector_names,
+                          variable_names=variable_names,
+                          parent=self)
+
+    def orient_new(self, name, orienters, location=None,
+                   vector_names=None, variable_names=None):
+        """
+        Creates a new CoordSys3D oriented in the user-specified way
+        with respect to this system.
+
+        Please refer to the documentation of the orienter classes
+        for more information about the orientation procedure.
+
+        Parameters
+        ==========
+
+        name : str
+            The name of the new CoordSys3D instance.
+
+        orienters : iterable/Orienter
+            An Orienter or an iterable of Orienters for orienting the
+            new coordinate system.
+            If an Orienter is provided, it is applied to get the new
+            system.
+            If an iterable is provided, the orienters will be applied
+            in the order in which they appear in the iterable.
+
+        location : Vector(optional)
+            The location of the new coordinate system's origin wrt this
+            system's origin. If not specified, the origins are taken to
+            be coincident.
+
+        vector_names, variable_names : iterable(optional)
+            Iterables of 3 strings each, with custom names for base
+            vectors and base scalars of the new system respectively.
+            Used for simple str printing.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import symbols
+        >>> q0, q1, q2, q3 = symbols('q0 q1 q2 q3')
+        >>> N = CoordSys3D('N')
+
+        Using an AxisOrienter
+
+        >>> from sympy.vector import AxisOrienter
+        >>> axis_orienter = AxisOrienter(q1, N.i + 2 * N.j)
+        >>> A = N.orient_new('A', (axis_orienter, ))
+
+        Using a BodyOrienter
+
+        >>> from sympy.vector import BodyOrienter
+        >>> body_orienter = BodyOrienter(q1, q2, q3, '123')
+        >>> B = N.orient_new('B', (body_orienter, ))
+
+        Using a SpaceOrienter
+
+        >>> from sympy.vector import SpaceOrienter
+        >>> space_orienter = SpaceOrienter(q1, q2, q3, '312')
+        >>> C = N.orient_new('C', (space_orienter, ))
+
+        Using a QuaternionOrienter
+
+        >>> from sympy.vector import QuaternionOrienter
+        >>> q_orienter = QuaternionOrienter(q0, q1, q2, q3)
+        >>> D = N.orient_new('D', (q_orienter, ))
+        """
+        if variable_names is None:
+            variable_names = self._variable_names
+        if vector_names is None:
+            vector_names = self._vector_names
+
+        if isinstance(orienters, Orienter):
+            if isinstance(orienters, AxisOrienter):
+                final_matrix = orienters.rotation_matrix(self)
+            else:
+                final_matrix = orienters.rotation_matrix()
+            # TODO: trigsimp is needed here so that the matrix becomes
+            # canonical (scalar_map also calls trigsimp; without this, you can
+            # end up with the same CoordinateSystem that compares differently
+            # due to a differently formatted matrix). However, this is
+            # probably not so good for performance.
+            final_matrix = trigsimp(final_matrix)
+        else:
+            final_matrix = Matrix(eye(3))
+            for orienter in orienters:
+                if isinstance(orienter, AxisOrienter):
+                    final_matrix *= orienter.rotation_matrix(self)
+                else:
+                    final_matrix *= orienter.rotation_matrix()
+
+        return CoordSys3D(name, rotation_matrix=final_matrix,
+                          vector_names=vector_names,
+                          variable_names=variable_names,
+                          location=location,
+                          parent=self)
+
+    def orient_new_axis(self, name, angle, axis, location=None,
+                        vector_names=None, variable_names=None):
+        """
+        Axis rotation is a rotation about an arbitrary axis by
+        some angle. The angle is supplied as a SymPy expr scalar, and
+        the axis is supplied as a Vector.
+
+        Parameters
+        ==========
+
+        name : string
+            The name of the new coordinate system
+
+        angle : Expr
+            The angle by which the new system is to be rotated
+
+        axis : Vector
+            The axis around which the rotation has to be performed
+
+        location : Vector(optional)
+            The location of the new coordinate system's origin wrt this
+            system's origin. If not specified, the origins are taken to
+            be coincident.
+
+        vector_names, variable_names : iterable(optional)
+            Iterables of 3 strings each, with custom names for base
+            vectors and base scalars of the new system respectively.
+            Used for simple str printing.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import symbols
+        >>> q1 = symbols('q1')
+        >>> N = CoordSys3D('N')
+        >>> B = N.orient_new_axis('B', q1, N.i + 2 * N.j)
+
+        """
+        if variable_names is None:
+            variable_names = self._variable_names
+        if vector_names is None:
+            vector_names = self._vector_names
+
+        orienter = AxisOrienter(angle, axis)
+        return self.orient_new(name, orienter,
+                               location=location,
+                               vector_names=vector_names,
+                               variable_names=variable_names)
+
+    def orient_new_body(self, name, angle1, angle2, angle3,
+                        rotation_order, location=None,
+                        vector_names=None, variable_names=None):
+        """
+        Body orientation takes this coordinate system through three
+        successive simple rotations.
+
+        Body fixed rotations include both Euler Angles and
+        Tait-Bryan Angles, see https://en.wikipedia.org/wiki/Euler_angles.
+
+        Parameters
+        ==========
+
+        name : string
+            The name of the new coordinate system
+
+        angle1, angle2, angle3 : Expr
+            Three successive angles to rotate the coordinate system by
+
+        rotation_order : string
+            String defining the order of axes for rotation
+
+        location : Vector(optional)
+            The location of the new coordinate system's origin wrt this
+            system's origin. If not specified, the origins are taken to
+            be coincident.
+
+        vector_names, variable_names : iterable(optional)
+            Iterables of 3 strings each, with custom names for base
+            vectors and base scalars of the new system respectively.
+            Used for simple str printing.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import symbols
+        >>> q1, q2, q3 = symbols('q1 q2 q3')
+        >>> N = CoordSys3D('N')
+
+        A 'Body' fixed rotation is described by three angles and
+        three body-fixed rotation axes. To orient a coordinate system D
+        with respect to N, each sequential rotation is always about
+        the orthogonal unit vectors fixed to D. For example, a '123'
+        rotation will specify rotations about N.i, then D.j, then
+        D.k. (Initially, D.i is same as N.i)
+        Therefore,
+
+        >>> D = N.orient_new_body('D', q1, q2, q3, '123')
+
+        is same as
+
+        >>> D = N.orient_new_axis('D', q1, N.i)
+        >>> D = D.orient_new_axis('D', q2, D.j)
+        >>> D = D.orient_new_axis('D', q3, D.k)
+
+        Acceptable rotation orders are of length 3, expressed in XYZ or
+        123, and cannot have a rotation about about an axis twice in a row.
+
+        >>> B = N.orient_new_body('B', q1, q2, q3, '123')
+        >>> B = N.orient_new_body('B', q1, q2, 0, 'ZXZ')
+        >>> B = N.orient_new_body('B', 0, 0, 0, 'XYX')
+
+        """
+
+        orienter = BodyOrienter(angle1, angle2, angle3, rotation_order)
+        return self.orient_new(name, orienter,
+                               location=location,
+                               vector_names=vector_names,
+                               variable_names=variable_names)
+
+    def orient_new_space(self, name, angle1, angle2, angle3,
+                         rotation_order, location=None,
+                         vector_names=None, variable_names=None):
+        """
+        Space rotation is similar to Body rotation, but the rotations
+        are applied in the opposite order.
+
+        Parameters
+        ==========
+
+        name : string
+            The name of the new coordinate system
+
+        angle1, angle2, angle3 : Expr
+            Three successive angles to rotate the coordinate system by
+
+        rotation_order : string
+            String defining the order of axes for rotation
+
+        location : Vector(optional)
+            The location of the new coordinate system's origin wrt this
+            system's origin. If not specified, the origins are taken to
+            be coincident.
+
+        vector_names, variable_names : iterable(optional)
+            Iterables of 3 strings each, with custom names for base
+            vectors and base scalars of the new system respectively.
+            Used for simple str printing.
+
+        See Also
+        ========
+
+        CoordSys3D.orient_new_body : method to orient via Euler
+            angles
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import symbols
+        >>> q1, q2, q3 = symbols('q1 q2 q3')
+        >>> N = CoordSys3D('N')
+
+        To orient a coordinate system D with respect to N, each
+        sequential rotation is always about N's orthogonal unit vectors.
+        For example, a '123' rotation will specify rotations about
+        N.i, then N.j, then N.k.
+        Therefore,
+
+        >>> D = N.orient_new_space('D', q1, q2, q3, '312')
+
+        is same as
+
+        >>> B = N.orient_new_axis('B', q1, N.i)
+        >>> C = B.orient_new_axis('C', q2, N.j)
+        >>> D = C.orient_new_axis('D', q3, N.k)
+
+        """
+
+        orienter = SpaceOrienter(angle1, angle2, angle3, rotation_order)
+        return self.orient_new(name, orienter,
+                               location=location,
+                               vector_names=vector_names,
+                               variable_names=variable_names)
+
+    def orient_new_quaternion(self, name, q0, q1, q2, q3, location=None,
+                              vector_names=None, variable_names=None):
+        """
+        Quaternion orientation orients the new CoordSys3D with
+        Quaternions, defined as a finite rotation about lambda, a unit
+        vector, by some amount theta.
+
+        This orientation is described by four parameters:
+
+        q0 = cos(theta/2)
+
+        q1 = lambda_x sin(theta/2)
+
+        q2 = lambda_y sin(theta/2)
+
+        q3 = lambda_z sin(theta/2)
+
+        Quaternion does not take in a rotation order.
+
+        Parameters
+        ==========
+
+        name : string
+            The name of the new coordinate system
+
+        q0, q1, q2, q3 : Expr
+            The quaternions to rotate the coordinate system by
+
+        location : Vector(optional)
+            The location of the new coordinate system's origin wrt this
+            system's origin. If not specified, the origins are taken to
+            be coincident.
+
+        vector_names, variable_names : iterable(optional)
+            Iterables of 3 strings each, with custom names for base
+            vectors and base scalars of the new system respectively.
+            Used for simple str printing.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import symbols
+        >>> q0, q1, q2, q3 = symbols('q0 q1 q2 q3')
+        >>> N = CoordSys3D('N')
+        >>> B = N.orient_new_quaternion('B', q0, q1, q2, q3)
+
+        """
+
+        orienter = QuaternionOrienter(q0, q1, q2, q3)
+        return self.orient_new(name, orienter,
+                               location=location,
+                               vector_names=vector_names,
+                               variable_names=variable_names)
+
+    def create_new(self, name, transformation, variable_names=None, vector_names=None):
+        """
+        Returns a CoordSys3D which is connected to self by transformation.
+
+        Parameters
+        ==========
+
+        name : str
+            The name of the new CoordSys3D instance.
+
+        transformation : Lambda, Tuple, str
+            Transformation defined by transformation equations or chosen
+            from predefined ones.
+
+        vector_names, variable_names : iterable(optional)
+            Iterables of 3 strings each, with custom names for base
+            vectors and base scalars of the new system respectively.
+            Used for simple str printing.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> a = CoordSys3D('a')
+        >>> b = a.create_new('b', transformation='spherical')
+        >>> b.transformation_to_parent()
+        (b.r*sin(b.theta)*cos(b.phi), b.r*sin(b.phi)*sin(b.theta), b.r*cos(b.theta))
+        >>> b.transformation_from_parent()
+        (sqrt(a.x**2 + a.y**2 + a.z**2), acos(a.z/sqrt(a.x**2 + a.y**2 + a.z**2)), atan2(a.y, a.x))
+
+        """
+        return CoordSys3D(name, parent=self, transformation=transformation,
+                          variable_names=variable_names, vector_names=vector_names)
+
+    def __init__(self, name, location=None, rotation_matrix=None,
+                 parent=None, vector_names=None, variable_names=None,
+                 latex_vects=None, pretty_vects=None, latex_scalars=None,
+                 pretty_scalars=None, transformation=None):
+        # Dummy initializer for setting docstring
+        pass
+
+    __init__.__doc__ = __new__.__doc__
+
+    @staticmethod
+    def _compose_rotation_and_translation(rot, translation, parent):
+        r = lambda x, y, z: CoordSys3D._rotation_trans_equations(rot, (x, y, z))
+        if parent is None:
+            return r
+
+        dx, dy, dz = [translation.dot(i) for i in parent.base_vectors()]
+        t = lambda x, y, z: (
+            x + dx,
+            y + dy,
+            z + dz,
+        )
+        return lambda x, y, z: t(*r(x, y, z))
+
+
+def _check_strings(arg_name, arg):
+    errorstr = arg_name + " must be an iterable of 3 string-types"
+    if len(arg) != 3:
+        raise ValueError(errorstr)
+    for s in arg:
+        if not isinstance(s, str):
+            raise TypeError(errorstr)
+
+
+# Delayed import to avoid cyclic import problems:
+from sympy.vector.vector import BaseVector
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/deloperator.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/deloperator.py
new file mode 100644
index 0000000000..cb8b92b91e
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/deloperator.py
@@ -0,0 +1,129 @@
+from sympy.utilities.exceptions import SymPyDeprecationWarning
+from sympy.core import Basic
+from sympy.vector.operators import gradient, divergence, curl
+
+
+class Del(Basic):
+    """
+    Represents the vector differential operator, usually represented in
+    mathematical expressions as the 'nabla' symbol.
+    """
+
+    def __new__(cls, system=None):
+        if system is not None:
+            SymPyDeprecationWarning(
+                feature="delop operator inside coordinate system",
+                useinstead="it as instance Del class",
+                deprecated_since_version="1.1",
+                issue=12866,
+            ).warn()
+        obj = super().__new__(cls)
+        obj._name = "delop"
+        return obj
+
+    def gradient(self, scalar_field, doit=False):
+        """
+        Returns the gradient of the given scalar field, as a
+        Vector instance.
+
+        Parameters
+        ==========
+
+        scalar_field : SymPy expression
+            The scalar field to calculate the gradient of.
+
+        doit : bool
+            If True, the result is returned after calling .doit() on
+            each component. Else, the returned expression contains
+            Derivative instances
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D, Del
+        >>> C = CoordSys3D('C')
+        >>> delop = Del()
+        >>> delop.gradient(9)
+        0
+        >>> delop(C.x*C.y*C.z).doit()
+        C.y*C.z*C.i + C.x*C.z*C.j + C.x*C.y*C.k
+
+        """
+
+        return gradient(scalar_field, doit=doit)
+
+    __call__ = gradient
+    __call__.__doc__ = gradient.__doc__
+
+    def dot(self, vect, doit=False):
+        """
+        Represents the dot product between this operator and a given
+        vector - equal to the divergence of the vector field.
+
+        Parameters
+        ==========
+
+        vect : Vector
+            The vector whose divergence is to be calculated.
+
+        doit : bool
+            If True, the result is returned after calling .doit() on
+            each component. Else, the returned expression contains
+            Derivative instances
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D, Del
+        >>> delop = Del()
+        >>> C = CoordSys3D('C')
+        >>> delop.dot(C.x*C.i)
+        Derivative(C.x, C.x)
+        >>> v = C.x*C.y*C.z * (C.i + C.j + C.k)
+        >>> (delop & v).doit()
+        C.x*C.y + C.x*C.z + C.y*C.z
+
+        """
+        return divergence(vect, doit=doit)
+
+    __and__ = dot
+    __and__.__doc__ = dot.__doc__
+
+    def cross(self, vect, doit=False):
+        """
+        Represents the cross product between this operator and a given
+        vector - equal to the curl of the vector field.
+
+        Parameters
+        ==========
+
+        vect : Vector
+            The vector whose curl is to be calculated.
+
+        doit : bool
+            If True, the result is returned after calling .doit() on
+            each component. Else, the returned expression contains
+            Derivative instances
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D, Del
+        >>> C = CoordSys3D('C')
+        >>> delop = Del()
+        >>> v = C.x*C.y*C.z * (C.i + C.j + C.k)
+        >>> delop.cross(v, doit = True)
+        (-C.x*C.y + C.x*C.z)*C.i + (C.x*C.y - C.y*C.z)*C.j +
+            (-C.x*C.z + C.y*C.z)*C.k
+        >>> (delop ^ C.i).doit()
+        0
+
+        """
+
+        return curl(vect, doit=doit)
+
+    __xor__ = cross
+    __xor__.__doc__ = cross.__doc__
+
+    def _sympystr(self, printer):
+        return self._name
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/dyadic.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/dyadic.py
new file mode 100644
index 0000000000..b0bdd5f2dc
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/dyadic.py
@@ -0,0 +1,281 @@
+from typing import Type
+
+from sympy.vector.basisdependent import (BasisDependent, BasisDependentAdd,
+                                         BasisDependentMul, BasisDependentZero)
+from sympy.core import S, Pow
+from sympy.core.expr import AtomicExpr
+from sympy import ImmutableMatrix as Matrix
+import sympy.vector
+
+
+class Dyadic(BasisDependent):
+    """
+    Super class for all Dyadic-classes.
+
+    References
+    ==========
+
+    .. [1] https://en.wikipedia.org/wiki/Dyadic_tensor
+    .. [2] Kane, T., Levinson, D. Dynamics Theory and Applications. 1985
+           McGraw-Hill
+
+    """
+
+    _op_priority = 13.0
+
+    _expr_type = None  # type: Type[Dyadic]
+    _mul_func = None  # type: Type[Dyadic]
+    _add_func = None  # type: Type[Dyadic]
+    _zero_func = None  # type: Type[Dyadic]
+    _base_func = None  # type: Type[Dyadic]
+    zero = None  # type: DyadicZero
+
+    @property
+    def components(self):
+        """
+        Returns the components of this dyadic in the form of a
+        Python dictionary mapping BaseDyadic instances to the
+        corresponding measure numbers.
+
+        """
+        # The '_components' attribute is defined according to the
+        # subclass of Dyadic the instance belongs to.
+        return self._components
+
+    def dot(self, other):
+        """
+        Returns the dot product(also called inner product) of this
+        Dyadic, with another Dyadic or Vector.
+        If 'other' is a Dyadic, this returns a Dyadic. Else, it returns
+        a Vector (unless an error is encountered).
+
+        Parameters
+        ==========
+
+        other : Dyadic/Vector
+            The other Dyadic or Vector to take the inner product with
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> N = CoordSys3D('N')
+        >>> D1 = N.i.outer(N.j)
+        >>> D2 = N.j.outer(N.j)
+        >>> D1.dot(D2)
+        (N.i|N.j)
+        >>> D1.dot(N.j)
+        N.i
+
+        """
+
+        Vector = sympy.vector.Vector
+        if isinstance(other, BasisDependentZero):
+            return Vector.zero
+        elif isinstance(other, Vector):
+            outvec = Vector.zero
+            for k, v in self.components.items():
+                vect_dot = k.args[1].dot(other)
+                outvec += vect_dot * v * k.args[0]
+            return outvec
+        elif isinstance(other, Dyadic):
+            outdyad = Dyadic.zero
+            for k1, v1 in self.components.items():
+                for k2, v2 in other.components.items():
+                    vect_dot = k1.args[1].dot(k2.args[0])
+                    outer_product = k1.args[0].outer(k2.args[1])
+                    outdyad += vect_dot * v1 * v2 * outer_product
+            return outdyad
+        else:
+            raise TypeError("Inner product is not defined for " +
+                            str(type(other)) + " and Dyadics.")
+
+    def __and__(self, other):
+        return self.dot(other)
+
+    __and__.__doc__ = dot.__doc__
+
+    def cross(self, other):
+        """
+        Returns the cross product between this Dyadic, and a Vector, as a
+        Vector instance.
+
+        Parameters
+        ==========
+
+        other : Vector
+            The Vector that we are crossing this Dyadic with
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> N = CoordSys3D('N')
+        >>> d = N.i.outer(N.i)
+        >>> d.cross(N.j)
+        (N.i|N.k)
+
+        """
+
+        Vector = sympy.vector.Vector
+        if other == Vector.zero:
+            return Dyadic.zero
+        elif isinstance(other, Vector):
+            outdyad = Dyadic.zero
+            for k, v in self.components.items():
+                cross_product = k.args[1].cross(other)
+                outer = k.args[0].outer(cross_product)
+                outdyad += v * outer
+            return outdyad
+        else:
+            raise TypeError(str(type(other)) + " not supported for " +
+                            "cross with dyadics")
+
+    def __xor__(self, other):
+        return self.cross(other)
+
+    __xor__.__doc__ = cross.__doc__
+
+    def to_matrix(self, system, second_system=None):
+        """
+        Returns the matrix form of the dyadic with respect to one or two
+        coordinate systems.
+
+        Parameters
+        ==========
+
+        system : CoordSys3D
+            The coordinate system that the rows and columns of the matrix
+            correspond to. If a second system is provided, this
+            only corresponds to the rows of the matrix.
+        second_system : CoordSys3D, optional, default=None
+            The coordinate system that the columns of the matrix correspond
+            to.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> N = CoordSys3D('N')
+        >>> v = N.i + 2*N.j
+        >>> d = v.outer(N.i)
+        >>> d.to_matrix(N)
+        Matrix([
+        [1, 0, 0],
+        [2, 0, 0],
+        [0, 0, 0]])
+        >>> from sympy import Symbol
+        >>> q = Symbol('q')
+        >>> P = N.orient_new_axis('P', q, N.k)
+        >>> d.to_matrix(N, P)
+        Matrix([
+        [  cos(q),   -sin(q), 0],
+        [2*cos(q), -2*sin(q), 0],
+        [       0,         0, 0]])
+
+        """
+
+        if second_system is None:
+            second_system = system
+
+        return Matrix([i.dot(self).dot(j) for i in system for j in
+                       second_system]).reshape(3, 3)
+
+    def _div_helper(one, other):
+        """ Helper for division involving dyadics """
+        if isinstance(one, Dyadic) and isinstance(other, Dyadic):
+            raise TypeError("Cannot divide two dyadics")
+        elif isinstance(one, Dyadic):
+            return DyadicMul(one, Pow(other, S.NegativeOne))
+        else:
+            raise TypeError("Cannot divide by a dyadic")
+
+
+class BaseDyadic(Dyadic, AtomicExpr):
+    """
+    Class to denote a base dyadic tensor component.
+    """
+
+    def __new__(cls, vector1, vector2):
+        Vector = sympy.vector.Vector
+        BaseVector = sympy.vector.BaseVector
+        VectorZero = sympy.vector.VectorZero
+        # Verify arguments
+        if not isinstance(vector1, (BaseVector, VectorZero)) or \
+                not isinstance(vector2, (BaseVector, VectorZero)):
+            raise TypeError("BaseDyadic cannot be composed of non-base " +
+                            "vectors")
+        # Handle special case of zero vector
+        elif vector1 == Vector.zero or vector2 == Vector.zero:
+            return Dyadic.zero
+        # Initialize instance
+        obj = super().__new__(cls, vector1, vector2)
+        obj._base_instance = obj
+        obj._measure_number = 1
+        obj._components = {obj: S.One}
+        obj._sys = vector1._sys
+        obj._pretty_form = ('(' + vector1._pretty_form + '|' +
+                             vector2._pretty_form + ')')
+        obj._latex_form = ('(' + vector1._latex_form + "{|}" +
+                           vector2._latex_form + ')')
+
+        return obj
+
+    def _sympystr(self, printer):
+        return "({}|{})".format(
+            printer._print(self.args[0]), printer._print(self.args[1]))
+
+
+class DyadicMul(BasisDependentMul, Dyadic):
+    """ Products of scalars and BaseDyadics """
+
+    def __new__(cls, *args, **options):
+        obj = BasisDependentMul.__new__(cls, *args, **options)
+        return obj
+
+    @property
+    def base_dyadic(self):
+        """ The BaseDyadic involved in the product. """
+        return self._base_instance
+
+    @property
+    def measure_number(self):
+        """ The scalar expression involved in the definition of
+        this DyadicMul.
+        """
+        return self._measure_number
+
+
+class DyadicAdd(BasisDependentAdd, Dyadic):
+    """ Class to hold dyadic sums """
+
+    def __new__(cls, *args, **options):
+        obj = BasisDependentAdd.__new__(cls, *args, **options)
+        return obj
+
+    def _sympystr(self, printer):
+        items = list(self.components.items())
+        items.sort(key=lambda x: x[0].__str__())
+        return " + ".join(printer._print(k * v) for k, v in items)
+
+
+class DyadicZero(BasisDependentZero, Dyadic):
+    """
+    Class to denote a zero dyadic
+    """
+
+    _op_priority = 13.1
+    _pretty_form = '(0|0)'
+    _latex_form = r'(\mathbf{\hat{0}}|\mathbf{\hat{0}})'
+
+    def __new__(cls):
+        obj = BasisDependentZero.__new__(cls)
+        return obj
+
+
+Dyadic._expr_type = Dyadic
+Dyadic._mul_func = DyadicMul
+Dyadic._add_func = DyadicAdd
+Dyadic._zero_func = DyadicZero
+Dyadic._base_func = BaseDyadic
+Dyadic.zero = DyadicZero()
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/functions.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/functions.py
new file mode 100644
index 0000000000..d823450cab
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/functions.py
@@ -0,0 +1,518 @@
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.vector.deloperator import Del
+from sympy.vector.scalar import BaseScalar
+from sympy.vector.vector import Vector, BaseVector
+from sympy.vector.operators import gradient, curl, divergence
+from sympy import diff, integrate, S, simplify
+from sympy.core import sympify
+from sympy.vector.dyadic import Dyadic
+
+
+def express(expr, system, system2=None, variables=False):
+    """
+    Global function for 'express' functionality.
+
+    Re-expresses a Vector, Dyadic or scalar(sympyfiable) in the given
+    coordinate system.
+
+    If 'variables' is True, then the coordinate variables (base scalars)
+    of other coordinate systems present in the vector/scalar field or
+    dyadic are also substituted in terms of the base scalars of the
+    given system.
+
+    Parameters
+    ==========
+
+    expr : Vector/Dyadic/scalar(sympyfiable)
+        The expression to re-express in CoordSys3D 'system'
+
+    system: CoordSys3D
+        The coordinate system the expr is to be expressed in
+
+    system2: CoordSys3D
+        The other coordinate system required for re-expression
+        (only for a Dyadic Expr)
+
+    variables : boolean
+        Specifies whether to substitute the coordinate variables present
+        in expr, in terms of those of parameter system
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D
+    >>> from sympy import Symbol, cos, sin
+    >>> N = CoordSys3D('N')
+    >>> q = Symbol('q')
+    >>> B = N.orient_new_axis('B', q, N.k)
+    >>> from sympy.vector import express
+    >>> express(B.i, N)
+    (cos(q))*N.i + (sin(q))*N.j
+    >>> express(N.x, B, variables=True)
+    B.x*cos(q) - B.y*sin(q)
+    >>> d = N.i.outer(N.i)
+    >>> express(d, B, N) == (cos(q))*(B.i|N.i) + (-sin(q))*(B.j|N.i)
+    True
+
+    """
+
+    if expr == 0 or expr == Vector.zero:
+        return expr
+
+    if not isinstance(system, CoordSys3D):
+        raise TypeError("system should be a CoordSys3D \
+                        instance")
+
+    if isinstance(expr, Vector):
+        if system2 is not None:
+            raise ValueError("system2 should not be provided for \
+                                Vectors")
+        # Given expr is a Vector
+        if variables:
+            # If variables attribute is True, substitute
+            # the coordinate variables in the Vector
+            system_list = []
+            for x in expr.atoms(BaseScalar, BaseVector):
+                if x.system != system:
+                    system_list.append(x.system)
+            system_list = set(system_list)
+            subs_dict = {}
+            for f in system_list:
+                subs_dict.update(f.scalar_map(system))
+            expr = expr.subs(subs_dict)
+        # Re-express in this coordinate system
+        outvec = Vector.zero
+        parts = expr.separate()
+        for x in parts:
+            if x != system:
+                temp = system.rotation_matrix(x) * parts[x].to_matrix(x)
+                outvec += matrix_to_vector(temp, system)
+            else:
+                outvec += parts[x]
+        return outvec
+
+    elif isinstance(expr, Dyadic):
+        if system2 is None:
+            system2 = system
+        if not isinstance(system2, CoordSys3D):
+            raise TypeError("system2 should be a CoordSys3D \
+                            instance")
+        outdyad = Dyadic.zero
+        var = variables
+        for k, v in expr.components.items():
+            outdyad += (express(v, system, variables=var) *
+                        (express(k.args[0], system, variables=var) |
+                         express(k.args[1], system2, variables=var)))
+
+        return outdyad
+
+    else:
+        if system2 is not None:
+            raise ValueError("system2 should not be provided for \
+                                Vectors")
+        if variables:
+            # Given expr is a scalar field
+            system_set = set()
+            expr = sympify(expr)
+            # Substitute all the coordinate variables
+            for x in expr.atoms(BaseScalar):
+                if x.system != system:
+                    system_set.add(x.system)
+            subs_dict = {}
+            for f in system_set:
+                subs_dict.update(f.scalar_map(system))
+            return expr.subs(subs_dict)
+        return expr
+
+
+def directional_derivative(field, direction_vector):
+    """
+    Returns the directional derivative of a scalar or vector field computed
+    along a given vector in coordinate system which parameters are expressed.
+
+    Parameters
+    ==========
+
+    field : Vector or Scalar
+        The scalar or vector field to compute the directional derivative of
+
+    direction_vector : Vector
+        The vector to calculated directional derivative along them.
+
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, directional_derivative
+    >>> R = CoordSys3D('R')
+    >>> f1 = R.x*R.y*R.z
+    >>> v1 = 3*R.i + 4*R.j + R.k
+    >>> directional_derivative(f1, v1)
+    R.x*R.y + 4*R.x*R.z + 3*R.y*R.z
+    >>> f2 = 5*R.x**2*R.z
+    >>> directional_derivative(f2, v1)
+    5*R.x**2 + 30*R.x*R.z
+
+    """
+    from sympy.vector.operators import _get_coord_sys_from_expr
+    coord_sys = _get_coord_sys_from_expr(field)
+    if len(coord_sys) > 0:
+        # TODO: This gets a random coordinate system in case of multiple ones:
+        coord_sys = next(iter(coord_sys))
+        field = express(field, coord_sys, variables=True)
+        i, j, k = coord_sys.base_vectors()
+        x, y, z = coord_sys.base_scalars()
+        out = Vector.dot(direction_vector, i) * diff(field, x)
+        out += Vector.dot(direction_vector, j) * diff(field, y)
+        out += Vector.dot(direction_vector, k) * diff(field, z)
+        if out == 0 and isinstance(field, Vector):
+            out = Vector.zero
+        return out
+    elif isinstance(field, Vector):
+        return Vector.zero
+    else:
+        return S.Zero
+
+
+def laplacian(expr):
+    """
+    Return the laplacian of the given field computed in terms of
+    the base scalars of the given coordinate system.
+
+    Parameters
+    ==========
+
+    expr : SymPy Expr or Vector
+        expr denotes a scalar or vector field.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, laplacian
+    >>> R = CoordSys3D('R')
+    >>> f = R.x**2*R.y**5*R.z
+    >>> laplacian(f)
+    20*R.x**2*R.y**3*R.z + 2*R.y**5*R.z
+    >>> f = R.x**2*R.i + R.y**3*R.j + R.z**4*R.k
+    >>> laplacian(f)
+    2*R.i + 6*R.y*R.j + 12*R.z**2*R.k
+
+    """
+
+    delop = Del()
+    if expr.is_Vector:
+        return (gradient(divergence(expr)) - curl(curl(expr))).doit()
+    return delop.dot(delop(expr)).doit()
+
+
+def is_conservative(field):
+    """
+    Checks if a field is conservative.
+
+    Parameters
+    ==========
+
+    field : Vector
+        The field to check for conservative property
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D
+    >>> from sympy.vector import is_conservative
+    >>> R = CoordSys3D('R')
+    >>> is_conservative(R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k)
+    True
+    >>> is_conservative(R.z*R.j)
+    False
+
+    """
+
+    # Field is conservative irrespective of system
+    # Take the first coordinate system in the result of the
+    # separate method of Vector
+    if not isinstance(field, Vector):
+        raise TypeError("field should be a Vector")
+    if field == Vector.zero:
+        return True
+    return curl(field).simplify() == Vector.zero
+
+
+def is_solenoidal(field):
+    """
+    Checks if a field is solenoidal.
+
+    Parameters
+    ==========
+
+    field : Vector
+        The field to check for solenoidal property
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D
+    >>> from sympy.vector import is_solenoidal
+    >>> R = CoordSys3D('R')
+    >>> is_solenoidal(R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k)
+    True
+    >>> is_solenoidal(R.y * R.j)
+    False
+
+    """
+
+    # Field is solenoidal irrespective of system
+    # Take the first coordinate system in the result of the
+    # separate method in Vector
+    if not isinstance(field, Vector):
+        raise TypeError("field should be a Vector")
+    if field == Vector.zero:
+        return True
+    return divergence(field).simplify() is S.Zero
+
+
+def scalar_potential(field, coord_sys):
+    """
+    Returns the scalar potential function of a field in a given
+    coordinate system (without the added integration constant).
+
+    Parameters
+    ==========
+
+    field : Vector
+        The vector field whose scalar potential function is to be
+        calculated
+
+    coord_sys : CoordSys3D
+        The coordinate system to do the calculation in
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D
+    >>> from sympy.vector import scalar_potential, gradient
+    >>> R = CoordSys3D('R')
+    >>> scalar_potential(R.k, R) == R.z
+    True
+    >>> scalar_field = 2*R.x**2*R.y*R.z
+    >>> grad_field = gradient(scalar_field)
+    >>> scalar_potential(grad_field, R)
+    2*R.x**2*R.y*R.z
+
+    """
+
+    # Check whether field is conservative
+    if not is_conservative(field):
+        raise ValueError("Field is not conservative")
+    if field == Vector.zero:
+        return S.Zero
+    # Express the field exntirely in coord_sys
+    # Substitute coordinate variables also
+    if not isinstance(coord_sys, CoordSys3D):
+        raise TypeError("coord_sys must be a CoordSys3D")
+    field = express(field, coord_sys, variables=True)
+    dimensions = coord_sys.base_vectors()
+    scalars = coord_sys.base_scalars()
+    # Calculate scalar potential function
+    temp_function = integrate(field.dot(dimensions[0]), scalars[0])
+    for i, dim in enumerate(dimensions[1:]):
+        partial_diff = diff(temp_function, scalars[i + 1])
+        partial_diff = field.dot(dim) - partial_diff
+        temp_function += integrate(partial_diff, scalars[i + 1])
+    return temp_function
+
+
+def scalar_potential_difference(field, coord_sys, point1, point2):
+    """
+    Returns the scalar potential difference between two points in a
+    certain coordinate system, wrt a given field.
+
+    If a scalar field is provided, its values at the two points are
+    considered. If a conservative vector field is provided, the values
+    of its scalar potential function at the two points are used.
+
+    Returns (potential at point2) - (potential at point1)
+
+    The position vectors of the two Points are calculated wrt the
+    origin of the coordinate system provided.
+
+    Parameters
+    ==========
+
+    field : Vector/Expr
+        The field to calculate wrt
+
+    coord_sys : CoordSys3D
+        The coordinate system to do the calculations in
+
+    point1 : Point
+        The initial Point in given coordinate system
+
+    position2 : Point
+        The second Point in the given coordinate system
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D
+    >>> from sympy.vector import scalar_potential_difference
+    >>> R = CoordSys3D('R')
+    >>> P = R.origin.locate_new('P', R.x*R.i + R.y*R.j + R.z*R.k)
+    >>> vectfield = 4*R.x*R.y*R.i + 2*R.x**2*R.j
+    >>> scalar_potential_difference(vectfield, R, R.origin, P)
+    2*R.x**2*R.y
+    >>> Q = R.origin.locate_new('O', 3*R.i + R.j + 2*R.k)
+    >>> scalar_potential_difference(vectfield, R, P, Q)
+    -2*R.x**2*R.y + 18
+
+    """
+
+    if not isinstance(coord_sys, CoordSys3D):
+        raise TypeError("coord_sys must be a CoordSys3D")
+    if isinstance(field, Vector):
+        # Get the scalar potential function
+        scalar_fn = scalar_potential(field, coord_sys)
+    else:
+        # Field is a scalar
+        scalar_fn = field
+    # Express positions in required coordinate system
+    origin = coord_sys.origin
+    position1 = express(point1.position_wrt(origin), coord_sys,
+                        variables=True)
+    position2 = express(point2.position_wrt(origin), coord_sys,
+                        variables=True)
+    # Get the two positions as substitution dicts for coordinate variables
+    subs_dict1 = {}
+    subs_dict2 = {}
+    scalars = coord_sys.base_scalars()
+    for i, x in enumerate(coord_sys.base_vectors()):
+        subs_dict1[scalars[i]] = x.dot(position1)
+        subs_dict2[scalars[i]] = x.dot(position2)
+    return scalar_fn.subs(subs_dict2) - scalar_fn.subs(subs_dict1)
+
+
+def matrix_to_vector(matrix, system):
+    """
+    Converts a vector in matrix form to a Vector instance.
+
+    It is assumed that the elements of the Matrix represent the
+    measure numbers of the components of the vector along basis
+    vectors of 'system'.
+
+    Parameters
+    ==========
+
+    matrix : SymPy Matrix, Dimensions: (3, 1)
+        The matrix to be converted to a vector
+
+    system : CoordSys3D
+        The coordinate system the vector is to be defined in
+
+    Examples
+    ========
+
+    >>> from sympy import ImmutableMatrix as Matrix
+    >>> m = Matrix([1, 2, 3])
+    >>> from sympy.vector import CoordSys3D, matrix_to_vector
+    >>> C = CoordSys3D('C')
+    >>> v = matrix_to_vector(m, C)
+    >>> v
+    C.i + 2*C.j + 3*C.k
+    >>> v.to_matrix(C) == m
+    True
+
+    """
+
+    outvec = Vector.zero
+    vects = system.base_vectors()
+    for i, x in enumerate(matrix):
+        outvec += x * vects[i]
+    return outvec
+
+
+def _path(from_object, to_object):
+    """
+    Calculates the 'path' of objects starting from 'from_object'
+    to 'to_object', along with the index of the first common
+    ancestor in the tree.
+
+    Returns (index, list) tuple.
+    """
+
+    if from_object._root != to_object._root:
+        raise ValueError("No connecting path found between " +
+                         str(from_object) + " and " + str(to_object))
+
+    other_path = []
+    obj = to_object
+    while obj._parent is not None:
+        other_path.append(obj)
+        obj = obj._parent
+    other_path.append(obj)
+    object_set = set(other_path)
+    from_path = []
+    obj = from_object
+    while obj not in object_set:
+        from_path.append(obj)
+        obj = obj._parent
+    index = len(from_path)
+    i = other_path.index(obj)
+    while i >= 0:
+        from_path.append(other_path[i])
+        i -= 1
+    return index, from_path
+
+
+def orthogonalize(*vlist, orthonormal=False):
+    """
+    Takes a sequence of independent vectors and orthogonalizes them
+    using the Gram - Schmidt process. Returns a list of
+    orthogonal or orthonormal vectors.
+
+    Parameters
+    ==========
+
+    vlist : sequence of independent vectors to be made orthogonal.
+
+    orthonormal : Optional parameter
+                  Set to True if the vectors returned should be
+                  orthonormal.
+                  Default: False
+
+    Examples
+    ========
+
+    >>> from sympy.vector.coordsysrect import CoordSys3D
+    >>> from sympy.vector.functions import orthogonalize
+    >>> C = CoordSys3D('C')
+    >>> i, j, k = C.base_vectors()
+    >>> v1 = i + 2*j
+    >>> v2 = 2*i + 3*j
+    >>> orthogonalize(v1, v2)
+    [C.i + 2*C.j, 2/5*C.i + (-1/5)*C.j]
+
+    References
+    ==========
+
+    .. [1] https://en.wikipedia.org/wiki/Gram-Schmidt_process
+
+    """
+
+    if not all(isinstance(vec, Vector) for vec in vlist):
+        raise TypeError('Each element must be of Type Vector')
+
+    ortho_vlist = []
+    for i, term in enumerate(vlist):
+        for j in range(i):
+            term -= ortho_vlist[j].projection(vlist[i])
+        # TODO : The following line introduces a performance issue
+        # and needs to be changed once a good solution for issue #10279 is
+        # found.
+        if simplify(term).equals(Vector.zero):
+            raise ValueError("Vector set not linearly independent")
+        ortho_vlist.append(term)
+
+    if orthonormal:
+        ortho_vlist = [vec.normalize() for vec in ortho_vlist]
+
+    return ortho_vlist
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/implicitregion.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/implicitregion.py
new file mode 100644
index 0000000000..e6527a5b05
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/implicitregion.py
@@ -0,0 +1,502 @@
+from sympy import S, Rational, gcd, sqrt, sign, symbols, Complement
+from sympy.core import Basic, Tuple, diff, expand, Eq, Integer
+from sympy.core.compatibility import ordered
+from sympy.core.symbol import _symbol
+from sympy.solvers import solveset, nonlinsolve, diophantine
+from sympy.polys import total_degree
+from sympy.geometry import Point
+from sympy.ntheory.factor_ import core
+
+
+class ImplicitRegion(Basic):
+    """
+    Represents an implicit region in space.
+
+    Examples
+    ========
+
+    >>> from sympy import Eq
+    >>> from sympy.abc import x, y, z, t
+    >>> from sympy.vector import ImplicitRegion
+
+    >>> ImplicitRegion((x, y), x**2 + y**2 - 4)
+    ImplicitRegion((x, y), x**2 + y**2 - 4)
+    >>> ImplicitRegion((x, y), Eq(y*x, 1))
+    ImplicitRegion((x, y), x*y - 1)
+
+    >>> parabola = ImplicitRegion((x, y), y**2 - 4*x)
+    >>> parabola.degree
+    2
+    >>> parabola.equation
+    -4*x + y**2
+    >>> parabola.rational_parametrization(t)
+    (4/t**2, 4/t)
+
+    >>> r = ImplicitRegion((x, y, z), Eq(z, x**2 + y**2))
+    >>> r.variables
+    (x, y, z)
+    >>> r.singular_points()
+    FiniteSet((0, 0, 0))
+    >>> r.regular_point()
+    (-10, -10, 200)
+
+    Parameters
+    ==========
+
+    variables : tuple to map variables in implicit equation to base scalars.
+
+    equation : An expression or Eq denoting the implicit equation of the region.
+
+    """
+    def __new__(cls, variables, equation):
+        if not isinstance(variables, Tuple):
+            variables = Tuple(*variables)
+
+        if isinstance(equation, Eq):
+            equation = equation.lhs - equation.rhs
+
+        return super().__new__(cls, variables, equation)
+
+    @property
+    def variables(self):
+        return self.args[0]
+
+    @property
+    def equation(self):
+        return self.args[1]
+
+    @property
+    def degree(self):
+        return total_degree(self.equation)
+
+    def regular_point(self):
+        """
+        Returns a point on the implicit region.
+
+        Examples
+        ========
+
+        >>> from sympy.abc import x, y, z
+        >>> from sympy.vector import ImplicitRegion
+        >>> circle = ImplicitRegion((x, y), (x + 2)**2 + (y - 3)**2 - 16)
+        >>> circle.regular_point()
+        (-2, -1)
+        >>> parabola = ImplicitRegion((x, y), x**2 - 4*y)
+        >>> parabola.regular_point()
+        (0, 0)
+        >>> r = ImplicitRegion((x, y, z), (x + y + z)**4)
+        >>> r.regular_point()
+        (-10, -10, 20)
+
+        References
+        ==========
+
+        - Erik Hillgarter, "Rational Points on Conics", Diploma Thesis, RISC-Linz,
+          J. Kepler Universitat Linz, 1996. Availaible:
+          https://www3.risc.jku.at/publications/download/risc_1355/Rational%20Points%20on%20Conics.pdf
+
+        """
+        equation = self.equation
+
+        if len(self.variables) == 1:
+            return (list(solveset(equation, self.variables[0], domain=S.Reals))[0],)
+        elif len(self.variables) == 2:
+
+            if self.degree == 2:
+                coeffs = a, b, c, d, e, f = conic_coeff(self.variables, equation)
+
+                if b**2 == 4*a*c:
+                    x_reg, y_reg = self._regular_point_parabola(*coeffs)
+                else:
+                    x_reg, y_reg = self._regular_point_ellipse(*coeffs)
+                return x_reg, y_reg
+
+        if len(self.variables) == 3:
+            x, y, z = self.variables
+
+            for x_reg in range(-10, 10):
+                for y_reg in range(-10, 10):
+                    if not solveset(equation.subs({x: x_reg, y: y_reg}), self.variables[2], domain=S.Reals).is_empty:
+                        return (x_reg, y_reg, list(solveset(equation.subs({x: x_reg, y: y_reg})))[0])
+
+        if len(self.singular_points()) != 0:
+            return list[self.singular_points()][0]
+
+        raise NotImplementedError()
+
+    def _regular_point_parabola(self, a, b, c, d, e, f):
+            ok = (a, d) != (0, 0) and (c, e) != (0, 0) and b**2 == 4*a*c and (a, c) != (0, 0)
+
+            if not ok:
+                raise ValueError("Rational Point on the conic does not exist")
+
+            if a != 0:
+                d_dash, f_dash = (4*a*e - 2*b*d, 4*a*f - d**2)
+                if d_dash != 0:
+                    y_reg = -f_dash/d_dash
+                    x_reg = -(d + b*y_reg)/(2*a)
+                else:
+                    ok = False
+            elif c != 0:
+                d_dash, f_dash = (4*c*d - 2*b*e, 4*c*f - e**2)
+                if d_dash != 0:
+                    x_reg = -f_dash/d_dash
+                    y_reg = -(e + b*x_reg)/(2*c)
+                else:
+                    ok = False
+
+            if ok:
+                return x_reg, y_reg
+            else:
+                raise ValueError("Rational Point on the conic does not exist")
+
+    def _regular_point_ellipse(self, a, b, c, d, e, f):
+            D = 4*a*c - b**2
+            ok = D
+
+            if not ok:
+                raise ValueError("Rational Point on the conic does not exist")
+
+            if a == 0 and c == 0:
+                K = -1
+                L = 4*(d*e - b*f)
+            elif c != 0:
+                K = D
+                L = 4*c**2*d**2 - 4*b*c*d*e + 4*a*c*e**2 + 4*b**2*c*f - 16*a*c**2*f
+            else:
+                K = D
+                L = 4*a**2*e**2 - 4*b*a*d*e + 4*b**2*a*f
+
+            ok = L != 0 and not(K > 0 and L < 0)
+            if not ok:
+                raise ValueError("Rational Point on the conic does not exist")
+
+            K = Rational(K).limit_denominator(10**12)
+            L = Rational(L).limit_denominator(10**12)
+
+            k1, k2 = K.p, K.q
+            l1, l2 = L.p, L.q
+            g = gcd(k2, l2)
+
+            a1 = (l2*k2)/g
+            b1 = (k1*l2)/g
+            c1 = -(l1*k2)/g
+            a2 = sign(a1)*core(abs(a1), 2)
+            r1 = sqrt(a1/a2)
+            b2 = sign(b1)*core(abs(b1), 2)
+            r2 = sqrt(b1/b2)
+            c2 = sign(c1)*core(abs(c1), 2)
+            r3 = sqrt(c1/c2)
+
+            g = gcd(gcd(a2, b2), c2)
+            a2 = a2/g
+            b2 = b2/g
+            c2 = c2/g
+
+            g1 = gcd(a2, b2)
+            a2 = a2/g1
+            b2 = b2/g1
+            c2 = c2*g1
+
+            g2 = gcd(a2,c2)
+            a2 = a2/g2
+            b2 = b2*g2
+            c2 = c2/g2
+
+            g3 = gcd(b2, c2)
+            a2 = a2*g3
+            b2 = b2/g3
+            c2 = c2/g3
+
+            x, y, z = symbols("x y z")
+            eq = a2*x**2 + b2*y**2 + c2*z**2
+
+            solutions = diophantine(eq)
+
+            if len(solutions) == 0:
+                raise ValueError("Rational Point on the conic does not exist")
+
+            flag = False
+            for sol in solutions:
+                syms = Tuple(*sol).free_symbols
+                rep = {s: 3 for s in syms}
+                sol_z = sol[2]
+
+                if sol_z == 0:
+                    flag = True
+                    continue
+
+                if not (isinstance(sol_z, Integer) or isinstance(sol_z, int)):
+                    syms_z = sol_z.free_symbols
+
+                    if len(syms_z) == 1:
+                        p = next(iter(syms_z))
+                        p_values = Complement(S.Integers, solveset(Eq(sol_z, 0), p, S.Integers))
+                        rep[p] = next(iter(p_values))
+
+                    if len(syms_z) == 2:
+                        p, q = list(ordered(syms_z))
+
+                        for i in S.Integers:
+                            subs_sol_z = sol_z.subs(p, i)
+                            q_values = Complement(S.Integers, solveset(Eq(subs_sol_z, 0), q, S.Integers))
+
+                            if not q_values.is_empty:
+                                rep[p] = i
+                                rep[q] = next(iter(q_values))
+                                break
+
+                    if len(syms) != 0:
+                        x, y, z = tuple(s.subs(rep) for s in sol)
+                    else:
+                        x, y, z =   sol
+                    flag = False
+                    break
+
+            if flag:
+                raise ValueError("Rational Point on the conic does not exist")
+
+            x = (x*g3)/r1
+            y = (y*g2)/r2
+            z = (z*g1)/r3
+            x = x/z
+            y = y/z
+
+            if a == 0 and c == 0:
+                x_reg = (x + y - 2*e)/(2*b)
+                y_reg = (x - y - 2*d)/(2*b)
+            elif c != 0:
+                x_reg = (x - 2*d*c + b*e)/K
+                y_reg = (y - b*x_reg - e)/(2*c)
+            else:
+                y_reg = (x - 2*e*a + b*d)/K
+                x_reg = (y - b*y_reg - d)/(2*a)
+
+            return x_reg, y_reg
+
+    def singular_points(self):
+        """
+        Returns a set of singular points of the region.
+
+        The singular points are those points on the region
+        where all partial derivatives vanish.
+
+        Examples
+        ========
+
+        >>> from sympy.abc import x, y
+        >>> from sympy.vector import ImplicitRegion
+        >>> I = ImplicitRegion((x, y), (y-1)**2 -x**3 + 2*x**2 -x)
+        >>> I.singular_points()
+        FiniteSet((1, 1))
+
+        """
+        eq_list = [self.equation]
+        for var in self.variables:
+            eq_list += [diff(self.equation, var)]
+
+        return nonlinsolve(eq_list, list(self.variables))
+
+    def multiplicity(self, point):
+        """
+        Returns the multiplicity of a singular point on the region.
+
+        A singular point (x,y) of region is said to be of multiplicity m
+        if all the partial derivatives off to order m - 1 vanish there.
+
+        Examples
+        ========
+
+        >>> from sympy.abc import x, y, z
+        >>> from sympy.vector import ImplicitRegion
+        >>> I = ImplicitRegion((x, y, z), x**2 + y**3 - z**4)
+        >>> I.singular_points()
+        FiniteSet((0, 0, 0))
+        >>> I.multiplicity((0, 0, 0))
+        2
+
+        """
+        if isinstance(point, Point):
+            point = point.args
+
+        modified_eq = self.equation
+
+        for i, var in enumerate(self.variables):
+            modified_eq = modified_eq.subs(var, var + point[i])
+        modified_eq = expand(modified_eq)
+
+        if len(modified_eq.args) != 0:
+            terms = modified_eq.args
+            m = min([total_degree(term) for term in terms])
+        else:
+            terms = modified_eq
+            m = total_degree(terms)
+
+        return m
+
+    def rational_parametrization(self, parameters=('t', 's'), reg_point=None):
+        """
+        Returns the rational parametrization of implict region.
+
+        Examples
+        ========
+
+        >>> from sympy import Eq
+        >>> from sympy.abc import x, y, z, s, t
+        >>> from sympy.vector import ImplicitRegion
+
+        >>> parabola = ImplicitRegion((x, y), y**2 - 4*x)
+        >>> parabola.rational_parametrization()
+        (4/t**2, 4/t)
+
+        >>> circle = ImplicitRegion((x, y), Eq(x**2 + y**2, 4))
+        >>> circle.rational_parametrization()
+        (4*t/(t**2 + 1), 4*t**2/(t**2 + 1) - 2)
+
+        >>> I = ImplicitRegion((x, y), x**3 + x**2 - y**2)
+        >>> I.rational_parametrization()
+        (t**2 - 1, t*(t**2 - 1))
+
+        >>> cubic_curve = ImplicitRegion((x, y), x**3 + x**2 - y**2)
+        >>> cubic_curve.rational_parametrization(parameters=(t))
+        (t**2 - 1, t*(t**2 - 1))
+
+        >>> sphere = ImplicitRegion((x, y, z), x**2 + y**2 + z**2 - 4)
+        >>> sphere.rational_parametrization(parameters=(t, s))
+        (-2 + 4/(s**2 + t**2 + 1), 4*s/(s**2 + t**2 + 1), 4*t/(s**2 + t**2 + 1))
+
+        For some conics, regular_points() is unable to find a point on curve.
+        To calulcate the parametric representation in such cases, user need
+        to determine a point on the region and pass it using reg_point.
+
+        >>> c = ImplicitRegion((x, y), (x  - 1/2)**2 + (y)**2 - (1/4)**2)
+        >>> c.rational_parametrization(reg_point=(3/4, 0))
+        (0.75 - 0.5/(t**2 + 1), -0.5*t/(t**2 + 1))
+
+        References
+        ==========
+
+        - Christoph M. Hoffmann, "Conversion Methods between Parametric and
+          Implicit Curves and Surfaces", Purdue e-Pubs, 1990. Available:
+          https://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1827&context=cstech
+
+        """
+        equation = self.equation
+        degree = self.degree
+
+        if degree == 1:
+            if len(self.variables) == 1:
+                return (equation,)
+            elif len(self.variables) == 2:
+                x, y = self.variables
+                y_par = list(solveset(equation, y))[0]
+                return x, y_par
+            else:
+                raise NotImplementedError()
+
+        point = ()
+
+        # Finding the (n - 1) fold point of the monoid of degree
+        if degree == 2:
+            # For degree 2 curves, either a regular point or a singular point can be used.
+            if reg_point is not None:
+                # Using point provided by the user as regular point
+                if isinstance(point, Point):
+                    point = point.args
+                point = reg_point
+            else:
+                if len(self.singular_points()) != 0:
+                    point = list(self.singular_points())[0]
+                else:
+                    point = self.regular_point()
+
+        if len(self.singular_points()) != 0:
+            singular_points = self.singular_points()
+            for spoint in singular_points:
+                syms = Tuple(*spoint).free_symbols
+                rep = {s: 2 for s in syms}
+
+                if len(syms) != 0:
+                   spoint = tuple(s.subs(rep) for s in spoint)
+
+                if self.multiplicity(spoint) == degree - 1:
+                    point = spoint
+                    break
+
+        if len(point) == 0:
+            # The region in not a monoid
+            raise NotImplementedError()
+
+        modified_eq = equation
+
+        # Shifting the region such that fold point moves to origin
+        for i, var in enumerate(self.variables):
+            modified_eq = modified_eq.subs(var, var + point[i])
+        modified_eq = expand(modified_eq)
+
+        hn = hn_1 = 0
+        for term in modified_eq.args:
+            if total_degree(term) == degree:
+                hn += term
+            else:
+                hn_1 += term
+
+        hn_1 = -1*hn_1
+
+        if not isinstance(parameters, tuple):
+            parameters = (parameters,)
+
+        if len(self.variables) == 2:
+
+            parameter1 = parameters[0]
+            if parameter1 == 's':
+                # To avoid name conflict between parameters
+                s = _symbol('s_', real=True)
+            else:
+                s = _symbol('s', real=True)
+            t = _symbol(parameter1, real=True)
+
+            hn = hn.subs({self.variables[0]: s, self.variables[1]: t})
+            hn_1 = hn_1.subs({self.variables[0]: s, self.variables[1]: t})
+
+            x_par = (s*(hn_1/hn)).subs(s, 1) + point[0]
+            y_par = (t*(hn_1/hn)).subs(s, 1) + point[1]
+
+            return x_par, y_par
+
+        elif len(self.variables) == 3:
+
+            parameter1, parameter2 = parameters
+            if parameter1 == 'r' or parameter2 == 'r':
+                # To avoid name conflict between parameters
+                r = _symbol('r_', real=True)
+            else:
+                r = _symbol('r', real=True)
+            s = _symbol(parameter2, real=True)
+            t = _symbol(parameter1, real=True)
+
+            hn = hn.subs({self.variables[0]: r, self.variables[1]: s, self.variables[2]: t})
+            hn_1 = hn_1.subs({self.variables[0]: r, self.variables[1]: s, self.variables[2]: t})
+
+            x_par = (r*(hn_1/hn)).subs(r, 1) + point[0]
+            y_par = (s*(hn_1/hn)).subs(r, 1) + point[1]
+            z_par = (t*(hn_1/hn)).subs(r, 1) + point[2]
+
+            return x_par, y_par, z_par
+
+        raise NotImplementedError()
+
+def conic_coeff(variables, equation):
+    if total_degree(equation) != 2:
+        raise ValueError()
+    x = variables[0]
+    y = variables[1]
+
+    equation = expand(equation)
+    a = equation.coeff(x**2)
+    b = equation.coeff(x*y)
+    c = equation.coeff(y**2)
+    d = equation.coeff(x, 1).coeff(y, 0)
+    e = equation.coeff(y, 1).coeff(x, 0)
+    f = equation.coeff(x, 0).coeff(y, 0)
+    return a, b, c, d, e, f
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/integrals.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/integrals.py
new file mode 100644
index 0000000000..6984883f52
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/integrals.py
@@ -0,0 +1,207 @@
+from sympy import S, simplify
+from sympy.core import Basic, diff
+from sympy.matrices import Matrix
+from sympy.vector import (CoordSys3D, Vector, ParametricRegion,
+                        parametric_region_list, ImplicitRegion)
+from sympy.vector.operators import _get_coord_sys_from_expr
+from sympy.integrals import Integral, integrate
+from sympy.utilities.iterables import topological_sort, default_sort_key
+from sympy.geometry.entity import GeometryEntity
+
+
+class ParametricIntegral(Basic):
+    """
+    Represents integral of a scalar or vector field
+    over a Parametric Region
+
+    Examples
+    ========
+
+    >>> from sympy import cos, sin, pi
+    >>> from sympy.vector import CoordSys3D, ParametricRegion, ParametricIntegral
+    >>> from sympy.abc import r, t, theta, phi
+
+    >>> C = CoordSys3D('C')
+    >>> curve = ParametricRegion((3*t - 2, t + 1), (t, 1, 2))
+    >>> ParametricIntegral(C.x, curve)
+    5*sqrt(10)/2
+    >>> length = ParametricIntegral(1, curve)
+    >>> length
+    sqrt(10)
+    >>> semisphere = ParametricRegion((2*sin(phi)*cos(theta), 2*sin(phi)*sin(theta), 2*cos(phi)),\
+                            (theta, 0, 2*pi), (phi, 0, pi/2))
+    >>> ParametricIntegral(C.z, semisphere)
+    8*pi
+
+    >>> ParametricIntegral(C.j + C.k, ParametricRegion((r*cos(theta), r*sin(theta)), r, theta))
+    0
+
+    """
+
+    def __new__(cls, field, parametricregion):
+
+        coord_set = _get_coord_sys_from_expr(field)
+
+        if len(coord_set) == 0:
+            coord_sys = CoordSys3D('C')
+        elif len(coord_set) > 1:
+            raise ValueError
+        else:
+            coord_sys = next(iter(coord_set))
+
+        if parametricregion.dimensions == 0:
+            return S.Zero
+
+        base_vectors = coord_sys.base_vectors()
+        base_scalars = coord_sys.base_scalars()
+
+        parametricfield = field
+
+        r = Vector.zero
+        for i in range(len(parametricregion.definition)):
+            r += base_vectors[i]*parametricregion.definition[i]
+
+        if len(coord_set) != 0:
+            for i in range(len(parametricregion.definition)):
+                parametricfield = parametricfield.subs(base_scalars[i], parametricregion.definition[i])
+
+        if parametricregion.dimensions == 1:
+            parameter = parametricregion.parameters[0]
+
+            r_diff = diff(r, parameter)
+            lower, upper = parametricregion.limits[parameter][0], parametricregion.limits[parameter][1]
+
+            if isinstance(parametricfield, Vector):
+                integrand = simplify(r_diff.dot(parametricfield))
+            else:
+                integrand = simplify(r_diff.magnitude()*parametricfield)
+
+            result = integrate(integrand, (parameter, lower, upper))
+
+        elif parametricregion.dimensions == 2:
+            u, v = cls._bounds_case(parametricregion.parameters, parametricregion.limits)
+
+            r_u = diff(r, u)
+            r_v = diff(r, v)
+            normal_vector = simplify(r_u.cross(r_v))
+
+            if isinstance(parametricfield, Vector):
+                integrand = parametricfield.dot(normal_vector)
+            else:
+                integrand = parametricfield*normal_vector.magnitude()
+
+            integrand = simplify(integrand)
+
+            lower_u, upper_u = parametricregion.limits[u][0], parametricregion.limits[u][1]
+            lower_v, upper_v = parametricregion.limits[v][0], parametricregion.limits[v][1]
+
+            result = integrate(integrand, (u, lower_u, upper_u), (v, lower_v, upper_v))
+
+        else:
+            variables = cls._bounds_case(parametricregion.parameters, parametricregion.limits)
+            coeff = Matrix(parametricregion.definition).jacobian(variables).det()
+            integrand = simplify(parametricfield*coeff)
+
+            l = [(var, parametricregion.limits[var][0], parametricregion.limits[var][1]) for var in variables]
+            result = integrate(integrand, *l)
+
+        if not isinstance(result, Integral):
+            return result
+        else:
+            return super().__new__(cls, field, parametricregion)
+
+    @classmethod
+    def _bounds_case(cls, parameters, limits):
+
+        V = list(limits.keys())
+        E = list()
+
+        for p in V:
+            lower_p = limits[p][0]
+            upper_p = limits[p][1]
+
+            lower_p = lower_p.atoms()
+            upper_p = upper_p.atoms()
+            for q in V:
+                if p == q:
+                    continue
+                if lower_p.issuperset({q}) or upper_p.issuperset({q}):
+                    E.append((p, q))
+
+        if not E:
+            return parameters
+        else:
+            return topological_sort((V, E), key=default_sort_key)
+
+    @property
+    def field(self):
+        return self.args[0]
+
+    @property
+    def parametricregion(self):
+        return self.args[1]
+
+
+def vector_integrate(field, *region):
+    """
+    Compute the integral of a vector/scalar field
+    over a a region or a set of parameters.
+
+    Examples
+    ========
+    >>> from sympy.vector import CoordSys3D, ParametricRegion, vector_integrate
+    >>> from sympy.abc import x, y, t
+    >>> C = CoordSys3D('C')
+
+    >>> region = ParametricRegion((t, t**2), (t, 1, 5))
+    >>> vector_integrate(C.x*C.i, region)
+    12
+
+    Integrals over some objects of geometry module can also be calculated.
+
+    >>> from sympy.geometry import Point, Circle, Triangle
+    >>> c = Circle(Point(0, 2), 5)
+    >>> vector_integrate(C.x**2 + C.y**2, c)
+    290*pi
+    >>> triangle = Triangle(Point(-2, 3), Point(2, 3), Point(0, 5))
+    >>> vector_integrate(3*C.x**2*C.y*C.i + C.j, triangle)
+    -8
+
+    Integrals over some simple implicit regions can be computed. But in most cases,
+    it takes too long to compute over them. This is due to the expressions of parametric
+    representation becoming large.
+
+    >>> from sympy.vector import ImplicitRegion
+    >>> c2 = ImplicitRegion((x, y), (x - 2)**2 + (y - 1)**2 - 9)
+    >>> vector_integrate(1, c2)
+    12*pi
+
+    Integral of fields with respect to base scalars:
+
+    >>> vector_integrate(12*C.y**3, (C.y, 1, 3))
+    240
+    >>> vector_integrate(C.x**2*C.z, C.x)
+    C.x**3*C.z/3
+    >>> vector_integrate(C.x*C.i - C.y*C.k, C.x)
+    (Integral(C.x, C.x))*C.i + (Integral(-C.y, C.x))*C.k
+    >>> _.doit()
+    C.x**2/2*C.i + (-C.x*C.y)*C.k
+
+    """
+    if len(region) == 1:
+        if isinstance(region[0], ParametricRegion):
+            return ParametricIntegral(field, region[0])
+
+        if isinstance(region[0], ImplicitRegion):
+            region = parametric_region_list(region[0])[0]
+            return vector_integrate(field, region)
+
+        if isinstance(region[0], GeometryEntity):
+            regions_list = parametric_region_list(region[0])
+
+            result = 0
+            for reg in regions_list:
+                result += vector_integrate(field, reg)
+            return result
+
+    return integrate(field, *region)
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/operators.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/operators.py
new file mode 100644
index 0000000000..2f303ee690
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/operators.py
@@ -0,0 +1,367 @@
+import collections
+from sympy.core.expr import Expr
+from sympy.core import sympify, S, preorder_traversal
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.vector.vector import Vector, VectorMul, VectorAdd, Cross, Dot
+from sympy.vector.scalar import BaseScalar
+from sympy.utilities.exceptions import SymPyDeprecationWarning
+from sympy.core.function import Derivative
+from sympy import Add, Mul
+
+
+def _get_coord_systems(expr):
+    g = preorder_traversal(expr)
+    ret = set()
+    for i in g:
+        if isinstance(i, CoordSys3D):
+            ret.add(i)
+            g.skip()
+    return frozenset(ret)
+
+
+def _get_coord_sys_from_expr(expr, coord_sys=None):
+    """
+    expr : expression
+        The coordinate system is extracted from this parameter.
+    """
+
+    # TODO: Remove this line when warning from issue #12884 will be removed
+    if coord_sys is not None:
+        SymPyDeprecationWarning(
+            feature="coord_sys parameter",
+            useinstead="do not use it",
+            deprecated_since_version="1.1",
+            issue=12884,
+        ).warn()
+
+    return _get_coord_systems(expr)
+
+
+def _split_mul_args_wrt_coordsys(expr):
+    d = collections.defaultdict(lambda: S.One)
+    for i in expr.args:
+        d[_get_coord_systems(i)] *= i
+    return list(d.values())
+
+
+class Gradient(Expr):
+    """
+    Represents unevaluated Gradient.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, Gradient
+    >>> R = CoordSys3D('R')
+    >>> s = R.x*R.y*R.z
+    >>> Gradient(s)
+    Gradient(R.x*R.y*R.z)
+
+    """
+
+    def __new__(cls, expr):
+        expr = sympify(expr)
+        obj = Expr.__new__(cls, expr)
+        obj._expr = expr
+        return obj
+
+    def doit(self, **kwargs):
+        return gradient(self._expr, doit=True)
+
+
+class Divergence(Expr):
+    """
+    Represents unevaluated Divergence.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, Divergence
+    >>> R = CoordSys3D('R')
+    >>> v = R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k
+    >>> Divergence(v)
+    Divergence(R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k)
+
+    """
+
+    def __new__(cls, expr):
+        expr = sympify(expr)
+        obj = Expr.__new__(cls, expr)
+        obj._expr = expr
+        return obj
+
+    def doit(self, **kwargs):
+        return divergence(self._expr, doit=True)
+
+
+class Curl(Expr):
+    """
+    Represents unevaluated Curl.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, Curl
+    >>> R = CoordSys3D('R')
+    >>> v = R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k
+    >>> Curl(v)
+    Curl(R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k)
+
+    """
+
+    def __new__(cls, expr):
+        expr = sympify(expr)
+        obj = Expr.__new__(cls, expr)
+        obj._expr = expr
+        return obj
+
+    def doit(self, **kwargs):
+        return curl(self._expr, doit=True)
+
+
+def curl(vect, coord_sys=None, doit=True):
+    """
+    Returns the curl of a vector field computed wrt the base scalars
+    of the given coordinate system.
+
+    Parameters
+    ==========
+
+    vect : Vector
+        The vector operand
+
+    coord_sys : CoordSys3D
+        The coordinate system to calculate the gradient in.
+        Deprecated since version 1.1
+
+    doit : bool
+        If True, the result is returned after calling .doit() on
+        each component. Else, the returned expression contains
+        Derivative instances
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, curl
+    >>> R = CoordSys3D('R')
+    >>> v1 = R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k
+    >>> curl(v1)
+    0
+    >>> v2 = R.x*R.y*R.z*R.i
+    >>> curl(v2)
+    R.x*R.y*R.j + (-R.x*R.z)*R.k
+
+    """
+
+    coord_sys = _get_coord_sys_from_expr(vect, coord_sys)
+
+    if len(coord_sys) == 0:
+        return Vector.zero
+    elif len(coord_sys) == 1:
+        coord_sys = next(iter(coord_sys))
+        i, j, k = coord_sys.base_vectors()
+        x, y, z = coord_sys.base_scalars()
+        h1, h2, h3 = coord_sys.lame_coefficients()
+        vectx = vect.dot(i)
+        vecty = vect.dot(j)
+        vectz = vect.dot(k)
+        outvec = Vector.zero
+        outvec += (Derivative(vectz * h3, y) -
+                   Derivative(vecty * h2, z)) * i / (h2 * h3)
+        outvec += (Derivative(vectx * h1, z) -
+                   Derivative(vectz * h3, x)) * j / (h1 * h3)
+        outvec += (Derivative(vecty * h2, x) -
+                   Derivative(vectx * h1, y)) * k / (h2 * h1)
+
+        if doit:
+            return outvec.doit()
+        return outvec
+    else:
+        if isinstance(vect, (Add, VectorAdd)):
+            from sympy.vector import express
+            try:
+                cs = next(iter(coord_sys))
+                args = [express(i, cs, variables=True) for i in vect.args]
+            except ValueError:
+                args = vect.args
+            return VectorAdd.fromiter(curl(i, doit=doit) for i in args)
+        elif isinstance(vect, (Mul, VectorMul)):
+            vector = [i for i in vect.args if isinstance(i, (Vector, Cross, Gradient))][0]
+            scalar = Mul.fromiter(i for i in vect.args if not isinstance(i, (Vector, Cross, Gradient)))
+            res = Cross(gradient(scalar), vector).doit() + scalar*curl(vector, doit=doit)
+            if doit:
+                return res.doit()
+            return res
+        elif isinstance(vect, (Cross, Curl, Gradient)):
+            return Curl(vect)
+        else:
+            raise Curl(vect)
+
+
+def divergence(vect, coord_sys=None, doit=True):
+    """
+    Returns the divergence of a vector field computed wrt the base
+    scalars of the given coordinate system.
+
+    Parameters
+    ==========
+
+    vector : Vector
+        The vector operand
+
+    coord_sys : CoordSys3D
+        The coordinate system to calculate the gradient in
+        Deprecated since version 1.1
+
+    doit : bool
+        If True, the result is returned after calling .doit() on
+        each component. Else, the returned expression contains
+        Derivative instances
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, divergence
+    >>> R = CoordSys3D('R')
+    >>> v1 = R.x*R.y*R.z * (R.i+R.j+R.k)
+
+    >>> divergence(v1)
+    R.x*R.y + R.x*R.z + R.y*R.z
+    >>> v2 = 2*R.y*R.z*R.j
+    >>> divergence(v2)
+    2*R.z
+
+    """
+    coord_sys = _get_coord_sys_from_expr(vect, coord_sys)
+    if len(coord_sys) == 0:
+        return S.Zero
+    elif len(coord_sys) == 1:
+        if isinstance(vect, (Cross, Curl, Gradient)):
+            return Divergence(vect)
+        # TODO: is case of many coord systems, this gets a random one:
+        coord_sys = next(iter(coord_sys))
+        i, j, k = coord_sys.base_vectors()
+        x, y, z = coord_sys.base_scalars()
+        h1, h2, h3 = coord_sys.lame_coefficients()
+        vx = _diff_conditional(vect.dot(i), x, h2, h3) \
+             / (h1 * h2 * h3)
+        vy = _diff_conditional(vect.dot(j), y, h3, h1) \
+             / (h1 * h2 * h3)
+        vz = _diff_conditional(vect.dot(k), z, h1, h2) \
+             / (h1 * h2 * h3)
+        res = vx + vy + vz
+        if doit:
+            return res.doit()
+        return res
+    else:
+        if isinstance(vect, (Add, VectorAdd)):
+            return Add.fromiter(divergence(i, doit=doit) for i in vect.args)
+        elif isinstance(vect, (Mul, VectorMul)):
+            vector = [i for i in vect.args if isinstance(i, (Vector, Cross, Gradient))][0]
+            scalar = Mul.fromiter(i for i in vect.args if not isinstance(i, (Vector, Cross, Gradient)))
+            res = Dot(vector, gradient(scalar)) + scalar*divergence(vector, doit=doit)
+            if doit:
+                return res.doit()
+            return res
+        elif isinstance(vect, (Cross, Curl, Gradient)):
+            return Divergence(vect)
+        else:
+            raise Divergence(vect)
+
+
+def gradient(scalar_field, coord_sys=None, doit=True):
+    """
+    Returns the vector gradient of a scalar field computed wrt the
+    base scalars of the given coordinate system.
+
+    Parameters
+    ==========
+
+    scalar_field : SymPy Expr
+        The scalar field to compute the gradient of
+
+    coord_sys : CoordSys3D
+        The coordinate system to calculate the gradient in
+        Deprecated since version 1.1
+
+    doit : bool
+        If True, the result is returned after calling .doit() on
+        each component. Else, the returned expression contains
+        Derivative instances
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, gradient
+    >>> R = CoordSys3D('R')
+    >>> s1 = R.x*R.y*R.z
+    >>> gradient(s1)
+    R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k
+    >>> s2 = 5*R.x**2*R.z
+    >>> gradient(s2)
+    10*R.x*R.z*R.i + 5*R.x**2*R.k
+
+    """
+    coord_sys = _get_coord_sys_from_expr(scalar_field, coord_sys)
+
+    if len(coord_sys) == 0:
+        return Vector.zero
+    elif len(coord_sys) == 1:
+        coord_sys = next(iter(coord_sys))
+        h1, h2, h3 = coord_sys.lame_coefficients()
+        i, j, k = coord_sys.base_vectors()
+        x, y, z = coord_sys.base_scalars()
+        vx = Derivative(scalar_field, x) / h1
+        vy = Derivative(scalar_field, y) / h2
+        vz = Derivative(scalar_field, z) / h3
+
+        if doit:
+            return (vx * i + vy * j + vz * k).doit()
+        return vx * i + vy * j + vz * k
+    else:
+        if isinstance(scalar_field, (Add, VectorAdd)):
+            return VectorAdd.fromiter(gradient(i) for i in scalar_field.args)
+        if isinstance(scalar_field, (Mul, VectorMul)):
+            s = _split_mul_args_wrt_coordsys(scalar_field)
+            return VectorAdd.fromiter(scalar_field / i * gradient(i) for i in s)
+        return Gradient(scalar_field)
+
+
+class Laplacian(Expr):
+    """
+    Represents unevaluated Laplacian.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, Laplacian
+    >>> R = CoordSys3D('R')
+    >>> v = 3*R.x**3*R.y**2*R.z**3
+    >>> Laplacian(v)
+    Laplacian(3*R.x**3*R.y**2*R.z**3)
+
+    """
+
+    def __new__(cls, expr):
+        expr = sympify(expr)
+        obj = Expr.__new__(cls, expr)
+        obj._expr = expr
+        return obj
+
+    def doit(self, **kwargs):
+        from sympy.vector.functions import laplacian
+        return laplacian(self._expr)
+
+
+def _diff_conditional(expr, base_scalar, coeff_1, coeff_2):
+    """
+    First re-expresses expr in the system that base_scalar belongs to.
+    If base_scalar appears in the re-expressed form, differentiates
+    it wrt base_scalar.
+    Else, returns 0
+    """
+    from sympy.vector.functions import express
+    new_expr = express(expr, base_scalar.system, variables=True)
+    if base_scalar in new_expr.atoms(BaseScalar):
+        return Derivative(coeff_1 * coeff_2 * new_expr, base_scalar)
+    return S.Zero
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/orienters.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/orienters.py
new file mode 100644
index 0000000000..bcaab04a8e
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/orienters.py
@@ -0,0 +1,396 @@
+from sympy.core.basic import Basic
+from sympy import (sympify, eye, sin, cos, rot_axis1, rot_axis2,
+                   rot_axis3, ImmutableMatrix as Matrix)
+from sympy.core.cache import cacheit
+from sympy.core.symbol import Str
+import sympy.vector
+
+
+class Orienter(Basic):
+    """
+    Super-class for all orienter classes.
+    """
+
+    def rotation_matrix(self):
+        """
+        The rotation matrix corresponding to this orienter
+        instance.
+        """
+        return self._parent_orient
+
+
+class AxisOrienter(Orienter):
+    """
+    Class to denote an axis orienter.
+    """
+
+    def __new__(cls, angle, axis):
+        if not isinstance(axis, sympy.vector.Vector):
+            raise TypeError("axis should be a Vector")
+        angle = sympify(angle)
+
+        obj = super().__new__(cls, angle, axis)
+        obj._angle = angle
+        obj._axis = axis
+
+        return obj
+
+    def __init__(self, angle, axis):
+        """
+        Axis rotation is a rotation about an arbitrary axis by
+        some angle. The angle is supplied as a SymPy expr scalar, and
+        the axis is supplied as a Vector.
+
+        Parameters
+        ==========
+
+        angle : Expr
+            The angle by which the new system is to be rotated
+
+        axis : Vector
+            The axis around which the rotation has to be performed
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import symbols
+        >>> q1 = symbols('q1')
+        >>> N = CoordSys3D('N')
+        >>> from sympy.vector import AxisOrienter
+        >>> orienter = AxisOrienter(q1, N.i + 2 * N.j)
+        >>> B = N.orient_new('B', (orienter, ))
+
+        """
+        # Dummy initializer for docstrings
+        pass
+
+    @cacheit
+    def rotation_matrix(self, system):
+        """
+        The rotation matrix corresponding to this orienter
+        instance.
+
+        Parameters
+        ==========
+
+        system : CoordSys3D
+            The coordinate system wrt which the rotation matrix
+            is to be computed
+        """
+
+        axis = sympy.vector.express(self.axis, system).normalize()
+        axis = axis.to_matrix(system)
+        theta = self.angle
+        parent_orient = ((eye(3) - axis * axis.T) * cos(theta) +
+                         Matrix([[0, -axis[2], axis[1]],
+                                 [axis[2], 0, -axis[0]],
+                                 [-axis[1], axis[0], 0]]) * sin(theta) +
+                         axis * axis.T)
+        parent_orient = parent_orient.T
+        return parent_orient
+
+    @property
+    def angle(self):
+        return self._angle
+
+    @property
+    def axis(self):
+        return self._axis
+
+
+class ThreeAngleOrienter(Orienter):
+    """
+    Super-class for Body and Space orienters.
+    """
+
+    def __new__(cls, angle1, angle2, angle3, rot_order):
+        if isinstance(rot_order, Str):
+            rot_order = rot_order.name
+
+        approved_orders = ('123', '231', '312', '132', '213',
+                           '321', '121', '131', '212', '232',
+                           '313', '323', '')
+        original_rot_order = rot_order
+        rot_order = str(rot_order).upper()
+        if not (len(rot_order) == 3):
+            raise TypeError('rot_order should be a str of length 3')
+        rot_order = [i.replace('X', '1') for i in rot_order]
+        rot_order = [i.replace('Y', '2') for i in rot_order]
+        rot_order = [i.replace('Z', '3') for i in rot_order]
+        rot_order = ''.join(rot_order)
+        if rot_order not in approved_orders:
+            raise TypeError('Invalid rot_type parameter')
+        a1 = int(rot_order[0])
+        a2 = int(rot_order[1])
+        a3 = int(rot_order[2])
+        angle1 = sympify(angle1)
+        angle2 = sympify(angle2)
+        angle3 = sympify(angle3)
+        if cls._in_order:
+            parent_orient = (_rot(a1, angle1) *
+                             _rot(a2, angle2) *
+                             _rot(a3, angle3))
+        else:
+            parent_orient = (_rot(a3, angle3) *
+                             _rot(a2, angle2) *
+                             _rot(a1, angle1))
+        parent_orient = parent_orient.T
+
+        obj = super().__new__(
+            cls, angle1, angle2, angle3, Str(rot_order))
+        obj._angle1 = angle1
+        obj._angle2 = angle2
+        obj._angle3 = angle3
+        obj._rot_order = original_rot_order
+        obj._parent_orient = parent_orient
+
+        return obj
+
+    @property
+    def angle1(self):
+        return self._angle1
+
+    @property
+    def angle2(self):
+        return self._angle2
+
+    @property
+    def angle3(self):
+        return self._angle3
+
+    @property
+    def rot_order(self):
+        return self._rot_order
+
+
+class BodyOrienter(ThreeAngleOrienter):
+    """
+    Class to denote a body-orienter.
+    """
+
+    _in_order = True
+
+    def __new__(cls, angle1, angle2, angle3, rot_order):
+        obj = ThreeAngleOrienter.__new__(cls, angle1, angle2, angle3,
+                                         rot_order)
+        return obj
+
+    def __init__(self, angle1, angle2, angle3, rot_order):
+        """
+        Body orientation takes this coordinate system through three
+        successive simple rotations.
+
+        Body fixed rotations include both Euler Angles and
+        Tait-Bryan Angles, see https://en.wikipedia.org/wiki/Euler_angles.
+
+        Parameters
+        ==========
+
+        angle1, angle2, angle3 : Expr
+            Three successive angles to rotate the coordinate system by
+
+        rotation_order : string
+            String defining the order of axes for rotation
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D, BodyOrienter
+        >>> from sympy import symbols
+        >>> q1, q2, q3 = symbols('q1 q2 q3')
+        >>> N = CoordSys3D('N')
+
+        A 'Body' fixed rotation is described by three angles and
+        three body-fixed rotation axes. To orient a coordinate system D
+        with respect to N, each sequential rotation is always about
+        the orthogonal unit vectors fixed to D. For example, a '123'
+        rotation will specify rotations about N.i, then D.j, then
+        D.k. (Initially, D.i is same as N.i)
+        Therefore,
+
+        >>> body_orienter = BodyOrienter(q1, q2, q3, '123')
+        >>> D = N.orient_new('D', (body_orienter, ))
+
+        is same as
+
+        >>> from sympy.vector import AxisOrienter
+        >>> axis_orienter1 = AxisOrienter(q1, N.i)
+        >>> D = N.orient_new('D', (axis_orienter1, ))
+        >>> axis_orienter2 = AxisOrienter(q2, D.j)
+        >>> D = D.orient_new('D', (axis_orienter2, ))
+        >>> axis_orienter3 = AxisOrienter(q3, D.k)
+        >>> D = D.orient_new('D', (axis_orienter3, ))
+
+        Acceptable rotation orders are of length 3, expressed in XYZ or
+        123, and cannot have a rotation about about an axis twice in a row.
+
+        >>> body_orienter1 = BodyOrienter(q1, q2, q3, '123')
+        >>> body_orienter2 = BodyOrienter(q1, q2, 0, 'ZXZ')
+        >>> body_orienter3 = BodyOrienter(0, 0, 0, 'XYX')
+
+        """
+        # Dummy initializer for docstrings
+        pass
+
+
+class SpaceOrienter(ThreeAngleOrienter):
+    """
+    Class to denote a space-orienter.
+    """
+
+    _in_order = False
+
+    def __new__(cls, angle1, angle2, angle3, rot_order):
+        obj = ThreeAngleOrienter.__new__(cls, angle1, angle2, angle3,
+                                         rot_order)
+        return obj
+
+    def __init__(self, angle1, angle2, angle3, rot_order):
+        """
+        Space rotation is similar to Body rotation, but the rotations
+        are applied in the opposite order.
+
+        Parameters
+        ==========
+
+        angle1, angle2, angle3 : Expr
+            Three successive angles to rotate the coordinate system by
+
+        rotation_order : string
+            String defining the order of axes for rotation
+
+        See Also
+        ========
+
+        BodyOrienter : Orienter to orient systems wrt Euler angles.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D, SpaceOrienter
+        >>> from sympy import symbols
+        >>> q1, q2, q3 = symbols('q1 q2 q3')
+        >>> N = CoordSys3D('N')
+
+        To orient a coordinate system D with respect to N, each
+        sequential rotation is always about N's orthogonal unit vectors.
+        For example, a '123' rotation will specify rotations about
+        N.i, then N.j, then N.k.
+        Therefore,
+
+        >>> space_orienter = SpaceOrienter(q1, q2, q3, '312')
+        >>> D = N.orient_new('D', (space_orienter, ))
+
+        is same as
+
+        >>> from sympy.vector import AxisOrienter
+        >>> axis_orienter1 = AxisOrienter(q1, N.i)
+        >>> B = N.orient_new('B', (axis_orienter1, ))
+        >>> axis_orienter2 = AxisOrienter(q2, N.j)
+        >>> C = B.orient_new('C', (axis_orienter2, ))
+        >>> axis_orienter3 = AxisOrienter(q3, N.k)
+        >>> D = C.orient_new('C', (axis_orienter3, ))
+
+        """
+        # Dummy initializer for docstrings
+        pass
+
+
+class QuaternionOrienter(Orienter):
+    """
+    Class to denote a quaternion-orienter.
+    """
+
+    def __new__(cls, q0, q1, q2, q3):
+        q0 = sympify(q0)
+        q1 = sympify(q1)
+        q2 = sympify(q2)
+        q3 = sympify(q3)
+        parent_orient = (Matrix([[q0 ** 2 + q1 ** 2 - q2 ** 2 -
+                                  q3 ** 2,
+                                  2 * (q1 * q2 - q0 * q3),
+                                  2 * (q0 * q2 + q1 * q3)],
+                                 [2 * (q1 * q2 + q0 * q3),
+                                  q0 ** 2 - q1 ** 2 +
+                                  q2 ** 2 - q3 ** 2,
+                                  2 * (q2 * q3 - q0 * q1)],
+                                 [2 * (q1 * q3 - q0 * q2),
+                                  2 * (q0 * q1 + q2 * q3),
+                                  q0 ** 2 - q1 ** 2 -
+                                  q2 ** 2 + q3 ** 2]]))
+        parent_orient = parent_orient.T
+
+        obj = super().__new__(cls, q0, q1, q2, q3)
+        obj._q0 = q0
+        obj._q1 = q1
+        obj._q2 = q2
+        obj._q3 = q3
+        obj._parent_orient = parent_orient
+
+        return obj
+
+    def __init__(self, angle1, angle2, angle3, rot_order):
+        """
+        Quaternion orientation orients the new CoordSys3D with
+        Quaternions, defined as a finite rotation about lambda, a unit
+        vector, by some amount theta.
+
+        This orientation is described by four parameters:
+
+        q0 = cos(theta/2)
+
+        q1 = lambda_x sin(theta/2)
+
+        q2 = lambda_y sin(theta/2)
+
+        q3 = lambda_z sin(theta/2)
+
+        Quaternion does not take in a rotation order.
+
+        Parameters
+        ==========
+
+        q0, q1, q2, q3 : Expr
+            The quaternions to rotate the coordinate system by
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> from sympy import symbols
+        >>> q0, q1, q2, q3 = symbols('q0 q1 q2 q3')
+        >>> N = CoordSys3D('N')
+        >>> from sympy.vector import QuaternionOrienter
+        >>> q_orienter = QuaternionOrienter(q0, q1, q2, q3)
+        >>> B = N.orient_new('B', (q_orienter, ))
+
+        """
+        # Dummy initializer for docstrings
+        pass
+
+    @property
+    def q0(self):
+        return self._q0
+
+    @property
+    def q1(self):
+        return self._q1
+
+    @property
+    def q2(self):
+        return self._q2
+
+    @property
+    def q3(self):
+        return self._q3
+
+
+def _rot(axis, angle):
+    """DCM for simple axis 1, 2 or 3 rotations. """
+    if axis == 1:
+        return Matrix(rot_axis1(angle).T)
+    elif axis == 2:
+        return Matrix(rot_axis2(angle).T)
+    elif axis == 3:
+        return Matrix(rot_axis3(angle).T)
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/parametricregion.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/parametricregion.py
new file mode 100644
index 0000000000..c3cd6f0e0a
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/parametricregion.py
@@ -0,0 +1,188 @@
+from functools import singledispatch
+from sympy import pi, tan
+from sympy.simplify import trigsimp
+from sympy.core import Basic, Tuple
+from sympy.core.symbol import _symbol
+from sympy.solvers import solve
+from sympy.geometry import Point, Segment, Curve, Ellipse, Polygon
+from sympy.vector import ImplicitRegion
+
+
+class ParametricRegion(Basic):
+    """
+    Represents a parametric region in space.
+
+    Examples
+    ========
+
+    >>> from sympy import cos, sin, pi
+    >>> from sympy.abc import r, theta, t, a, b, x, y
+    >>> from sympy.vector import ParametricRegion
+
+    >>> ParametricRegion((t, t**2), (t, -1, 2))
+    ParametricRegion((t, t**2), (t, -1, 2))
+    >>> ParametricRegion((x, y), (x, 3, 4), (y, 5, 6))
+    ParametricRegion((x, y), (x, 3, 4), (y, 5, 6))
+    >>> ParametricRegion((r*cos(theta), r*sin(theta)), (r, -2, 2), (theta, 0, pi))
+    ParametricRegion((r*cos(theta), r*sin(theta)), (r, -2, 2), (theta, 0, pi))
+    >>> ParametricRegion((a*cos(t), b*sin(t)), t)
+    ParametricRegion((a*cos(t), b*sin(t)), t)
+
+    >>> circle = ParametricRegion((r*cos(theta), r*sin(theta)), r, (theta, 0, pi))
+    >>> circle.parameters
+    (r, theta)
+    >>> circle.definition
+    (r*cos(theta), r*sin(theta))
+    >>> circle.limits
+    {theta: (0, pi)}
+
+    Dimension of a parametric region determines whether a region is a curve, surface
+    or volume region. It does not represent its dimensions in space.
+
+    >>> circle.dimensions
+    1
+
+    Parameters
+    ==========
+
+    definition : tuple to define base scalars in terms of parameters.
+
+    bounds : Parameter or a tuple of length 3 to define parameter and corresponding lower and upper bound.
+
+    """
+    def __new__(cls, definition, *bounds):
+        parameters = ()
+        limits = {}
+
+        if not isinstance(bounds, Tuple):
+            bounds = Tuple(*bounds)
+
+        for bound in bounds:
+            if  isinstance(bound, tuple) or isinstance(bound, Tuple):
+                if len(bound) != 3:
+                    raise ValueError("Tuple should be in the form (parameter, lowerbound, upperbound)")
+                parameters += (bound[0],)
+                limits[bound[0]] = (bound[1], bound[2])
+            else:
+                parameters += (bound,)
+
+        if not (isinstance(definition, tuple) or isinstance(definition, Tuple)):
+            definition = (definition,)
+
+        obj = super().__new__(cls, Tuple(*definition), *bounds)
+        obj._parameters = parameters
+        obj._limits = limits
+
+        return obj
+
+    @property
+    def definition(self):
+        return self.args[0]
+
+    @property
+    def limits(self):
+        return self._limits
+
+    @property
+    def parameters(self):
+        return self._parameters
+
+    @property
+    def dimensions(self):
+        return len(self.limits)
+
+
+@singledispatch
+def parametric_region_list(reg):
+    """
+    Returns a list of ParametricRegion objects representing the geometric region.
+
+    Examples
+    ========
+
+    >>> from sympy.abc import t
+    >>> from sympy.vector import parametric_region_list
+    >>> from sympy.geometry import Point, Curve, Ellipse, Segment, Polygon
+
+    >>> p = Point(2, 5)
+    >>> parametric_region_list(p)
+    [ParametricRegion((2, 5))]
+
+    >>> c = Curve((t**3, 4*t), (t, -3, 4))
+    >>> parametric_region_list(c)
+    [ParametricRegion((t**3, 4*t), (t, -3, 4))]
+
+    >>> e = Ellipse(Point(1, 3), 2, 3)
+    >>> parametric_region_list(e)
+    [ParametricRegion((2*cos(t) + 1, 3*sin(t) + 3), (t, 0, 2*pi))]
+
+    >>> s = Segment(Point(1, 3), Point(2, 6))
+    >>> parametric_region_list(s)
+    [ParametricRegion((t + 1, 3*t + 3), (t, 0, 1))]
+
+    >>> p1, p2, p3, p4 = [(0, 1), (2, -3), (5, 3), (-2, 3)]
+    >>> poly = Polygon(p1, p2, p3, p4)
+    >>> parametric_region_list(poly)
+    [ParametricRegion((2*t, 1 - 4*t), (t, 0, 1)), ParametricRegion((3*t + 2, 6*t - 3), (t, 0, 1)),\
+     ParametricRegion((5 - 7*t, 3), (t, 0, 1)), ParametricRegion((2*t - 2, 3 - 2*t),  (t, 0, 1))]
+
+    """
+    raise ValueError("SymPy cannot determine parametric representation of the region.")
+
+
+@parametric_region_list.register(Point)
+def _(obj):
+    return [ParametricRegion(obj.args)]
+
+
+@parametric_region_list.register(Curve)  # type: ignore
+def _(obj):
+    definition = obj.arbitrary_point(obj.parameter).args
+    bounds = obj.limits
+    return [ParametricRegion(definition, bounds)]
+
+
+@parametric_region_list.register(Ellipse) # type: ignore
+def _(obj, parameter='t'):
+    definition = obj.arbitrary_point(parameter).args
+    t = _symbol(parameter, real=True)
+    bounds = (t, 0, 2*pi)
+    return [ParametricRegion(definition, bounds)]
+
+
+@parametric_region_list.register(Segment) # type: ignore
+def _(obj, parameter='t'):
+    t = _symbol(parameter, real=True)
+    definition = obj.arbitrary_point(t).args
+
+    for i in range(0, 3):
+        lower_bound = solve(definition[i] - obj.points[0].args[i], t)
+        upper_bound = solve(definition[i] - obj.points[1].args[i], t)
+
+        if len(lower_bound) == 1 and len(upper_bound) == 1:
+            bounds = t, lower_bound[0], upper_bound[0]
+            break
+
+    definition_tuple = obj.arbitrary_point(parameter).args
+    return [ParametricRegion(definition_tuple, bounds)]
+
+
+@parametric_region_list.register(Polygon) # type: ignore
+def _(obj, parameter='t'):
+    l = [parametric_region_list(side, parameter)[0] for side in obj.sides]
+    return l
+
+
+@parametric_region_list.register(ImplicitRegion) # type: ignore
+def _(obj, parameters=('t', 's')):
+    definition = obj.rational_parametrization(parameters)
+    bounds = []
+
+    for i in range(len(obj.variables) - 1):
+        # Each parameter is replaced by its tangent to simplify intergation
+        parameter = _symbol(parameters[i], real=True)
+        definition = [trigsimp(elem.subs(parameter, tan(parameter))) for elem in definition]
+        bounds.append((parameter, 0, 2*pi),)
+
+    definition = Tuple(*definition)
+    return [ParametricRegion(definition, *bounds)]
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/point.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/point.py
new file mode 100644
index 0000000000..e46bb22d91
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/point.py
@@ -0,0 +1,151 @@
+from sympy.core.basic import Basic
+from sympy.core.symbol import Str
+from sympy.vector.vector import Vector
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.vector.functions import _path
+from sympy.core.cache import cacheit
+
+
+class Point(Basic):
+    """
+    Represents a point in 3-D space.
+    """
+
+    def __new__(cls, name, position=Vector.zero, parent_point=None):
+        name = str(name)
+        # Check the args first
+        if not isinstance(position, Vector):
+            raise TypeError(
+                "position should be an instance of Vector, not %s" % type(
+                    position))
+        if (not isinstance(parent_point, Point) and
+                parent_point is not None):
+            raise TypeError(
+                "parent_point should be an instance of Point, not %s" % type(
+                    parent_point))
+        # Super class construction
+        if parent_point is None:
+            obj = super().__new__(cls, Str(name), position)
+        else:
+            obj = super().__new__(cls, Str(name), position, parent_point)
+        # Decide the object parameters
+        obj._name = name
+        obj._pos = position
+        if parent_point is None:
+            obj._parent = None
+            obj._root = obj
+        else:
+            obj._parent = parent_point
+            obj._root = parent_point._root
+        # Return object
+        return obj
+
+    @cacheit
+    def position_wrt(self, other):
+        """
+        Returns the position vector of this Point with respect to
+        another Point/CoordSys3D.
+
+        Parameters
+        ==========
+
+        other : Point/CoordSys3D
+            If other is a Point, the position of this Point wrt it is
+            returned. If its an instance of CoordSyRect, the position
+            wrt its origin is returned.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> N = CoordSys3D('N')
+        >>> p1 = N.origin.locate_new('p1', 10 * N.i)
+        >>> N.origin.position_wrt(p1)
+        (-10)*N.i
+
+        """
+
+        if (not isinstance(other, Point) and
+                not isinstance(other, CoordSys3D)):
+            raise TypeError(str(other) +
+                            "is not a Point or CoordSys3D")
+        if isinstance(other, CoordSys3D):
+            other = other.origin
+        # Handle special cases
+        if other == self:
+            return Vector.zero
+        elif other == self._parent:
+            return self._pos
+        elif other._parent == self:
+            return -1 * other._pos
+        # Else, use point tree to calculate position
+        rootindex, path = _path(self, other)
+        result = Vector.zero
+        i = -1
+        for i in range(rootindex):
+            result += path[i]._pos
+        i += 2
+        while i < len(path):
+            result -= path[i]._pos
+            i += 1
+        return result
+
+    def locate_new(self, name, position):
+        """
+        Returns a new Point located at the given position wrt this
+        Point.
+        Thus, the position vector of the new Point wrt this one will
+        be equal to the given 'position' parameter.
+
+        Parameters
+        ==========
+
+        name : str
+            Name of the new point
+
+        position : Vector
+            The position vector of the new Point wrt this one
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> N = CoordSys3D('N')
+        >>> p1 = N.origin.locate_new('p1', 10 * N.i)
+        >>> p1.position_wrt(N.origin)
+        10*N.i
+
+        """
+        return Point(name, position, self)
+
+    def express_coordinates(self, coordinate_system):
+        """
+        Returns the Cartesian/rectangular coordinates of this point
+        wrt the origin of the given CoordSys3D instance.
+
+        Parameters
+        ==========
+
+        coordinate_system : CoordSys3D
+            The coordinate system to express the coordinates of this
+            Point in.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> N = CoordSys3D('N')
+        >>> p1 = N.origin.locate_new('p1', 10 * N.i)
+        >>> p2 = p1.locate_new('p2', 5 * N.j)
+        >>> p2.express_coordinates(N)
+        (10, 5, 0)
+
+        """
+
+        # Determine the position vector
+        pos_vect = self.position_wrt(coordinate_system.origin)
+        # Express it in the given coordinate system
+        return tuple(pos_vect.to_matrix(coordinate_system))
+
+    def _sympystr(self, printer):
+        return self._name
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/scalar.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/scalar.py
new file mode 100644
index 0000000000..2441b6aeed
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/scalar.py
@@ -0,0 +1,71 @@
+from sympy.core import AtomicExpr, Symbol, S
+from sympy.core.sympify import _sympify
+from sympy.printing.pretty.stringpict import prettyForm
+from sympy.printing.precedence import PRECEDENCE
+
+
+class BaseScalar(AtomicExpr):
+    """
+    A coordinate symbol/base scalar.
+
+    Ideally, users should not instantiate this class.
+
+    Unicode pretty forms in Python 2 should use the `u` prefix.
+
+    """
+
+    def __new__(cls, index, system, pretty_str=None, latex_str=None):
+        from sympy.vector.coordsysrect import CoordSys3D
+        if pretty_str is None:
+            pretty_str = "x{}".format(index)
+        elif isinstance(pretty_str, Symbol):
+            pretty_str = pretty_str.name
+        if latex_str is None:
+            latex_str = "x_{}".format(index)
+        elif isinstance(latex_str, Symbol):
+            latex_str = latex_str.name
+
+        index = _sympify(index)
+        system = _sympify(system)
+        obj = super().__new__(cls, index, system)
+        if not isinstance(system, CoordSys3D):
+            raise TypeError("system should be a CoordSys3D")
+        if index not in range(0, 3):
+            raise ValueError("Invalid index specified.")
+        # The _id is used for equating purposes, and for hashing
+        obj._id = (index, system)
+        obj._name = obj.name = system._name + '.' + system._variable_names[index]
+        obj._pretty_form = '' + pretty_str
+        obj._latex_form = latex_str
+        obj._system = system
+
+        return obj
+
+    is_commutative = True
+    is_symbol = True
+
+    @property
+    def free_symbols(self):
+        return {self}
+
+    _diff_wrt = True
+
+    def _eval_derivative(self, s):
+        if self == s:
+            return S.One
+        return S.Zero
+
+    def _latex(self, printer=None):
+        return self._latex_form
+
+    def _pretty(self, printer=None):
+        return prettyForm(self._pretty_form)
+
+    precedence = PRECEDENCE['Atom']
+
+    @property
+    def system(self):
+        return self._system
+
+    def _sympystr(self, printer):
+        return self._name
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/__init__.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_coordsysrect.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_coordsysrect.py
new file mode 100644
index 0000000000..fd35f60ae9
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_coordsysrect.py
@@ -0,0 +1,462 @@
+from sympy.testing.pytest import raises, warns_deprecated_sympy
+from sympy.vector.coordsysrect import CoordSys3D, CoordSysCartesian
+from sympy.vector.scalar import BaseScalar
+from sympy import sin, sinh, cos, cosh, sqrt, pi, ImmutableMatrix as Matrix, \
+     symbols, simplify, zeros, expand, acos, atan2
+from sympy.vector.functions import express
+from sympy.vector.point import Point
+from sympy.vector.vector import Vector
+from sympy.vector.orienters import (AxisOrienter, BodyOrienter,
+                                    SpaceOrienter, QuaternionOrienter)
+
+
+x, y, z = symbols('x y z')
+a, b, c, q = symbols('a b c q')
+q1, q2, q3, q4 = symbols('q1 q2 q3 q4')
+
+
+def test_func_args():
+    A = CoordSys3D('A')
+    assert A.x.func(*A.x.args) == A.x
+    expr = 3*A.x + 4*A.y
+    assert expr.func(*expr.args) == expr
+    assert A.i.func(*A.i.args) == A.i
+    v = A.x*A.i + A.y*A.j + A.z*A.k
+    assert v.func(*v.args) == v
+    assert A.origin.func(*A.origin.args) == A.origin
+
+
+def test_coordsyscartesian_equivalence():
+    A = CoordSys3D('A')
+    A1 = CoordSys3D('A')
+    assert A1 == A
+    B = CoordSys3D('B')
+    assert A != B
+
+
+def test_orienters():
+    A = CoordSys3D('A')
+    axis_orienter = AxisOrienter(a, A.k)
+    body_orienter = BodyOrienter(a, b, c, '123')
+    space_orienter = SpaceOrienter(a, b, c, '123')
+    q_orienter = QuaternionOrienter(q1, q2, q3, q4)
+    assert axis_orienter.rotation_matrix(A) == Matrix([
+        [ cos(a), sin(a), 0],
+        [-sin(a), cos(a), 0],
+        [      0,      0, 1]])
+    assert body_orienter.rotation_matrix() == Matrix([
+        [ cos(b)*cos(c),  sin(a)*sin(b)*cos(c) + sin(c)*cos(a),
+          sin(a)*sin(c) - sin(b)*cos(a)*cos(c)],
+        [-sin(c)*cos(b), -sin(a)*sin(b)*sin(c) + cos(a)*cos(c),
+         sin(a)*cos(c) + sin(b)*sin(c)*cos(a)],
+        [        sin(b),                        -sin(a)*cos(b),
+                 cos(a)*cos(b)]])
+    assert space_orienter.rotation_matrix() == Matrix([
+        [cos(b)*cos(c), sin(c)*cos(b),       -sin(b)],
+        [sin(a)*sin(b)*cos(c) - sin(c)*cos(a),
+         sin(a)*sin(b)*sin(c) + cos(a)*cos(c), sin(a)*cos(b)],
+        [sin(a)*sin(c) + sin(b)*cos(a)*cos(c), -sin(a)*cos(c) +
+         sin(b)*sin(c)*cos(a), cos(a)*cos(b)]])
+    assert q_orienter.rotation_matrix() == Matrix([
+        [q1**2 + q2**2 - q3**2 - q4**2, 2*q1*q4 + 2*q2*q3,
+         -2*q1*q3 + 2*q2*q4],
+        [-2*q1*q4 + 2*q2*q3, q1**2 - q2**2 + q3**2 - q4**2,
+         2*q1*q2 + 2*q3*q4],
+        [2*q1*q3 + 2*q2*q4,
+         -2*q1*q2 + 2*q3*q4, q1**2 - q2**2 - q3**2 + q4**2]])
+
+
+def test_coordinate_vars():
+    """
+    Tests the coordinate variables functionality with respect to
+    reorientation of coordinate systems.
+    """
+    A = CoordSys3D('A')
+    # Note that the name given on the lhs is different from A.x._name
+    assert BaseScalar(0, A, 'A_x', r'\mathbf{{x}_{A}}') == A.x
+    assert BaseScalar(1, A, 'A_y', r'\mathbf{{y}_{A}}') == A.y
+    assert BaseScalar(2, A, 'A_z', r'\mathbf{{z}_{A}}') == A.z
+    assert BaseScalar(0, A, 'A_x', r'\mathbf{{x}_{A}}').__hash__() == A.x.__hash__()
+    assert isinstance(A.x, BaseScalar) and \
+           isinstance(A.y, BaseScalar) and \
+           isinstance(A.z, BaseScalar)
+    assert A.x*A.y == A.y*A.x
+    assert A.scalar_map(A) == {A.x: A.x, A.y: A.y, A.z: A.z}
+    assert A.x.system == A
+    assert A.x.diff(A.x) == 1
+    B = A.orient_new_axis('B', q, A.k)
+    assert B.scalar_map(A) == {B.z: A.z, B.y: -A.x*sin(q) + A.y*cos(q),
+                                 B.x: A.x*cos(q) + A.y*sin(q)}
+    assert A.scalar_map(B) == {A.x: B.x*cos(q) - B.y*sin(q),
+                                 A.y: B.x*sin(q) + B.y*cos(q), A.z: B.z}
+    assert express(B.x, A, variables=True) == A.x*cos(q) + A.y*sin(q)
+    assert express(B.y, A, variables=True) == -A.x*sin(q) + A.y*cos(q)
+    assert express(B.z, A, variables=True) == A.z
+    assert expand(express(B.x*B.y*B.z, A, variables=True)) == \
+           expand(A.z*(-A.x*sin(q) + A.y*cos(q))*(A.x*cos(q) + A.y*sin(q)))
+    assert express(B.x*B.i + B.y*B.j + B.z*B.k, A) == \
+           (B.x*cos(q) - B.y*sin(q))*A.i + (B.x*sin(q) + \
+           B.y*cos(q))*A.j + B.z*A.k
+    assert simplify(express(B.x*B.i + B.y*B.j + B.z*B.k, A, \
+                            variables=True)) == \
+           A.x*A.i + A.y*A.j + A.z*A.k
+    assert express(A.x*A.i + A.y*A.j + A.z*A.k, B) == \
+           (A.x*cos(q) + A.y*sin(q))*B.i + \
+           (-A.x*sin(q) + A.y*cos(q))*B.j + A.z*B.k
+    assert simplify(express(A.x*A.i + A.y*A.j + A.z*A.k, B, \
+                            variables=True)) == \
+           B.x*B.i + B.y*B.j + B.z*B.k
+    N = B.orient_new_axis('N', -q, B.k)
+    assert N.scalar_map(A) == \
+           {N.x: A.x, N.z: A.z, N.y: A.y}
+    C = A.orient_new_axis('C', q, A.i + A.j + A.k)
+    mapping = A.scalar_map(C)
+    assert mapping[A.x].equals(C.x*(2*cos(q) + 1)/3 +
+                            C.y*(-2*sin(q + pi/6) + 1)/3 +
+                            C.z*(-2*cos(q + pi/3) + 1)/3)
+    assert mapping[A.y].equals(C.x*(-2*cos(q + pi/3) + 1)/3 +
+                            C.y*(2*cos(q) + 1)/3 +
+                            C.z*(-2*sin(q + pi/6) + 1)/3)
+    assert mapping[A.z].equals(C.x*(-2*sin(q + pi/6) + 1)/3 +
+                            C.y*(-2*cos(q + pi/3) + 1)/3 +
+                            C.z*(2*cos(q) + 1)/3)
+    D = A.locate_new('D', a*A.i + b*A.j + c*A.k)
+    assert D.scalar_map(A) == {D.z: A.z - c, D.x: A.x - a, D.y: A.y - b}
+    E = A.orient_new_axis('E', a, A.k, a*A.i + b*A.j + c*A.k)
+    assert A.scalar_map(E) == {A.z: E.z + c,
+                               A.x: E.x*cos(a) - E.y*sin(a) + a,
+                               A.y: E.x*sin(a) + E.y*cos(a) + b}
+    assert E.scalar_map(A) == {E.x: (A.x - a)*cos(a) + (A.y - b)*sin(a),
+                               E.y: (-A.x + a)*sin(a) + (A.y - b)*cos(a),
+                               E.z: A.z - c}
+    F = A.locate_new('F', Vector.zero)
+    assert A.scalar_map(F) == {A.z: F.z, A.x: F.x, A.y: F.y}
+
+
+def test_rotation_matrix():
+    N = CoordSys3D('N')
+    A = N.orient_new_axis('A', q1, N.k)
+    B = A.orient_new_axis('B', q2, A.i)
+    C = B.orient_new_axis('C', q3, B.j)
+    D = N.orient_new_axis('D', q4, N.j)
+    E = N.orient_new_space('E', q1, q2, q3, '123')
+    F = N.orient_new_quaternion('F', q1, q2, q3, q4)
+    G = N.orient_new_body('G', q1, q2, q3, '123')
+    assert N.rotation_matrix(C) == Matrix([
+        [- sin(q1) * sin(q2) * sin(q3) + cos(q1) * cos(q3), - sin(q1) *
+        cos(q2), sin(q1) * sin(q2) * cos(q3) + sin(q3) * cos(q1)], \
+        [sin(q1) * cos(q3) + sin(q2) * sin(q3) * cos(q1), \
+         cos(q1) * cos(q2), sin(q1) * sin(q3) - sin(q2) * cos(q1) * \
+         cos(q3)], [- sin(q3) * cos(q2), sin(q2), cos(q2) * cos(q3)]])
+    test_mat = D.rotation_matrix(C) - Matrix(
+        [[cos(q1) * cos(q3) * cos(q4) - sin(q3) * (- sin(q4) * cos(q2) +
+        sin(q1) * sin(q2) * cos(q4)), - sin(q2) * sin(q4) - sin(q1) *
+            cos(q2) * cos(q4), sin(q3) * cos(q1) * cos(q4) + cos(q3) * \
+          (- sin(q4) * cos(q2) + sin(q1) * sin(q2) * cos(q4))], \
+         [sin(q1) * cos(q3) + sin(q2) * sin(q3) * cos(q1), cos(q1) * \
+          cos(q2), sin(q1) * sin(q3) - sin(q2) * cos(q1) * cos(q3)], \
+         [sin(q4) * cos(q1) * cos(q3) - sin(q3) * (cos(q2) * cos(q4) + \
+                                                   sin(q1) * sin(q2) * \
+                                                   sin(q4)), sin(q2) *
+                cos(q4) - sin(q1) * sin(q4) * cos(q2), sin(q3) * \
+          sin(q4) * cos(q1) + cos(q3) * (cos(q2) * cos(q4) + \
+                                         sin(q1) * sin(q2) * sin(q4))]])
+    assert test_mat.expand() == zeros(3, 3)
+    assert E.rotation_matrix(N) == Matrix(
+        [[cos(q2)*cos(q3), sin(q3)*cos(q2), -sin(q2)],
+        [sin(q1)*sin(q2)*cos(q3) - sin(q3)*cos(q1), \
+         sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3), sin(q1)*cos(q2)], \
+         [sin(q1)*sin(q3) + sin(q2)*cos(q1)*cos(q3), - \
+          sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1), cos(q1)*cos(q2)]])
+    assert F.rotation_matrix(N) == Matrix([[
+        q1**2 + q2**2 - q3**2 - q4**2,
+        2*q1*q4 + 2*q2*q3, -2*q1*q3 + 2*q2*q4],[ -2*q1*q4 + 2*q2*q3,
+            q1**2 - q2**2 + q3**2 - q4**2, 2*q1*q2 + 2*q3*q4],
+                                           [2*q1*q3 + 2*q2*q4,
+                                            -2*q1*q2 + 2*q3*q4,
+                                q1**2 - q2**2 - q3**2 + q4**2]])
+    assert G.rotation_matrix(N) == Matrix([[
+        cos(q2)*cos(q3),  sin(q1)*sin(q2)*cos(q3) + sin(q3)*cos(q1),
+        sin(q1)*sin(q3) - sin(q2)*cos(q1)*cos(q3)], [
+            -sin(q3)*cos(q2), -sin(q1)*sin(q2)*sin(q3) + cos(q1)*cos(q3),
+            sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1)],[
+                sin(q2), -sin(q1)*cos(q2), cos(q1)*cos(q2)]])
+
+
+def test_vector_with_orientation():
+    """
+    Tests the effects of orientation of coordinate systems on
+    basic vector operations.
+    """
+    N = CoordSys3D('N')
+    A = N.orient_new_axis('A', q1, N.k)
+    B = A.orient_new_axis('B', q2, A.i)
+    C = B.orient_new_axis('C', q3, B.j)
+
+    # Test to_matrix
+    v1 = a*N.i + b*N.j + c*N.k
+    assert v1.to_matrix(A) == Matrix([[ a*cos(q1) + b*sin(q1)],
+                                      [-a*sin(q1) + b*cos(q1)],
+                                      [                     c]])
+
+    # Test dot
+    assert N.i.dot(A.i) == cos(q1)
+    assert N.i.dot(A.j) == -sin(q1)
+    assert N.i.dot(A.k) == 0
+    assert N.j.dot(A.i) == sin(q1)
+    assert N.j.dot(A.j) == cos(q1)
+    assert N.j.dot(A.k) == 0
+    assert N.k.dot(A.i) == 0
+    assert N.k.dot(A.j) == 0
+    assert N.k.dot(A.k) == 1
+
+    assert N.i.dot(A.i + A.j) == -sin(q1) + cos(q1) == \
+           (A.i + A.j).dot(N.i)
+
+    assert A.i.dot(C.i) == cos(q3)
+    assert A.i.dot(C.j) == 0
+    assert A.i.dot(C.k) == sin(q3)
+    assert A.j.dot(C.i) == sin(q2)*sin(q3)
+    assert A.j.dot(C.j) == cos(q2)
+    assert A.j.dot(C.k) == -sin(q2)*cos(q3)
+    assert A.k.dot(C.i) == -cos(q2)*sin(q3)
+    assert A.k.dot(C.j) == sin(q2)
+    assert A.k.dot(C.k) == cos(q2)*cos(q3)
+
+    # Test cross
+    assert N.i.cross(A.i) == sin(q1)*A.k
+    assert N.i.cross(A.j) == cos(q1)*A.k
+    assert N.i.cross(A.k) == -sin(q1)*A.i - cos(q1)*A.j
+    assert N.j.cross(A.i) == -cos(q1)*A.k
+    assert N.j.cross(A.j) == sin(q1)*A.k
+    assert N.j.cross(A.k) == cos(q1)*A.i - sin(q1)*A.j
+    assert N.k.cross(A.i) == A.j
+    assert N.k.cross(A.j) == -A.i
+    assert N.k.cross(A.k) == Vector.zero
+
+    assert N.i.cross(A.i) == sin(q1)*A.k
+    assert N.i.cross(A.j) == cos(q1)*A.k
+    assert N.i.cross(A.i + A.j) == sin(q1)*A.k + cos(q1)*A.k
+    assert (A.i + A.j).cross(N.i) == (-sin(q1) - cos(q1))*N.k
+
+    assert A.i.cross(C.i) == sin(q3)*C.j
+    assert A.i.cross(C.j) == -sin(q3)*C.i + cos(q3)*C.k
+    assert A.i.cross(C.k) == -cos(q3)*C.j
+    assert C.i.cross(A.i) == (-sin(q3)*cos(q2))*A.j + \
+           (-sin(q2)*sin(q3))*A.k
+    assert C.j.cross(A.i) == (sin(q2))*A.j + (-cos(q2))*A.k
+    assert express(C.k.cross(A.i), C).trigsimp() == cos(q3)*C.j
+
+
+def test_orient_new_methods():
+    N = CoordSys3D('N')
+    orienter1 = AxisOrienter(q4, N.j)
+    orienter2 = SpaceOrienter(q1, q2, q3, '123')
+    orienter3 = QuaternionOrienter(q1, q2, q3, q4)
+    orienter4 = BodyOrienter(q1, q2, q3, '123')
+    D = N.orient_new('D', (orienter1, ))
+    E = N.orient_new('E', (orienter2, ))
+    F = N.orient_new('F', (orienter3, ))
+    G = N.orient_new('G', (orienter4, ))
+    assert D == N.orient_new_axis('D', q4, N.j)
+    assert E == N.orient_new_space('E', q1, q2, q3, '123')
+    assert F == N.orient_new_quaternion('F', q1, q2, q3, q4)
+    assert G == N.orient_new_body('G', q1, q2, q3, '123')
+
+
+def test_locatenew_point():
+    """
+    Tests Point class, and locate_new method in CoordSysCartesian.
+    """
+    A = CoordSys3D('A')
+    assert isinstance(A.origin, Point)
+    v = a*A.i + b*A.j + c*A.k
+    C = A.locate_new('C', v)
+    assert C.origin.position_wrt(A) == \
+           C.position_wrt(A) == \
+           C.origin.position_wrt(A.origin) == v
+    assert A.origin.position_wrt(C) == \
+           A.position_wrt(C) == \
+           A.origin.position_wrt(C.origin) == -v
+    assert A.origin.express_coordinates(C) == (-a, -b, -c)
+    p = A.origin.locate_new('p', -v)
+    assert p.express_coordinates(A) == (-a, -b, -c)
+    assert p.position_wrt(C.origin) == p.position_wrt(C) == \
+           -2 * v
+    p1 = p.locate_new('p1', 2*v)
+    assert p1.position_wrt(C.origin) == Vector.zero
+    assert p1.express_coordinates(C) == (0, 0, 0)
+    p2 = p.locate_new('p2', A.i)
+    assert p1.position_wrt(p2) == 2*v - A.i
+    assert p2.express_coordinates(C) == (-2*a + 1, -2*b, -2*c)
+
+
+def test_create_new():
+    a = CoordSys3D('a')
+    c = a.create_new('c', transformation='spherical')
+    assert c._parent == a
+    assert c.transformation_to_parent() == \
+           (c.r*sin(c.theta)*cos(c.phi), c.r*sin(c.theta)*sin(c.phi), c.r*cos(c.theta))
+    assert c.transformation_from_parent() == \
+           (sqrt(a.x**2 + a.y**2 + a.z**2), acos(a.z/sqrt(a.x**2 + a.y**2 + a.z**2)), atan2(a.y, a.x))
+
+
+def test_evalf():
+    A = CoordSys3D('A')
+    v = 3*A.i + 4*A.j + a*A.k
+    assert v.n() == v.evalf()
+    assert v.evalf(subs={a:1}) == v.subs(a, 1).evalf()
+
+
+def test_lame_coefficients():
+    a = CoordSys3D('a', 'spherical')
+    assert a.lame_coefficients() == (1, a.r, sin(a.theta)*a.r)
+    a = CoordSys3D('a')
+    assert a.lame_coefficients() == (1, 1, 1)
+    a = CoordSys3D('a', 'cartesian')
+    assert a.lame_coefficients() == (1, 1, 1)
+    a = CoordSys3D('a', 'cylindrical')
+    assert a.lame_coefficients() == (1, a.r, 1)
+
+
+def test_transformation_equations():
+
+    x, y, z = symbols('x y z')
+    # Str
+    a = CoordSys3D('a', transformation='spherical',
+                   variable_names=["r", "theta", "phi"])
+    r, theta, phi = a.base_scalars()
+
+    assert r == a.r
+    assert theta == a.theta
+    assert phi == a.phi
+
+    raises(AttributeError, lambda: a.x)
+    raises(AttributeError, lambda: a.y)
+    raises(AttributeError, lambda: a.z)
+
+    assert a.transformation_to_parent() == (
+        r*sin(theta)*cos(phi),
+        r*sin(theta)*sin(phi),
+        r*cos(theta)
+    )
+    assert a.lame_coefficients() == (1, r, r*sin(theta))
+    assert a.transformation_from_parent_function()(x, y, z) == (
+        sqrt(x ** 2 + y ** 2 + z ** 2),
+        acos((z) / sqrt(x**2 + y**2 + z**2)),
+        atan2(y, x)
+    )
+    a = CoordSys3D('a', transformation='cylindrical',
+                   variable_names=["r", "theta", "z"])
+    r, theta, z = a.base_scalars()
+    assert a.transformation_to_parent() == (
+        r*cos(theta),
+        r*sin(theta),
+        z
+    )
+    assert a.lame_coefficients() == (1, a.r, 1)
+    assert a.transformation_from_parent_function()(x, y, z) == (sqrt(x**2 + y**2),
+                            atan2(y, x), z)
+
+    a = CoordSys3D('a', 'cartesian')
+    assert a.transformation_to_parent() == (a.x, a.y, a.z)
+    assert a.lame_coefficients() == (1, 1, 1)
+    assert a.transformation_from_parent_function()(x, y, z) == (x, y, z)
+
+    # Variables and expressions
+
+    # Cartesian with equation tuple:
+    x, y, z = symbols('x y z')
+    a = CoordSys3D('a', ((x, y, z), (x, y, z)))
+    a._calculate_inv_trans_equations()
+    assert a.transformation_to_parent() == (a.x1, a.x2, a.x3)
+    assert a.lame_coefficients() == (1, 1, 1)
+    assert a.transformation_from_parent_function()(x, y, z) == (x, y, z)
+    r, theta, z = symbols("r theta z")
+
+    # Cylindrical with equation tuple:
+    a = CoordSys3D('a', [(r, theta, z), (r*cos(theta), r*sin(theta), z)],
+                   variable_names=["r", "theta", "z"])
+    r, theta, z = a.base_scalars()
+    assert a.transformation_to_parent() == (
+        r*cos(theta), r*sin(theta), z
+    )
+    assert a.lame_coefficients() == (
+        sqrt(sin(theta)**2 + cos(theta)**2),
+        sqrt(r**2*sin(theta)**2 + r**2*cos(theta)**2),
+        1
+    )  # ==> this should simplify to (1, r, 1), tests are too slow with `simplify`.
+
+    # Definitions with `lambda`:
+
+    # Cartesian with `lambda`
+    a = CoordSys3D('a', lambda x, y, z: (x, y, z))
+    assert a.transformation_to_parent() == (a.x1, a.x2, a.x3)
+    assert a.lame_coefficients() == (1, 1, 1)
+    a._calculate_inv_trans_equations()
+    assert a.transformation_from_parent_function()(x, y, z) == (x, y, z)
+
+    # Spherical with `lambda`
+    a = CoordSys3D('a', lambda r, theta, phi: (r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)),
+                   variable_names=["r", "theta", "phi"])
+    r, theta, phi = a.base_scalars()
+    assert a.transformation_to_parent() == (
+        r*sin(theta)*cos(phi), r*sin(phi)*sin(theta), r*cos(theta)
+    )
+    assert a.lame_coefficients() == (
+        sqrt(sin(phi)**2*sin(theta)**2 + sin(theta)**2*cos(phi)**2 + cos(theta)**2),
+        sqrt(r**2*sin(phi)**2*cos(theta)**2 + r**2*sin(theta)**2 + r**2*cos(phi)**2*cos(theta)**2),
+        sqrt(r**2*sin(phi)**2*sin(theta)**2 + r**2*sin(theta)**2*cos(phi)**2)
+    )  # ==> this should simplify to (1, r, sin(theta)*r), `simplify` is too slow.
+
+    # Cylindrical with `lambda`
+    a = CoordSys3D('a', lambda r, theta, z:
+        (r*cos(theta), r*sin(theta), z),
+        variable_names=["r", "theta", "z"]
+    )
+    r, theta, z = a.base_scalars()
+    assert a.transformation_to_parent() == (r*cos(theta), r*sin(theta), z)
+    assert a.lame_coefficients() == (
+        sqrt(sin(theta)**2 + cos(theta)**2),
+        sqrt(r**2*sin(theta)**2 + r**2*cos(theta)**2),
+        1
+    )  # ==> this should simplify to (1, a.x, 1)
+
+    raises(TypeError, lambda: CoordSys3D('a', transformation={
+        x: x*sin(y)*cos(z), y:x*sin(y)*sin(z), z:  x*cos(y)}))
+
+
+def test_check_orthogonality():
+    x, y, z = symbols('x y z')
+    u,v = symbols('u, v')
+    a = CoordSys3D('a', transformation=((x, y, z), (x*sin(y)*cos(z), x*sin(y)*sin(z), x*cos(y))))
+    assert a._check_orthogonality(a._transformation) is True
+    a = CoordSys3D('a', transformation=((x, y, z), (x * cos(y), x * sin(y), z)))
+    assert a._check_orthogonality(a._transformation) is True
+    a = CoordSys3D('a', transformation=((u, v, z), (cosh(u) * cos(v), sinh(u) * sin(v), z)))
+    assert a._check_orthogonality(a._transformation) is True
+
+    raises(ValueError, lambda: CoordSys3D('a', transformation=((x, y, z), (x, x, z))))
+    raises(ValueError, lambda: CoordSys3D('a', transformation=(
+        (x, y, z), (x*sin(y/2)*cos(z), x*sin(y)*sin(z), x*cos(y)))))
+
+
+def test_coordsys3d():
+    with warns_deprecated_sympy():
+        assert CoordSysCartesian("C") == CoordSys3D("C")
+
+
+def test_rotation_trans_equations():
+    a = CoordSys3D('a')
+    from sympy import symbols
+    q0 = symbols('q0')
+    assert a._rotation_trans_equations(a._parent_rotation_matrix, a.base_scalars()) == (a.x, a.y, a.z)
+    assert a._rotation_trans_equations(a._inverse_rotation_matrix(), a.base_scalars()) == (a.x, a.y, a.z)
+    b = a.orient_new_axis('b', 0, -a.k)
+    assert b._rotation_trans_equations(b._parent_rotation_matrix, b.base_scalars()) == (b.x, b.y, b.z)
+    assert b._rotation_trans_equations(b._inverse_rotation_matrix(), b.base_scalars()) == (b.x, b.y, b.z)
+    c = a.orient_new_axis('c', q0, -a.k)
+    assert c._rotation_trans_equations(c._parent_rotation_matrix, c.base_scalars()) == \
+           (-sin(q0) * c.y + cos(q0) * c.x, sin(q0) * c.x + cos(q0) * c.y, c.z)
+    assert c._rotation_trans_equations(c._inverse_rotation_matrix(), c.base_scalars()) == \
+           (sin(q0) * c.y + cos(q0) * c.x, -sin(q0) * c.x + cos(q0) * c.y, c.z)
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_dyadic.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_dyadic.py
new file mode 100644
index 0000000000..f301a770a8
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_dyadic.py
@@ -0,0 +1,117 @@
+from sympy import sin, cos, symbols, pi, ImmutableMatrix as Matrix, \
+     simplify
+from sympy.vector import (CoordSys3D, Vector, Dyadic,
+                          DyadicAdd, DyadicMul, DyadicZero,
+                          BaseDyadic, express)
+
+
+A = CoordSys3D('A')
+
+
+def test_dyadic():
+    a, b = symbols('a, b')
+    assert Dyadic.zero != 0
+    assert isinstance(Dyadic.zero, DyadicZero)
+    assert BaseDyadic(A.i, A.j) != BaseDyadic(A.j, A.i)
+    assert (BaseDyadic(Vector.zero, A.i) ==
+            BaseDyadic(A.i, Vector.zero) == Dyadic.zero)
+
+    d1 = A.i | A.i
+    d2 = A.j | A.j
+    d3 = A.i | A.j
+
+    assert isinstance(d1, BaseDyadic)
+    d_mul = a*d1
+    assert isinstance(d_mul, DyadicMul)
+    assert d_mul.base_dyadic == d1
+    assert d_mul.measure_number == a
+    assert isinstance(a*d1 + b*d3, DyadicAdd)
+    assert d1 == A.i.outer(A.i)
+    assert d3 == A.i.outer(A.j)
+    v1 = a*A.i - A.k
+    v2 = A.i + b*A.j
+    assert v1 | v2 == v1.outer(v2) == a * (A.i|A.i) + (a*b) * (A.i|A.j) +\
+           - (A.k|A.i) - b * (A.k|A.j)
+    assert d1 * 0 == Dyadic.zero
+    assert d1 != Dyadic.zero
+    assert d1 * 2 == 2 * (A.i | A.i)
+    assert d1 / 2. == 0.5 * d1
+
+    assert d1.dot(0 * d1) == Vector.zero
+    assert d1 & d2 == Dyadic.zero
+    assert d1.dot(A.i) == A.i == d1 & A.i
+
+    assert d1.cross(Vector.zero) == Dyadic.zero
+    assert d1.cross(A.i) == Dyadic.zero
+    assert d1 ^ A.j == d1.cross(A.j)
+    assert d1.cross(A.k) == - A.i | A.j
+    assert d2.cross(A.i) == - A.j | A.k == d2 ^ A.i
+
+    assert A.i ^ d1 == Dyadic.zero
+    assert A.j.cross(d1) == - A.k | A.i == A.j ^ d1
+    assert Vector.zero.cross(d1) == Dyadic.zero
+    assert A.k ^ d1 == A.j | A.i
+    assert A.i.dot(d1) == A.i & d1 == A.i
+    assert A.j.dot(d1) == Vector.zero
+    assert Vector.zero.dot(d1) == Vector.zero
+    assert A.j & d2 == A.j
+
+    assert d1.dot(d3) == d1 & d3 == A.i | A.j == d3
+    assert d3 & d1 == Dyadic.zero
+
+    q = symbols('q')
+    B = A.orient_new_axis('B', q, A.k)
+    assert express(d1, B) == express(d1, B, B)
+
+    expr1 = ((cos(q)**2) * (B.i | B.i) + (-sin(q) * cos(q)) *
+            (B.i | B.j) + (-sin(q) * cos(q)) * (B.j | B.i) + (sin(q)**2) *
+            (B.j | B.j))
+    assert (express(d1, B) - expr1).simplify() == Dyadic.zero
+
+    expr2 = (cos(q)) * (B.i | A.i) + (-sin(q)) * (B.j | A.i)
+    assert (express(d1, B, A) - expr2).simplify() == Dyadic.zero
+
+    expr3 = (cos(q)) * (A.i | B.i) + (-sin(q)) * (A.i | B.j)
+    assert (express(d1, A, B) - expr3).simplify() == Dyadic.zero
+
+    assert d1.to_matrix(A) == Matrix([[1, 0, 0], [0, 0, 0], [0, 0, 0]])
+    assert d1.to_matrix(A, B) == Matrix([[cos(q), -sin(q), 0],
+                                         [0, 0, 0],
+                                         [0, 0, 0]])
+    assert d3.to_matrix(A) == Matrix([[0, 1, 0], [0, 0, 0], [0, 0, 0]])
+    a, b, c, d, e, f = symbols('a, b, c, d, e, f')
+    v1 = a * A.i + b * A.j + c * A.k
+    v2 = d * A.i + e * A.j + f * A.k
+    d4 = v1.outer(v2)
+    assert d4.to_matrix(A) == Matrix([[a * d, a * e, a * f],
+                                      [b * d, b * e, b * f],
+                                      [c * d, c * e, c * f]])
+    d5 = v1.outer(v1)
+    C = A.orient_new_axis('C', q, A.i)
+    for expected, actual in zip(C.rotation_matrix(A) * d5.to_matrix(A) * \
+                               C.rotation_matrix(A).T, d5.to_matrix(C)):
+        assert (expected - actual).simplify() == 0
+
+
+def test_dyadic_simplify():
+    x, y, z, k, n, m, w, f, s, A = symbols('x, y, z, k, n, m, w, f, s, A')
+    N = CoordSys3D('N')
+
+    dy = N.i | N.i
+    test1 = (1 / x + 1 / y) * dy
+    assert (N.i & test1 & N.i) != (x + y) / (x * y)
+    test1 = test1.simplify()
+    assert test1.simplify() == simplify(test1)
+    assert (N.i & test1 & N.i) == (x + y) / (x * y)
+
+    test2 = (A**2 * s**4 / (4 * pi * k * m**3)) * dy
+    test2 = test2.simplify()
+    assert (N.i & test2 & N.i) == (A**2 * s**4 / (4 * pi * k * m**3))
+
+    test3 = ((4 + 4 * x - 2 * (2 + 2 * x)) / (2 + 2 * x)) * dy
+    test3 = test3.simplify()
+    assert (N.i & test3 & N.i) == 0
+
+    test4 = ((-4 * x * y**2 - 2 * y**3 - 2 * x**2 * y) / (x + y)**2) * dy
+    test4 = test4.simplify()
+    assert (N.i & test4 & N.i) == -2 * y
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_field_functions.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_field_functions.py
new file mode 100644
index 0000000000..3f50e790bd
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_field_functions.py
@@ -0,0 +1,322 @@
+from sympy.core.function import Derivative
+from sympy.vector.vector import Vector
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.simplify import simplify
+from sympy.core.symbol import symbols
+from sympy.core import S
+from sympy import sin, cos
+from sympy.vector.vector import Dot
+from sympy.vector.operators import curl, divergence, gradient, Gradient, Divergence, Cross
+from sympy.vector.deloperator import Del
+from sympy.vector.functions import (is_conservative, is_solenoidal,
+                                    scalar_potential, directional_derivative,
+                                    laplacian, scalar_potential_difference)
+from sympy.testing.pytest import raises
+
+C = CoordSys3D('C')
+i, j, k = C.base_vectors()
+x, y, z = C.base_scalars()
+delop = Del()
+a, b, c, q = symbols('a b c q')
+
+
+def test_del_operator():
+    # Tests for curl
+
+    assert delop ^ Vector.zero == Vector.zero
+    assert ((delop ^ Vector.zero).doit() == Vector.zero ==
+            curl(Vector.zero))
+    assert delop.cross(Vector.zero) == delop ^ Vector.zero
+    assert (delop ^ i).doit() == Vector.zero
+    assert delop.cross(2*y**2*j, doit=True) == Vector.zero
+    assert delop.cross(2*y**2*j) == delop ^ 2*y**2*j
+    v = x*y*z * (i + j + k)
+    assert ((delop ^ v).doit() ==
+            (-x*y + x*z)*i + (x*y - y*z)*j + (-x*z + y*z)*k ==
+            curl(v))
+    assert delop ^ v == delop.cross(v)
+    assert (delop.cross(2*x**2*j) ==
+            (Derivative(0, C.y) - Derivative(2*C.x**2, C.z))*C.i +
+            (-Derivative(0, C.x) + Derivative(0, C.z))*C.j +
+            (-Derivative(0, C.y) + Derivative(2*C.x**2, C.x))*C.k)
+    assert (delop.cross(2*x**2*j, doit=True) == 4*x*k ==
+            curl(2*x**2*j))
+
+    #Tests for divergence
+    assert delop & Vector.zero is S.Zero == divergence(Vector.zero)
+    assert (delop & Vector.zero).doit() is S.Zero
+    assert delop.dot(Vector.zero) == delop & Vector.zero
+    assert (delop & i).doit() is S.Zero
+    assert (delop & x**2*i).doit() == 2*x == divergence(x**2*i)
+    assert (delop.dot(v, doit=True) == x*y + y*z + z*x ==
+            divergence(v))
+    assert delop & v == delop.dot(v)
+    assert delop.dot(1/(x*y*z) * (i + j + k), doit=True) == \
+           - 1 / (x*y*z**2) - 1 / (x*y**2*z) - 1 / (x**2*y*z)
+    v = x*i + y*j + z*k
+    assert (delop & v == Derivative(C.x, C.x) +
+            Derivative(C.y, C.y) + Derivative(C.z, C.z))
+    assert delop.dot(v, doit=True) == 3 == divergence(v)
+    assert delop & v == delop.dot(v)
+    assert simplify((delop & v).doit()) == 3
+
+    #Tests for gradient
+    assert (delop.gradient(0, doit=True) == Vector.zero ==
+            gradient(0))
+    assert delop.gradient(0) == delop(0)
+    assert (delop(S.Zero)).doit() == Vector.zero
+    assert (delop(x) == (Derivative(C.x, C.x))*C.i +
+            (Derivative(C.x, C.y))*C.j + (Derivative(C.x, C.z))*C.k)
+    assert (delop(x)).doit() == i == gradient(x)
+    assert (delop(x*y*z) ==
+            (Derivative(C.x*C.y*C.z, C.x))*C.i +
+            (Derivative(C.x*C.y*C.z, C.y))*C.j +
+            (Derivative(C.x*C.y*C.z, C.z))*C.k)
+    assert (delop.gradient(x*y*z, doit=True) ==
+            y*z*i + z*x*j + x*y*k ==
+            gradient(x*y*z))
+    assert delop(x*y*z) == delop.gradient(x*y*z)
+    assert (delop(2*x**2)).doit() == 4*x*i
+    assert ((delop(a*sin(y) / x)).doit() ==
+            -a*sin(y)/x**2 * i + a*cos(y)/x * j)
+
+    #Tests for directional derivative
+    assert (Vector.zero & delop)(a) is S.Zero
+    assert ((Vector.zero & delop)(a)).doit() is S.Zero
+    assert ((v & delop)(Vector.zero)).doit() == Vector.zero
+    assert ((v & delop)(S.Zero)).doit() is S.Zero
+    assert ((i & delop)(x)).doit() == 1
+    assert ((j & delop)(y)).doit() == 1
+    assert ((k & delop)(z)).doit() == 1
+    assert ((i & delop)(x*y*z)).doit() == y*z
+    assert ((v & delop)(x)).doit() == x
+    assert ((v & delop)(x*y*z)).doit() == 3*x*y*z
+    assert (v & delop)(x + y + z) == C.x + C.y + C.z
+    assert ((v & delop)(x + y + z)).doit() == x + y + z
+    assert ((v & delop)(v)).doit() == v
+    assert ((i & delop)(v)).doit() == i
+    assert ((j & delop)(v)).doit() == j
+    assert ((k & delop)(v)).doit() == k
+    assert ((v & delop)(Vector.zero)).doit() == Vector.zero
+
+    # Tests for laplacian on scalar fields
+    assert laplacian(x*y*z) is S.Zero
+    assert laplacian(x**2) == S(2)
+    assert laplacian(x**2*y**2*z**2) == \
+                    2*y**2*z**2 + 2*x**2*z**2 + 2*x**2*y**2
+    A = CoordSys3D('A', transformation="spherical", variable_names=["r", "theta", "phi"])
+    B = CoordSys3D('B', transformation='cylindrical', variable_names=["r", "theta", "z"])
+    assert laplacian(A.r + A.theta + A.phi) == 2/A.r + cos(A.theta)/(A.r**2*sin(A.theta))
+    assert laplacian(B.r + B.theta + B.z) == 1/B.r
+
+    # Tests for laplacian on vector fields
+    assert laplacian(x*y*z*(i + j + k)) == Vector.zero
+    assert laplacian(x*y**2*z*(i + j + k)) == \
+                            2*x*z*i + 2*x*z*j + 2*x*z*k
+
+
+
+def test_product_rules():
+    """
+    Tests the six product rules defined with respect to the Del
+    operator
+
+    References
+    ==========
+
+    .. [1] https://en.wikipedia.org/wiki/Del
+
+    """
+
+    #Define the scalar and vector functions
+    f = 2*x*y*z
+    g = x*y + y*z + z*x
+    u = x**2*i + 4*j - y**2*z*k
+    v = 4*i + x*y*z*k
+
+    # First product rule
+    lhs = delop(f * g, doit=True)
+    rhs = (f * delop(g) + g * delop(f)).doit()
+    assert simplify(lhs) == simplify(rhs)
+
+    # Second product rule
+    lhs = delop(u & v).doit()
+    rhs = ((u ^ (delop ^ v)) + (v ^ (delop ^ u)) + \
+          ((u & delop)(v)) + ((v & delop)(u))).doit()
+    assert simplify(lhs) == simplify(rhs)
+
+    # Third product rule
+    lhs = (delop & (f*v)).doit()
+    rhs = ((f * (delop & v)) + (v & (delop(f)))).doit()
+    assert simplify(lhs) == simplify(rhs)
+
+    # Fourth product rule
+    lhs = (delop & (u ^ v)).doit()
+    rhs = ((v & (delop ^ u)) - (u & (delop ^ v))).doit()
+    assert simplify(lhs) == simplify(rhs)
+
+    # Fifth product rule
+    lhs = (delop ^ (f * v)).doit()
+    rhs = (((delop(f)) ^ v) + (f * (delop ^ v))).doit()
+    assert simplify(lhs) == simplify(rhs)
+
+    # Sixth product rule
+    lhs = (delop ^ (u ^ v)).doit()
+    rhs = (u * (delop & v) - v * (delop & u) +
+           (v & delop)(u) - (u & delop)(v)).doit()
+    assert simplify(lhs) == simplify(rhs)
+
+
+P = C.orient_new_axis('P', q, C.k)  # type: ignore
+scalar_field = 2*x**2*y*z
+grad_field = gradient(scalar_field)
+vector_field = y**2*i + 3*x*j + 5*y*z*k
+curl_field = curl(vector_field)
+
+
+def test_conservative():
+    assert is_conservative(Vector.zero) is True
+    assert is_conservative(i) is True
+    assert is_conservative(2 * i + 3 * j + 4 * k) is True
+    assert (is_conservative(y*z*i + x*z*j + x*y*k) is
+            True)
+    assert is_conservative(x * j) is False
+    assert is_conservative(grad_field) is True
+    assert is_conservative(curl_field) is False
+    assert (is_conservative(4*x*y*z*i + 2*x**2*z*j) is
+            False)
+    assert is_conservative(z*P.i + P.x*k) is True
+
+
+def test_solenoidal():
+    assert is_solenoidal(Vector.zero) is True
+    assert is_solenoidal(i) is True
+    assert is_solenoidal(2 * i + 3 * j + 4 * k) is True
+    assert (is_solenoidal(y*z*i + x*z*j + x*y*k) is
+            True)
+    assert is_solenoidal(y * j) is False
+    assert is_solenoidal(grad_field) is False
+    assert is_solenoidal(curl_field) is True
+    assert is_solenoidal((-2*y + 3)*k) is True
+    assert is_solenoidal(cos(q)*i + sin(q)*j + cos(q)*P.k) is True
+    assert is_solenoidal(z*P.i + P.x*k) is True
+
+
+def test_directional_derivative():
+    assert directional_derivative(C.x*C.y*C.z, 3*C.i + 4*C.j + C.k) == C.x*C.y + 4*C.x*C.z + 3*C.y*C.z
+    assert directional_derivative(5*C.x**2*C.z, 3*C.i + 4*C.j + C.k) == 5*C.x**2 + 30*C.x*C.z
+    assert directional_derivative(5*C.x**2*C.z, 4*C.j) is S.Zero
+
+    D = CoordSys3D("D", "spherical", variable_names=["r", "theta", "phi"],
+                   vector_names=["e_r", "e_theta", "e_phi"])
+    r, theta, phi = D.base_scalars()
+    e_r, e_theta, e_phi = D.base_vectors()
+    assert directional_derivative(r**2*e_r, e_r) == 2*r*e_r
+    assert directional_derivative(5*r**2*phi, 3*e_r + 4*e_theta + e_phi) == 5*r**2 + 30*r*phi
+
+
+def test_scalar_potential():
+    assert scalar_potential(Vector.zero, C) == 0
+    assert scalar_potential(i, C) == x
+    assert scalar_potential(j, C) == y
+    assert scalar_potential(k, C) == z
+    assert scalar_potential(y*z*i + x*z*j + x*y*k, C) == x*y*z
+    assert scalar_potential(grad_field, C) == scalar_field
+    assert scalar_potential(z*P.i + P.x*k, C) == x*z*cos(q) + y*z*sin(q)
+    assert scalar_potential(z*P.i + P.x*k, P) == P.x*P.z
+    raises(ValueError, lambda: scalar_potential(x*j, C))
+
+
+def test_scalar_potential_difference():
+    point1 = C.origin.locate_new('P1', 1*i + 2*j + 3*k)
+    point2 = C.origin.locate_new('P2', 4*i + 5*j + 6*k)
+    genericpointC = C.origin.locate_new('RP', x*i + y*j + z*k)
+    genericpointP = P.origin.locate_new('PP', P.x*P.i + P.y*P.j + P.z*P.k)
+    assert scalar_potential_difference(S.Zero, C, point1, point2) == 0
+    assert (scalar_potential_difference(scalar_field, C, C.origin,
+                                        genericpointC) ==
+            scalar_field)
+    assert (scalar_potential_difference(grad_field, C, C.origin,
+                                        genericpointC) ==
+            scalar_field)
+    assert scalar_potential_difference(grad_field, C, point1, point2) == 948
+    assert (scalar_potential_difference(y*z*i + x*z*j +
+                                        x*y*k, C, point1,
+                                        genericpointC) ==
+            x*y*z - 6)
+    potential_diff_P = (2*P.z*(P.x*sin(q) + P.y*cos(q))*
+                        (P.x*cos(q) - P.y*sin(q))**2)
+    assert (scalar_potential_difference(grad_field, P, P.origin,
+                                        genericpointP).simplify() ==
+            potential_diff_P.simplify())
+
+
+def test_differential_operators_curvilinear_system():
+    A = CoordSys3D('A', transformation="spherical", variable_names=["r", "theta", "phi"])
+    B = CoordSys3D('B', transformation='cylindrical', variable_names=["r", "theta", "z"])
+    # Test for spherical coordinate system and gradient
+    assert gradient(3*A.r + 4*A.theta) == 3*A.i + 4/A.r*A.j
+    assert gradient(3*A.r*A.phi + 4*A.theta) == 3*A.phi*A.i + 4/A.r*A.j + (3/sin(A.theta))*A.k
+    assert gradient(0*A.r + 0*A.theta+0*A.phi) == Vector.zero
+    assert gradient(A.r*A.theta*A.phi) == A.theta*A.phi*A.i + A.phi*A.j + (A.theta/sin(A.theta))*A.k
+    # Test for spherical coordinate system and divergence
+    assert divergence(A.r * A.i + A.theta * A.j + A.phi * A.k) == \
+           (sin(A.theta)*A.r + cos(A.theta)*A.r*A.theta)/(sin(A.theta)*A.r**2) + 3 + 1/(sin(A.theta)*A.r)
+    assert divergence(3*A.r*A.phi*A.i + A.theta*A.j + A.r*A.theta*A.phi*A.k) == \
+           (sin(A.theta)*A.r + cos(A.theta)*A.r*A.theta)/(sin(A.theta)*A.r**2) + 9*A.phi + A.theta/sin(A.theta)
+    assert divergence(Vector.zero) == 0
+    assert divergence(0*A.i + 0*A.j + 0*A.k) == 0
+    # Test for spherical coordinate system and curl
+    assert curl(A.r*A.i + A.theta*A.j + A.phi*A.k) == \
+           (cos(A.theta)*A.phi/(sin(A.theta)*A.r))*A.i + (-A.phi/A.r)*A.j + A.theta/A.r*A.k
+    assert curl(A.r*A.j + A.phi*A.k) == (cos(A.theta)*A.phi/(sin(A.theta)*A.r))*A.i + (-A.phi/A.r)*A.j + 2*A.k
+
+    # Test for cylindrical coordinate system and gradient
+    assert gradient(0*B.r + 0*B.theta+0*B.z) == Vector.zero
+    assert gradient(B.r*B.theta*B.z) == B.theta*B.z*B.i + B.z*B.j + B.r*B.theta*B.k
+    assert gradient(3*B.r) == 3*B.i
+    assert gradient(2*B.theta) == 2/B.r * B.j
+    assert gradient(4*B.z) == 4*B.k
+    # Test for cylindrical coordinate system and divergence
+    assert divergence(B.r*B.i + B.theta*B.j + B.z*B.k) == 3 + 1/B.r
+    assert divergence(B.r*B.j + B.z*B.k) == 1
+    # Test for cylindrical coordinate system and curl
+    assert curl(B.r*B.j + B.z*B.k) == 2*B.k
+    assert curl(3*B.i + 2/B.r*B.j + 4*B.k) == Vector.zero
+
+def test_mixed_coordinates():
+    # gradient
+    a = CoordSys3D('a')
+    b = CoordSys3D('b')
+    c = CoordSys3D('c')
+    assert gradient(a.x*b.y) == b.y*a.i + a.x*b.j
+    assert gradient(3*cos(q)*a.x*b.x+a.y*(a.x+(cos(q)+b.x))) ==\
+           (a.y + 3*b.x*cos(q))*a.i + (a.x + b.x + cos(q))*a.j + (3*a.x*cos(q) + a.y)*b.i
+    # Some tests need further work:
+    # assert gradient(a.x*(cos(a.x+b.x))) == (cos(a.x + b.x))*a.i + a.x*Gradient(cos(a.x + b.x))
+    # assert gradient(cos(a.x + b.x)*cos(a.x + b.z)) == Gradient(cos(a.x + b.x)*cos(a.x + b.z))
+    assert gradient(a.x**b.y) == Gradient(a.x**b.y)
+    # assert gradient(cos(a.x+b.y)*a.z) == None
+    assert gradient(cos(a.x*b.y)) == Gradient(cos(a.x*b.y))
+    assert gradient(3*cos(q)*a.x*b.x*a.z*a.y+ b.y*b.z + cos(a.x+a.y)*b.z) == \
+           (3*a.y*a.z*b.x*cos(q) - b.z*sin(a.x + a.y))*a.i + \
+           (3*a.x*a.z*b.x*cos(q) - b.z*sin(a.x + a.y))*a.j + (3*a.x*a.y*b.x*cos(q))*a.k + \
+           (3*a.x*a.y*a.z*cos(q))*b.i + b.z*b.j + (b.y + cos(a.x + a.y))*b.k
+    # divergence
+    assert divergence(a.i*a.x+a.j*a.y+a.z*a.k + b.i*b.x+b.j*b.y+b.z*b.k + c.i*c.x+c.j*c.y+c.z*c.k) == S(9)
+    # assert divergence(3*a.i*a.x*cos(a.x+b.z) + a.j*b.x*c.z) == None
+    assert divergence(3*a.i*a.x*a.z + b.j*b.x*c.z + 3*a.j*a.z*a.y) == \
+            6*a.z + b.x*Dot(b.j, c.k)
+    assert divergence(3*cos(q)*a.x*b.x*b.i*c.x) == \
+        3*a.x*b.x*cos(q)*Dot(b.i, c.i) + 3*a.x*c.x*cos(q) + 3*b.x*c.x*cos(q)*Dot(b.i, a.i)
+    assert divergence(a.x*b.x*c.x*Cross(a.x*a.i, a.y*b.j)) ==\
+           a.x*b.x*c.x*Divergence(Cross(a.x*a.i, a.y*b.j)) + \
+           b.x*c.x*Dot(Cross(a.x*a.i, a.y*b.j), a.i) + \
+           a.x*c.x*Dot(Cross(a.x*a.i, a.y*b.j), b.i) + \
+           a.x*b.x*Dot(Cross(a.x*a.i, a.y*b.j), c.i)
+    assert divergence(a.x*b.x*c.x*(a.x*a.i + b.x*b.i)) == \
+                4*a.x*b.x*c.x +\
+                a.x**2*c.x*Dot(a.i, b.i) +\
+                a.x**2*b.x*Dot(a.i, c.i) +\
+                b.x**2*c.x*Dot(b.i, a.i) +\
+                a.x*b.x**2*Dot(b.i, c.i)
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_functions.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_functions.py
new file mode 100644
index 0000000000..1785b4802d
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_functions.py
@@ -0,0 +1,179 @@
+from sympy.vector.vector import Vector
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.vector.functions import express, matrix_to_vector, orthogonalize
+from sympy import symbols, S, sqrt, sin, cos, ImmutableMatrix as Matrix, Rational
+from sympy.testing.pytest import raises
+
+N = CoordSys3D('N')
+q1, q2, q3, q4, q5 = symbols('q1 q2 q3 q4 q5')
+A = N.orient_new_axis('A', q1, N.k)  # type: ignore
+B = A.orient_new_axis('B', q2, A.i)
+C = B.orient_new_axis('C', q3, B.j)
+
+
+def test_express():
+    assert express(Vector.zero, N) == Vector.zero
+    assert express(S.Zero, N) is S.Zero
+    assert express(A.i, C) == cos(q3)*C.i + sin(q3)*C.k
+    assert express(A.j, C) == sin(q2)*sin(q3)*C.i + cos(q2)*C.j - \
+        sin(q2)*cos(q3)*C.k
+    assert express(A.k, C) == -sin(q3)*cos(q2)*C.i + sin(q2)*C.j + \
+        cos(q2)*cos(q3)*C.k
+    assert express(A.i, N) == cos(q1)*N.i + sin(q1)*N.j
+    assert express(A.j, N) == -sin(q1)*N.i + cos(q1)*N.j
+    assert express(A.k, N) == N.k
+    assert express(A.i, A) == A.i
+    assert express(A.j, A) == A.j
+    assert express(A.k, A) == A.k
+    assert express(A.i, B) == B.i
+    assert express(A.j, B) == cos(q2)*B.j - sin(q2)*B.k
+    assert express(A.k, B) == sin(q2)*B.j + cos(q2)*B.k
+    assert express(A.i, C) == cos(q3)*C.i + sin(q3)*C.k
+    assert express(A.j, C) == sin(q2)*sin(q3)*C.i + cos(q2)*C.j - \
+        sin(q2)*cos(q3)*C.k
+    assert express(A.k, C) == -sin(q3)*cos(q2)*C.i + sin(q2)*C.j + \
+        cos(q2)*cos(q3)*C.k
+    # Check to make sure UnitVectors get converted properly
+    assert express(N.i, N) == N.i
+    assert express(N.j, N) == N.j
+    assert express(N.k, N) == N.k
+    assert express(N.i, A) == (cos(q1)*A.i - sin(q1)*A.j)
+    assert express(N.j, A) == (sin(q1)*A.i + cos(q1)*A.j)
+    assert express(N.k, A) == A.k
+    assert express(N.i, B) == (cos(q1)*B.i - sin(q1)*cos(q2)*B.j +
+            sin(q1)*sin(q2)*B.k)
+    assert express(N.j, B) == (sin(q1)*B.i + cos(q1)*cos(q2)*B.j -
+            sin(q2)*cos(q1)*B.k)
+    assert express(N.k, B) == (sin(q2)*B.j + cos(q2)*B.k)
+    assert express(N.i, C) == (
+        (cos(q1)*cos(q3) - sin(q1)*sin(q2)*sin(q3))*C.i -
+        sin(q1)*cos(q2)*C.j +
+        (sin(q3)*cos(q1) + sin(q1)*sin(q2)*cos(q3))*C.k)
+    assert express(N.j, C) == (
+        (sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1))*C.i +
+        cos(q1)*cos(q2)*C.j +
+        (sin(q1)*sin(q3) - sin(q2)*cos(q1)*cos(q3))*C.k)
+    assert express(N.k, C) == (-sin(q3)*cos(q2)*C.i + sin(q2)*C.j +
+            cos(q2)*cos(q3)*C.k)
+
+    assert express(A.i, N) == (cos(q1)*N.i + sin(q1)*N.j)
+    assert express(A.j, N) == (-sin(q1)*N.i + cos(q1)*N.j)
+    assert express(A.k, N) == N.k
+    assert express(A.i, A) == A.i
+    assert express(A.j, A) == A.j
+    assert express(A.k, A) == A.k
+    assert express(A.i, B) == B.i
+    assert express(A.j, B) == (cos(q2)*B.j - sin(q2)*B.k)
+    assert express(A.k, B) == (sin(q2)*B.j + cos(q2)*B.k)
+    assert express(A.i, C) == (cos(q3)*C.i + sin(q3)*C.k)
+    assert express(A.j, C) == (sin(q2)*sin(q3)*C.i + cos(q2)*C.j -
+            sin(q2)*cos(q3)*C.k)
+    assert express(A.k, C) == (-sin(q3)*cos(q2)*C.i + sin(q2)*C.j +
+            cos(q2)*cos(q3)*C.k)
+
+    assert express(B.i, N) == (cos(q1)*N.i + sin(q1)*N.j)
+    assert express(B.j, N) == (-sin(q1)*cos(q2)*N.i +
+            cos(q1)*cos(q2)*N.j + sin(q2)*N.k)
+    assert express(B.k, N) == (sin(q1)*sin(q2)*N.i -
+            sin(q2)*cos(q1)*N.j + cos(q2)*N.k)
+    assert express(B.i, A) == A.i
+    assert express(B.j, A) == (cos(q2)*A.j + sin(q2)*A.k)
+    assert express(B.k, A) == (-sin(q2)*A.j + cos(q2)*A.k)
+    assert express(B.i, B) == B.i
+    assert express(B.j, B) == B.j
+    assert express(B.k, B) == B.k
+    assert express(B.i, C) == (cos(q3)*C.i + sin(q3)*C.k)
+    assert express(B.j, C) == C.j
+    assert express(B.k, C) == (-sin(q3)*C.i + cos(q3)*C.k)
+
+    assert express(C.i, N) == (
+        (cos(q1)*cos(q3) - sin(q1)*sin(q2)*sin(q3))*N.i +
+        (sin(q1)*cos(q3) + sin(q2)*sin(q3)*cos(q1))*N.j -
+        sin(q3)*cos(q2)*N.k)
+    assert express(C.j, N) == (
+        -sin(q1)*cos(q2)*N.i + cos(q1)*cos(q2)*N.j + sin(q2)*N.k)
+    assert express(C.k, N) == (
+        (sin(q3)*cos(q1) + sin(q1)*sin(q2)*cos(q3))*N.i +
+        (sin(q1)*sin(q3) - sin(q2)*cos(q1)*cos(q3))*N.j +
+        cos(q2)*cos(q3)*N.k)
+    assert express(C.i, A) == (cos(q3)*A.i + sin(q2)*sin(q3)*A.j -
+            sin(q3)*cos(q2)*A.k)
+    assert express(C.j, A) == (cos(q2)*A.j + sin(q2)*A.k)
+    assert express(C.k, A) == (sin(q3)*A.i - sin(q2)*cos(q3)*A.j +
+            cos(q2)*cos(q3)*A.k)
+    assert express(C.i, B) == (cos(q3)*B.i - sin(q3)*B.k)
+    assert express(C.j, B) == B.j
+    assert express(C.k, B) == (sin(q3)*B.i + cos(q3)*B.k)
+    assert express(C.i, C) == C.i
+    assert express(C.j, C) == C.j
+    assert express(C.k, C) == C.k == (C.k)
+
+    #  Check to make sure Vectors get converted back to UnitVectors
+    assert N.i == express((cos(q1)*A.i - sin(q1)*A.j), N).simplify()
+    assert N.j == express((sin(q1)*A.i + cos(q1)*A.j), N).simplify()
+    assert N.i == express((cos(q1)*B.i - sin(q1)*cos(q2)*B.j +
+            sin(q1)*sin(q2)*B.k), N).simplify()
+    assert N.j == express((sin(q1)*B.i + cos(q1)*cos(q2)*B.j -
+        sin(q2)*cos(q1)*B.k), N).simplify()
+    assert N.k == express((sin(q2)*B.j + cos(q2)*B.k), N).simplify()
+
+
+    assert A.i == express((cos(q1)*N.i + sin(q1)*N.j), A).simplify()
+    assert A.j == express((-sin(q1)*N.i + cos(q1)*N.j), A).simplify()
+
+    assert A.j == express((cos(q2)*B.j - sin(q2)*B.k), A).simplify()
+    assert A.k == express((sin(q2)*B.j + cos(q2)*B.k), A).simplify()
+
+    assert A.i == express((cos(q3)*C.i + sin(q3)*C.k), A).simplify()
+    assert A.j == express((sin(q2)*sin(q3)*C.i + cos(q2)*C.j -
+            sin(q2)*cos(q3)*C.k), A).simplify()
+
+    assert A.k == express((-sin(q3)*cos(q2)*C.i + sin(q2)*C.j +
+            cos(q2)*cos(q3)*C.k), A).simplify()
+    assert B.i == express((cos(q1)*N.i + sin(q1)*N.j), B).simplify()
+    assert B.j == express((-sin(q1)*cos(q2)*N.i +
+            cos(q1)*cos(q2)*N.j + sin(q2)*N.k), B).simplify()
+
+    assert B.k == express((sin(q1)*sin(q2)*N.i -
+            sin(q2)*cos(q1)*N.j + cos(q2)*N.k), B).simplify()
+
+    assert B.j == express((cos(q2)*A.j + sin(q2)*A.k), B).simplify()
+    assert B.k == express((-sin(q2)*A.j + cos(q2)*A.k), B).simplify()
+    assert B.i == express((cos(q3)*C.i + sin(q3)*C.k), B).simplify()
+    assert B.k == express((-sin(q3)*C.i + cos(q3)*C.k), B).simplify()
+    assert C.i == express((cos(q3)*A.i + sin(q2)*sin(q3)*A.j -
+            sin(q3)*cos(q2)*A.k), C).simplify()
+    assert C.j == express((cos(q2)*A.j + sin(q2)*A.k), C).simplify()
+    assert C.k == express((sin(q3)*A.i - sin(q2)*cos(q3)*A.j +
+            cos(q2)*cos(q3)*A.k), C).simplify()
+    assert C.i == express((cos(q3)*B.i - sin(q3)*B.k), C).simplify()
+    assert C.k == express((sin(q3)*B.i + cos(q3)*B.k), C).simplify()
+
+
+def test_matrix_to_vector():
+    m = Matrix([[1], [2], [3]])
+    assert matrix_to_vector(m, C) == C.i + 2*C.j + 3*C.k
+    m = Matrix([[0], [0], [0]])
+    assert matrix_to_vector(m, N) == matrix_to_vector(m, C) == \
+           Vector.zero
+    m = Matrix([[q1], [q2], [q3]])
+    assert matrix_to_vector(m, N) == q1*N.i + q2*N.j + q3*N.k
+
+
+def test_orthogonalize():
+    C = CoordSys3D('C')
+    a, b = symbols('a b', integer=True)
+    i, j, k = C.base_vectors()
+    v1 = i + 2*j
+    v2 = 2*i + 3*j
+    v3 = 3*i + 5*j
+    v4 = 3*i + j
+    v5 = 2*i + 2*j
+    v6 = a*i + b*j
+    v7 = 4*a*i + 4*b*j
+    assert orthogonalize(v1, v2) == [C.i + 2*C.j, C.i*Rational(2, 5) + -C.j/5]
+    # from wikipedia
+    assert orthogonalize(v4, v5, orthonormal=True) == \
+        [(3*sqrt(10))*C.i/10 + (sqrt(10))*C.j/10, (-sqrt(10))*C.i/10 + (3*sqrt(10))*C.j/10]
+    raises(ValueError, lambda: orthogonalize(v1, v2, v3))
+    raises(ValueError, lambda: orthogonalize(v6, v7))
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_implicitregion.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_implicitregion.py
new file mode 100644
index 0000000000..862aab11f8
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_implicitregion.py
@@ -0,0 +1,91 @@
+from sympy import Eq, S, sqrt
+from sympy.abc import x, y, z, s, t
+from sympy.sets import FiniteSet, EmptySet
+from sympy.geometry import Point
+from sympy.vector import ImplicitRegion
+from sympy.testing.pytest import raises
+
+
+def test_ImplicitRegion():
+    ellipse = ImplicitRegion((x, y), (x**2/4 + y**2/16 - 1))
+    assert ellipse.equation == x**2/4 + y**2/16 - 1
+    assert ellipse.variables == (x, y)
+    assert ellipse.degree == 2
+    r = ImplicitRegion((x, y, z), Eq(x**4 + y**2 - x*y, 6))
+    assert r.equation == x**4 + y**2 - x*y - 6
+    assert r.variables == (x, y, z)
+    assert r.degree == 4
+
+
+def test_regular_point():
+    r1 = ImplicitRegion((x,), x**2 - 16)
+    r1.regular_point() == (-4,)
+    c1 = ImplicitRegion((x, y), x**2 + y**2 - 4)
+    c1.regular_point() == (2, 0)
+    c2 = ImplicitRegion((x, y), (x - S(5)/2)**2 + y**2 - (S(1)/4)**2)
+    c2.regular_point() == (11/4, 0)
+    c3 = ImplicitRegion((x, y), (y - 5)**2  - 16*(x - 5))
+    c3.regular_point() == (5, 5)
+    r2 = ImplicitRegion((x, y), x**2 - 4*x*y - 3*y**2 + 4*x + 8*y - 5)
+    r2.regular_point == (4/7, 13/21)
+    r3 = ImplicitRegion((x, y), x**2 - 2*x*y + 3*y**2 - 2*x - 5*y + 3/2)
+    raises(ValueError, lambda: r3.regular_point())
+
+
+def test_singular_points_and_multiplicty():
+    r1 = ImplicitRegion((x, y, z), Eq(x + y + z, 0))
+    assert r1.singular_points() == FiniteSet((-y - z, y, z))
+    assert r1.multiplicity((0, 0, 0)) == 1
+    assert r1.multiplicity((-y - z, y, z)) == 1
+    r2 = ImplicitRegion((x, y, z), x*y*z + y**4 -x**2*z**2)
+    assert r2.singular_points() == FiniteSet((0, 0, z), ((-y*sqrt(4*y**2 + 1)/2 + y/2)/z, y, z),\
+                            ((y*sqrt(4*y**2 + 1)/2 + y/2)/z, y, z))
+    assert r2.multiplicity((0, 0, 0)) == 3
+    assert r2.multiplicity((0, 0, 6)) == 2
+    r3 = ImplicitRegion((x, y, z), z**2 - x**2 - y**2)
+    assert r3.singular_points() == FiniteSet((0, 0, 0))
+    assert r3.multiplicity((0, 0, 0)) == 2
+    r4 = ImplicitRegion((x, y), x**2 + y**2 - 2*x)
+    assert r4.singular_points() == EmptySet
+    assert r4.multiplicity(Point(1, 3)) == 0
+
+
+def test_rational_parametrization():
+    p = ImplicitRegion((x,), x - 2)
+    assert p.rational_parametrization() == (x - 2,)
+
+    line = ImplicitRegion((x, y), Eq(y, 3*x + 2))
+    assert line.rational_parametrization() == (x, 3*x + 2)
+
+    circle1 = ImplicitRegion((x, y), (x-2)**2 + (y+3)**2 - 4)
+    assert circle1.rational_parametrization(parameters=t) == (4*t/(t**2 + 1) + 2, 4*t**2/(t**2 + 1) - 5)
+    circle2 = ImplicitRegion((x, y), (x - S.Half)**2 + y**2 - (S(1)/2)**2)
+
+    assert circle2.rational_parametrization(parameters=t) == (t/(t**2 + 1) + S(1)/2, t**2/(t**2 + 1) - S(1)/2)
+    circle3 = ImplicitRegion((x, y), Eq(x**2 + y**2, 2*x))
+    assert circle3.rational_parametrization(parameters=(t,)) == (2*t/(t**2 + 1) + 1, 2*t**2/(t**2 + 1) - 1)
+
+    parabola = ImplicitRegion((x, y), (y - 3)**2 - 4*(x + 6))
+    assert parabola.rational_parametrization(t) == (-6 + 4/t**2, 3 + 4/t)
+
+    rect_hyperbola = ImplicitRegion((x, y), x*y - 1)
+    assert rect_hyperbola.rational_parametrization(t) == (-1 + (t + 1)/t, t)
+
+    cubic_curve = ImplicitRegion((x, y), x**3 + x**2 - y**2)
+    assert cubic_curve.rational_parametrization(parameters=(t)) == (t**2 - 1, t*(t**2 - 1))
+    cuspidal = ImplicitRegion((x, y), (x**3 - y**2))
+    assert cuspidal.rational_parametrization(t) == (t**2, t**3)
+
+    I = ImplicitRegion((x, y), x**3 + x**2 - y**2)
+    assert I.rational_parametrization(t) == (t**2 - 1, t*(t**2 - 1))
+
+    sphere = ImplicitRegion((x, y, z), Eq(x**2 + y**2 + z**2, 2*x))
+    assert sphere.rational_parametrization(parameters=(s, t)) == (2/(s**2 + t**2 + 1), 2*t/(s**2 + t**2 + 1), 2*s/(s**2 + t**2 + 1))
+
+    conic = ImplicitRegion((x, y), Eq(x**2 + 4*x*y + 3*y**2 + x - y + 10, 0))
+    conic.rational_parametrization(t) == (17/2 + 4/(3*t**2 + 4*t + 1), 4*t/(3*t**2 + 4*t + 1) - 11/2)
+
+    r1 = ImplicitRegion((x, y), y**2 - x**3 + x)
+    raises(NotImplementedError, lambda: r1.rational_parametrization())
+    r2 = ImplicitRegion((x, y), y**2 - x**3 - x**2 + 1)
+    raises(NotImplementedError, lambda: r2.rational_parametrization())
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_integrals.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_integrals.py
new file mode 100644
index 0000000000..e5271a2111
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_integrals.py
@@ -0,0 +1,103 @@
+from sympy import sin, cos, pi, S, sqrt
+from sympy.testing.pytest import raises
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.vector.integrals import ParametricIntegral, vector_integrate
+from sympy.vector.parametricregion import ParametricRegion
+from sympy.vector.implicitregion import ImplicitRegion
+from sympy.abc import x, y, z, u, v, r, t, theta, phi
+from sympy.geometry import Point, Segment, Curve, Circle, Polygon, Plane
+
+C = CoordSys3D('C')
+
+def test_parametric_lineintegrals():
+    halfcircle = ParametricRegion((4*cos(theta), 4*sin(theta)), (theta, -pi/2, pi/2))
+    assert ParametricIntegral(C.x*C.y**4, halfcircle) == S(8192)/5
+
+    curve = ParametricRegion((t, t**2, t**3), (t, 0, 1))
+    field1 = 8*C.x**2*C.y*C.z*C.i + 5*C.z*C.j - 4*C.x*C.y*C.k
+    assert ParametricIntegral(field1, curve) == 1
+    line = ParametricRegion((4*t - 1, 2 - 2*t, t), (t, 0, 1))
+    assert ParametricIntegral(C.x*C.z*C.i - C.y*C.z*C.k, line) == 3
+
+    assert ParametricIntegral(4*C.x**3, ParametricRegion((1, t), (t, 0, 2))) == 8
+
+    helix = ParametricRegion((cos(t), sin(t), 3*t), (t, 0, 4*pi))
+    assert ParametricIntegral(C.x*C.y*C.z, helix) == -3*sqrt(10)*pi
+
+    field2 = C.y*C.i + C.z*C.j + C.z*C.k
+    assert ParametricIntegral(field2, ParametricRegion((cos(t), sin(t), t**2), (t, 0, pi))) == -5*pi/2 + pi**4/2
+
+def test_parametric_surfaceintegrals():
+
+    semisphere = ParametricRegion((2*sin(phi)*cos(theta), 2*sin(phi)*sin(theta), 2*cos(phi)),\
+                            (theta, 0, 2*pi), (phi, 0, pi/2))
+    assert ParametricIntegral(C.z, semisphere) == 8*pi
+
+    cylinder = ParametricRegion((sqrt(3)*cos(theta), sqrt(3)*sin(theta), z), (z, 0, 6), (theta, 0, 2*pi))
+    assert ParametricIntegral(C.y, cylinder) == 0
+
+    cone = ParametricRegion((v*cos(u), v*sin(u), v), (u, 0, 2*pi), (v, 0, 1))
+    assert ParametricIntegral(C.x*C.i + C.y*C.j + C.z**4*C.k, cone) == pi/3
+
+    triangle1 = ParametricRegion((x, y), (x, 0, 2), (y, 0, 10 - 5*x))
+    triangle2 = ParametricRegion((x, y), (y, 0, 10 - 5*x), (x, 0, 2))
+    assert ParametricIntegral(-15.6*C.y*C.k, triangle1) == ParametricIntegral(-15.6*C.y*C.k, triangle2)
+    assert ParametricIntegral(C.z, triangle1) == 10*C.z
+
+def test_parametric_volumeintegrals():
+
+    cube = ParametricRegion((x, y, z), (x, 0, 1), (y, 0, 1), (z, 0, 1))
+    assert ParametricIntegral(1, cube) == 1
+
+    solidsphere1 = ParametricRegion((r*sin(phi)*cos(theta), r*sin(phi)*sin(theta), r*cos(phi)),\
+                            (r, 0, 2), (theta, 0, 2*pi), (phi, 0, pi))
+    solidsphere2 = ParametricRegion((r*sin(phi)*cos(theta), r*sin(phi)*sin(theta), r*cos(phi)),\
+                            (r, 0, 2), (phi, 0, pi), (theta, 0, 2*pi))
+    assert ParametricIntegral(C.x**2 + C.y**2, solidsphere1) == -256*pi/15
+    assert ParametricIntegral(C.x**2 + C.y**2, solidsphere2) == 256*pi/15
+
+    region_under_plane1 = ParametricRegion((x, y, z), (x, 0, 3), (y, 0, -2*x/3 + 2),\
+                                    (z, 0, 6 - 2*x - 3*y))
+    region_under_plane2 = ParametricRegion((x, y, z), (x, 0, 3), (z, 0, 6 - 2*x - 3*y),\
+                                    (y, 0, -2*x/3 + 2))
+
+    assert ParametricIntegral(C.x*C.i + C.j - 100*C.k, region_under_plane1) == \
+        ParametricIntegral(C.x*C.i + C.j - 100*C.k, region_under_plane2)
+    assert ParametricIntegral(2*C.x, region_under_plane2) == -9
+
+def test_vector_integrate():
+    halfdisc = ParametricRegion((r*cos(theta), r* sin(theta)), (r, -2, 2), (theta, 0, pi))
+    assert vector_integrate(C.x**2, halfdisc) == 4*pi
+    vector_integrate(C.x, ParametricRegion((t, t**2), (t, 2, 3))) == -17*sqrt(17)/12 + 37*sqrt(37)/12
+
+    assert  vector_integrate(C.y**3*C.z, (C.x, 0, 3), (C.y, -1, 4)) == 765*C.z/4
+
+    s1 = Segment(Point(0, 0), Point(0, 1))
+    assert vector_integrate(-15*C.y, s1) == S(-15)/2
+    s2 = Segment(Point(4, 3, 9), Point(1, 1, 7))
+    assert vector_integrate(C.y*C.i, s2) == -6
+
+    curve = Curve((sin(t), cos(t)), (t, 0, 2))
+    assert vector_integrate(5*C.z, curve) == 10*C.z
+
+    c1 = Circle(Point(2, 3), 6)
+    assert vector_integrate(C.x*C.y, c1) == 72*pi
+    c2 = Circle(Point(0, 0), Point(1, 1), Point(1, 0))
+    assert vector_integrate(1, c2) == c2.circumference
+
+    triangle = Polygon((0, 0), (1, 0), (1, 1))
+    assert vector_integrate(C.x*C.i - 14*C.y*C.j, triangle) == 0
+    p1, p2, p3, p4 = [(0, 0), (1, 0), (5, 1), (0, 1)]
+    poly = Polygon(p1, p2, p3, p4)
+    assert vector_integrate(-23*C.z, poly) == -161*C.z - 23*sqrt(17)*C.z
+
+    point = Point(2, 3)
+    assert vector_integrate(C.i*C.y - C.z, point) == ParametricIntegral(C.y*C.i, ParametricRegion((2, 3)))
+
+    c3 = ImplicitRegion((x, y), x**2 + y**2 - 4)
+    assert vector_integrate(45, c3) == 360*pi
+    c4 = ImplicitRegion((x, y), (x - 3)**2 + (y - 4)**2 - 9)
+    assert vector_integrate(1, c4) == 12*pi
+
+    pl = Plane(Point(1, 1, 1), Point(2, 3, 4), Point(2, 2, 2))
+    raises(ValueError, lambda: vector_integrate(C.x*C.z*C.i + C.k, pl))
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_operators.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_operators.py
new file mode 100644
index 0000000000..2f3eccf65e
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_operators.py
@@ -0,0 +1,40 @@
+from sympy.vector import CoordSys3D, Gradient, Divergence, Curl, VectorZero, Laplacian
+from sympy.printing.repr import srepr
+
+R = CoordSys3D('R')
+s1 = R.x*R.y*R.z  # type: ignore
+s2 = R.x + 3*R.y**2  # type: ignore
+s3 = R.x**2 + R.y**2 + R.z**2  # type: ignore
+v1 = R.x*R.i + R.z*R.z*R.j  # type: ignore
+v2 = R.x*R.i + R.y*R.j + R.z*R.k  # type: ignore
+v3 = R.x**2*R.i + R.y**2*R.j + R.z**2*R.k  # type: ignore
+
+
+def test_Gradient():
+    assert Gradient(s1) == Gradient(R.x*R.y*R.z)
+    assert Gradient(s2) == Gradient(R.x + 3*R.y**2)
+    assert Gradient(s1).doit() == R.y*R.z*R.i + R.x*R.z*R.j + R.x*R.y*R.k
+    assert Gradient(s2).doit() == R.i + 6*R.y*R.j
+
+
+def test_Divergence():
+    assert Divergence(v1) == Divergence(R.x*R.i + R.z*R.z*R.j)
+    assert Divergence(v2) == Divergence(R.x*R.i + R.y*R.j + R.z*R.k)
+    assert Divergence(v1).doit() == 1
+    assert Divergence(v2).doit() == 3
+
+
+def test_Curl():
+    assert Curl(v1) == Curl(R.x*R.i + R.z*R.z*R.j)
+    assert Curl(v2) == Curl(R.x*R.i + R.y*R.j + R.z*R.k)
+    assert Curl(v1).doit() == (-2*R.z)*R.i
+    assert Curl(v2).doit() == VectorZero()
+
+
+def test_Laplacian():
+    assert Laplacian(s3) == Laplacian(R.x**2 + R.y**2 + R.z**2)
+    assert Laplacian(v3) == Laplacian(R.x**2*R.i + R.y**2*R.j + R.z**2*R.k)
+    assert Laplacian(s3).doit() == 6
+    assert Laplacian(v3).doit() == 2*R.i + 2*R.j + 2*R.k
+    assert srepr(Laplacian(s3)) == \
+            'Laplacian(Add(Pow(R.x, Integer(2)), Pow(R.y, Integer(2)), Pow(R.z, Integer(2))))'
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_parametricregion.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_parametricregion.py
new file mode 100644
index 0000000000..68cd82db55
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_parametricregion.py
@@ -0,0 +1,96 @@
+from sympy import sin, cos, pi
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.vector.parametricregion import ParametricRegion, parametric_region_list
+from sympy.geometry import Point, Segment, Curve, Ellipse, Line, Parabola, Polygon
+from sympy.testing.pytest import raises
+from sympy.abc import a, b, r, t, x, y, z, theta, phi
+
+
+C = CoordSys3D('C')
+
+def test_ParametricRegion():
+
+    point = ParametricRegion((3, 4))
+    assert point.definition == (3, 4)
+    assert point.parameters == ()
+    assert point.limits == {}
+    assert point.dimensions == 0
+
+    # line x = y
+    line_xy = ParametricRegion((y, y), (y, 1, 5))
+    assert line_xy .definition == (y, y)
+    assert line_xy.parameters == (y,)
+    assert line_xy.dimensions == 1
+
+    # line y = z
+    line_yz = ParametricRegion((x,t,t), x, (t, 1, 2))
+    assert line_yz.definition == (x,t,t)
+    assert line_yz.parameters == (x, t)
+    assert line_yz.limits == {t: (1, 2)}
+    assert line_yz.dimensions == 1
+
+    p1 = ParametricRegion((9*a, -16*b), (a, 0, 2), (b, -1, 5))
+    assert p1.definition == (9*a, -16*b)
+    assert p1.parameters == (a, b)
+    assert p1.limits == {a: (0, 2), b: (-1, 5)}
+    assert p1.dimensions == 2
+
+    p2 = ParametricRegion((t, t**3), t)
+    assert p2.parameters == (t,)
+    assert p2.limits == {}
+    assert p2.dimensions == 0
+
+    circle = ParametricRegion((r*cos(theta), r*sin(theta)), r, (theta, 0, 2*pi))
+    assert circle.definition == (r*cos(theta), r*sin(theta))
+    assert circle.dimensions == 1
+
+    halfdisc = ParametricRegion((r*cos(theta), r*sin(theta)), (r, -2, 2), (theta, 0, pi))
+    assert halfdisc.definition == (r*cos(theta), r*sin(theta))
+    assert halfdisc.parameters == (r, theta)
+    assert halfdisc.limits == {r: (-2, 2), theta: (0, pi)}
+    assert halfdisc.dimensions == 2
+
+    ellipse = ParametricRegion((a*cos(t), b*sin(t)), (t, 0, 8))
+    assert ellipse.parameters == (t,)
+    assert ellipse.limits == {t: (0, 8)}
+    assert ellipse.dimensions == 1
+
+    cylinder = ParametricRegion((r*cos(theta), r*sin(theta), z), (r, 0, 1), (theta, 0, 2*pi), (z, 0, 4))
+    assert cylinder.parameters == (r, theta, z)
+    assert cylinder.dimensions == 3
+
+    sphere = ParametricRegion((r*sin(phi)*cos(theta),r*sin(phi)*sin(theta), r*cos(phi)),
+                                r, (theta, 0, 2*pi), (phi, 0, pi))
+    assert sphere.definition == (r*sin(phi)*cos(theta),r*sin(phi)*sin(theta), r*cos(phi))
+    assert sphere.parameters == (r, theta, phi)
+    assert sphere.dimensions == 2
+
+    raises(ValueError, lambda: ParametricRegion((a*t**2, 2*a*t), (a, -2)))
+    raises(ValueError, lambda: ParametricRegion((a, b), (a**2, sin(b)), (a, 2, 4, 6)))
+
+
+def test_parametric_region_list():
+
+    point = Point(-5, 12)
+    assert parametric_region_list(point) == [ParametricRegion((-5, 12))]
+
+    e = Ellipse(Point(2, 8), 2, 6)
+    assert parametric_region_list(e, t) == [ParametricRegion((2*cos(t) + 2, 6*sin(t) + 8), (t, 0, 2*pi))]
+
+    c = Curve((t, t**3), (t, 5, 3))
+    assert parametric_region_list(c) == [ParametricRegion((t, t**3), (t, 5, 3))]
+
+    s = Segment(Point(2, 11, -6), Point(0, 2, 5))
+    assert parametric_region_list(s, t) == [ParametricRegion((2 - 2*t, 11 - 9*t, 11*t - 6), (t, 0, 1))]
+    s1 = Segment(Point(0, 0), (1, 0))
+    assert parametric_region_list(s1, t) == [ParametricRegion((t, 0), (t, 0, 1))]
+    s2 = Segment(Point(1, 2, 3), Point(1, 2, 5))
+    assert parametric_region_list(s2, t) == [ParametricRegion((1, 2, 2*t + 3), (t, 0, 1))]
+    s3 = Segment(Point(12, 56), Point(12, 56))
+    assert parametric_region_list(s3) == [ParametricRegion((12, 56))]
+
+    poly = Polygon((1,3), (-3, 8), (2, 4))
+    assert parametric_region_list(poly, t) == [ParametricRegion((1 - 4*t, 5*t + 3), (t, 0, 1)), ParametricRegion((5*t - 3, 8 - 4*t), (t, 0, 1)), ParametricRegion((2 - t, 4 - t), (t, 0, 1))]
+
+    p1 = Parabola(Point(0, 0), Line(Point(5, 8), Point(7,8)))
+    raises(ValueError, lambda: parametric_region_list(p1))
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_printing.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_printing.py
new file mode 100644
index 0000000000..7edac35a0e
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_printing.py
@@ -0,0 +1,168 @@
+# -*- coding: utf-8 -*-
+from sympy import Integral, latex, Function
+from sympy import pretty as xpretty
+from sympy.vector import CoordSys3D, Vector, express
+from sympy.abc import a, b, c
+from sympy.testing.pytest import XFAIL
+
+
+def pretty(expr):
+    """ASCII pretty-printing"""
+    return xpretty(expr, use_unicode=False, wrap_line=False)
+
+
+def upretty(expr):
+    """Unicode pretty-printing"""
+    return xpretty(expr, use_unicode=True, wrap_line=False)
+
+
+# Initialize the basic and tedious vector/dyadic expressions
+# needed for testing.
+# Some of the pretty forms shown denote how the expressions just
+# above them should look with pretty printing.
+N = CoordSys3D('N')
+C = N.orient_new_axis('C', a, N.k)  # type: ignore
+v = []
+d = []
+v.append(Vector.zero)
+v.append(N.i)  # type: ignore
+v.append(-N.i)  # type: ignore
+v.append(N.i + N.j)  # type: ignore
+v.append(a*N.i)  # type: ignore
+v.append(a*N.i - b*N.j)  # type: ignore
+v.append((a**2 + N.x)*N.i + N.k)  # type: ignore
+v.append((a**2 + b)*N.i + 3*(C.y - c)*N.k)  # type: ignore
+f = Function('f')
+v.append(N.j - (Integral(f(b)) - C.x**2)*N.k)  # type: ignore
+upretty_v_8 = """\
+      ⎛   2   ⌠        ⎞    \n\
+j_N + ⎜x_C  - ⎮ f(b) db⎟ k_N\n\
+      ⎝       ⌡        ⎠    \
+"""
+pretty_v_8 = """\
+j_N + /         /       \\\n\
+      |   2    |        |\n\
+      |x_C  -  | f(b) db|\n\
+      |        |        |\n\
+      \\       /         / \
+"""
+
+v.append(N.i + C.k)  # type: ignore
+v.append(express(N.i, C))  # type: ignore
+v.append((a**2 + b)*N.i + (Integral(f(b)))*N.k)  # type: ignore
+upretty_v_11 = """\
+⎛ 2    ⎞        ⎛⌠        ⎞    \n\
+⎝a  + b⎠ i_N  + ⎜⎮ f(b) db⎟ k_N\n\
+                ⎝⌡        ⎠    \
+"""
+pretty_v_11 = """\
+/ 2    \\ + /  /       \\\n\
+\\a  + b/ i_N| |        |\n\
+           | | f(b) db|\n\
+           | |        |\n\
+           \\/         / \
+"""
+
+for x in v:
+    d.append(x | N.k)  # type: ignore
+s = 3*N.x**2*C.y  # type: ignore
+upretty_s = """\
+         2\n\
+3⋅y_C⋅x_N \
+"""
+pretty_s = """\
+         2\n\
+3*y_C*x_N \
+"""
+
+# This is the pretty form for ((a**2 + b)*N.i + 3*(C.y - c)*N.k) | N.k
+upretty_d_7 = """\
+⎛ 2    ⎞                                     \n\
+⎝a  + b⎠ (i_N|k_N)  + (3⋅y_C - 3⋅c) (k_N|k_N)\
+"""
+pretty_d_7 = """\
+/ 2    \\ (i_N|k_N) + (3*y_C - 3*c) (k_N|k_N)\n\
+\\a  + b/                                    \
+"""
+
+
+def test_str_printing():
+    assert str(v[0]) == '0'
+    assert str(v[1]) == 'N.i'
+    assert str(v[2]) == '(-1)*N.i'
+    assert str(v[3]) == 'N.i + N.j'
+    assert str(v[8]) == 'N.j + (C.x**2 - Integral(f(b), b))*N.k'
+    assert str(v[9]) == 'C.k + N.i'
+    assert str(s) == '3*C.y*N.x**2'
+    assert str(d[0]) == '0'
+    assert str(d[1]) == '(N.i|N.k)'
+    assert str(d[4]) == 'a*(N.i|N.k)'
+    assert str(d[5]) == 'a*(N.i|N.k) + (-b)*(N.j|N.k)'
+    assert str(d[8]) == ('(N.j|N.k) + (C.x**2 - ' +
+                         'Integral(f(b), b))*(N.k|N.k)')
+
+
+@XFAIL
+def test_pretty_printing_ascii():
+    assert pretty(v[0]) == '0'
+    assert pretty(v[1]) == 'i_N'
+    assert pretty(v[5]) == '(a) i_N + (-b) j_N'
+    assert pretty(v[8]) == pretty_v_8
+    assert pretty(v[2]) == '(-1) i_N'
+    assert pretty(v[11]) == pretty_v_11
+    assert pretty(s) == pretty_s
+    assert pretty(d[0]) == '(0|0)'
+    assert pretty(d[5]) == '(a) (i_N|k_N) + (-b) (j_N|k_N)'
+    assert pretty(d[7]) == pretty_d_7
+    assert pretty(d[10]) == '(cos(a)) (i_C|k_N) + (-sin(a)) (j_C|k_N)'
+
+
+def test_pretty_print_unicode_v():
+    assert upretty(v[0]) == '0'
+    assert upretty(v[1]) == 'i_N'
+    assert upretty(v[5]) == '(a) i_N + (-b) j_N'
+    # Make sure the printing works in other objects
+    assert upretty(v[5].args) == '((a) i_N, (-b) j_N)'
+    assert upretty(v[8]) == upretty_v_8
+    assert upretty(v[2]) == '(-1) i_N'
+    assert upretty(v[11]) == upretty_v_11
+    assert upretty(s) == upretty_s
+    assert upretty(d[0]) == '(0|0)'
+    assert upretty(d[5]) == '(a) (i_N|k_N) + (-b) (j_N|k_N)'
+    assert upretty(d[7]) == upretty_d_7
+    assert upretty(d[10]) == '(cos(a)) (i_C|k_N) + (-sin(a)) (j_C|k_N)'
+
+
+def test_latex_printing():
+    assert latex(v[0]) == '\\mathbf{\\hat{0}}'
+    assert latex(v[1]) == '\\mathbf{\\hat{i}_{N}}'
+    assert latex(v[2]) == '- \\mathbf{\\hat{i}_{N}}'
+    assert latex(v[5]) == ('(a)\\mathbf{\\hat{i}_{N}} + ' +
+                           '(- b)\\mathbf{\\hat{j}_{N}}')
+    assert latex(v[6]) == ('(\\mathbf{{x}_{N}} + a^{2})\\mathbf{\\hat{i}_' +
+                          '{N}} + \\mathbf{\\hat{k}_{N}}')
+    assert latex(v[8]) == ('\\mathbf{\\hat{j}_{N}} + (\\mathbf{{x}_' +
+                           '{C}}^{2} - \\int f{\\left(b \\right)}\\,' +
+                           ' db)\\mathbf{\\hat{k}_{N}}')
+    assert latex(s) == '3 \\mathbf{{y}_{C}} \\mathbf{{x}_{N}}^{2}'
+    assert latex(d[0]) == '(\\mathbf{\\hat{0}}|\\mathbf{\\hat{0}})'
+    assert latex(d[4]) == ('(a)(\\mathbf{\\hat{i}_{N}}{|}\\mathbf' +
+                           '{\\hat{k}_{N}})')
+    assert latex(d[9]) == ('(\\mathbf{\\hat{k}_{C}}{|}\\mathbf{\\' +
+                           'hat{k}_{N}}) + (\\mathbf{\\hat{i}_{N}}{|' +
+                           '}\\mathbf{\\hat{k}_{N}})')
+    assert latex(d[11]) == ('(a^{2} + b)(\\mathbf{\\hat{i}_{N}}{|}\\' +
+                            'mathbf{\\hat{k}_{N}}) + (\\int f{\\left(' +
+                            'b \\right)}\\, db)(\\mathbf{\\hat{k}_{N}' +
+                            '}{|}\\mathbf{\\hat{k}_{N}})')
+
+
+def test_custom_names():
+    A = CoordSys3D('A', vector_names=['x', 'y', 'z'],
+                   variable_names=['i', 'j', 'k'])
+    assert A.i.__str__() == 'A.i'
+    assert A.x.__str__() == 'A.x'
+    assert A.i._pretty_form == 'i_A'
+    assert A.x._pretty_form == 'x_A'
+    assert A.i._latex_form == r'\mathbf{{i}_{A}}'
+    assert A.x._latex_form == r"\mathbf{\hat{x}_{A}}"
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_vector.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_vector.py
new file mode 100644
index 0000000000..f7fc13d66f
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/tests/test_vector.py
@@ -0,0 +1,241 @@
+from sympy.core import Rational
+from sympy.simplify import simplify, trigsimp
+from sympy import pi, sqrt, symbols, ImmutableMatrix as Matrix, \
+     sin, cos, Function, Integral, Derivative, diff
+from sympy.vector.vector import Vector, BaseVector, VectorAdd, \
+     VectorMul, VectorZero
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.vector.vector import Cross, Dot, cross
+from sympy.testing.pytest import raises
+
+C = CoordSys3D('C')
+
+i, j, k = C.base_vectors()
+a, b, c = symbols('a b c')
+
+
+def test_cross():
+    v1 = C.x * i + C.z * C.z * j
+    v2 = C.x * i + C.y * j + C.z * k
+    assert Cross(v1, v2) == Cross(C.x*C.i + C.z**2*C.j, C.x*C.i + C.y*C.j + C.z*C.k)
+    assert Cross(v1, v2).doit() == C.z**3*C.i + (-C.x*C.z)*C.j + (C.x*C.y - C.x*C.z**2)*C.k
+    assert cross(v1, v2) == C.z**3*C.i + (-C.x*C.z)*C.j + (C.x*C.y - C.x*C.z**2)*C.k
+    assert Cross(v1, v2) == -Cross(v2, v1)
+    assert Cross(v1, v2) + Cross(v2, v1) == Vector.zero
+
+
+def test_dot():
+    v1 = C.x * i + C.z * C.z * j
+    v2 = C.x * i + C.y * j + C.z * k
+    assert Dot(v1, v2) == Dot(C.x*C.i + C.z**2*C.j, C.x*C.i + C.y*C.j + C.z*C.k)
+    assert Dot(v1, v2).doit() == C.x**2 + C.y*C.z**2
+    assert Dot(v1, v2).doit() == C.x**2 + C.y*C.z**2
+    assert Dot(v1, v2) == Dot(v2, v1)
+
+
+def test_vector_sympy():
+    """
+    Test whether the Vector framework confirms to the hashing
+    and equality testing properties of SymPy.
+    """
+    v1 = 3*j
+    assert v1 == j*3
+    assert v1.components == {j: 3}
+    v2 = 3*i + 4*j + 5*k
+    v3 = 2*i + 4*j + i + 4*k + k
+    assert v3 == v2
+    assert v3.__hash__() == v2.__hash__()
+
+
+def test_vector():
+    assert isinstance(i, BaseVector)
+    assert i != j
+    assert j != k
+    assert k != i
+    assert i - i == Vector.zero
+    assert i + Vector.zero == i
+    assert i - Vector.zero == i
+    assert Vector.zero != 0
+    assert -Vector.zero == Vector.zero
+
+    v1 = a*i + b*j + c*k
+    v2 = a**2*i + b**2*j + c**2*k
+    v3 = v1 + v2
+    v4 = 2 * v1
+    v5 = a * i
+
+    assert isinstance(v1, VectorAdd)
+    assert v1 - v1 == Vector.zero
+    assert v1 + Vector.zero == v1
+    assert v1.dot(i) == a
+    assert v1.dot(j) == b
+    assert v1.dot(k) == c
+    assert i.dot(v2) == a**2
+    assert j.dot(v2) == b**2
+    assert k.dot(v2) == c**2
+    assert v3.dot(i) == a**2 + a
+    assert v3.dot(j) == b**2 + b
+    assert v3.dot(k) == c**2 + c
+
+    assert v1 + v2 == v2 + v1
+    assert v1 - v2 == -1 * (v2 - v1)
+    assert a * v1 == v1 * a
+
+    assert isinstance(v5, VectorMul)
+    assert v5.base_vector == i
+    assert v5.measure_number == a
+    assert isinstance(v4, Vector)
+    assert isinstance(v4, VectorAdd)
+    assert isinstance(v4, Vector)
+    assert isinstance(Vector.zero, VectorZero)
+    assert isinstance(Vector.zero, Vector)
+    assert isinstance(v1 * 0, VectorZero)
+
+    assert v1.to_matrix(C) == Matrix([[a], [b], [c]])
+
+    assert i.components == {i: 1}
+    assert v5.components == {i: a}
+    assert v1.components == {i: a, j: b, k: c}
+
+    assert VectorAdd(v1, Vector.zero) == v1
+    assert VectorMul(a, v1) == v1*a
+    assert VectorMul(1, i) == i
+    assert VectorAdd(v1, Vector.zero) == v1
+    assert VectorMul(0, Vector.zero) == Vector.zero
+    raises(TypeError, lambda: v1.outer(1))
+    raises(TypeError, lambda: v1.dot(1))
+
+
+def test_vector_magnitude_normalize():
+    assert Vector.zero.magnitude() == 0
+    assert Vector.zero.normalize() == Vector.zero
+
+    assert i.magnitude() == 1
+    assert j.magnitude() == 1
+    assert k.magnitude() == 1
+    assert i.normalize() == i
+    assert j.normalize() == j
+    assert k.normalize() == k
+
+    v1 = a * i
+    assert v1.normalize() == (a/sqrt(a**2))*i
+    assert v1.magnitude() == sqrt(a**2)
+
+    v2 = a*i + b*j + c*k
+    assert v2.magnitude() == sqrt(a**2 + b**2 + c**2)
+    assert v2.normalize() == v2 / v2.magnitude()
+
+    v3 = i + j
+    assert v3.normalize() == (sqrt(2)/2)*C.i + (sqrt(2)/2)*C.j
+
+
+def test_vector_simplify():
+    A, s, k, m = symbols('A, s, k, m')
+
+    test1 = (1 / a + 1 / b) * i
+    assert (test1 & i) != (a + b) / (a * b)
+    test1 = simplify(test1)
+    assert (test1 & i) == (a + b) / (a * b)
+    assert test1.simplify() == simplify(test1)
+
+    test2 = (A**2 * s**4 / (4 * pi * k * m**3)) * i
+    test2 = simplify(test2)
+    assert (test2 & i) == (A**2 * s**4 / (4 * pi * k * m**3))
+
+    test3 = ((4 + 4 * a - 2 * (2 + 2 * a)) / (2 + 2 * a)) * i
+    test3 = simplify(test3)
+    assert (test3 & i) == 0
+
+    test4 = ((-4 * a * b**2 - 2 * b**3 - 2 * a**2 * b) / (a + b)**2) * i
+    test4 = simplify(test4)
+    assert (test4 & i) == -2 * b
+
+    v = (sin(a)+cos(a))**2*i - j
+    assert trigsimp(v) == (2*sin(a + pi/4)**2)*i + (-1)*j
+    assert trigsimp(v) == v.trigsimp()
+
+    assert simplify(Vector.zero) == Vector.zero
+
+
+def test_vector_dot():
+    assert i.dot(Vector.zero) == 0
+    assert Vector.zero.dot(i) == 0
+    assert i & Vector.zero == 0
+
+    assert i.dot(i) == 1
+    assert i.dot(j) == 0
+    assert i.dot(k) == 0
+    assert i & i == 1
+    assert i & j == 0
+    assert i & k == 0
+
+    assert j.dot(i) == 0
+    assert j.dot(j) == 1
+    assert j.dot(k) == 0
+    assert j & i == 0
+    assert j & j == 1
+    assert j & k == 0
+
+    assert k.dot(i) == 0
+    assert k.dot(j) == 0
+    assert k.dot(k) == 1
+    assert k & i == 0
+    assert k & j == 0
+    assert k & k == 1
+
+    raises(TypeError, lambda: k.dot(1))
+
+
+def test_vector_cross():
+    assert i.cross(Vector.zero) == Vector.zero
+    assert Vector.zero.cross(i) == Vector.zero
+
+    assert i.cross(i) == Vector.zero
+    assert i.cross(j) == k
+    assert i.cross(k) == -j
+    assert i ^ i == Vector.zero
+    assert i ^ j == k
+    assert i ^ k == -j
+
+    assert j.cross(i) == -k
+    assert j.cross(j) == Vector.zero
+    assert j.cross(k) == i
+    assert j ^ i == -k
+    assert j ^ j == Vector.zero
+    assert j ^ k == i
+
+    assert k.cross(i) == j
+    assert k.cross(j) == -i
+    assert k.cross(k) == Vector.zero
+    assert k ^ i == j
+    assert k ^ j == -i
+    assert k ^ k == Vector.zero
+
+    assert k.cross(1) == Cross(k, 1)
+
+
+def test_projection():
+    v1 = i + j + k
+    v2 = 3*i + 4*j
+    v3 = 0*i + 0*j
+    assert v1.projection(v1) == i + j + k
+    assert v1.projection(v2) == Rational(7, 3)*C.i + Rational(7, 3)*C.j + Rational(7, 3)*C.k
+    assert v1.projection(v1, scalar=True) == 1
+    assert v1.projection(v2, scalar=True) == Rational(7, 3)
+    assert v3.projection(v1) == Vector.zero
+
+
+def test_vector_diff_integrate():
+    f = Function('f')
+    v = f(a)*C.i + a**2*C.j - C.k
+    assert Derivative(v, a) == Derivative((f(a))*C.i +
+                                          a**2*C.j + (-1)*C.k, a)
+    assert (diff(v, a) == v.diff(a) == Derivative(v, a).doit() ==
+            (Derivative(f(a), a))*C.i + 2*a*C.j)
+    assert (Integral(v, a) == (Integral(f(a), a))*C.i +
+            (Integral(a**2, a))*C.j + (Integral(-1, a))*C.k)
+
+
+def test_vector_args():
+    raises(ValueError, lambda: BaseVector(3, C))
+    raises(TypeError, lambda: BaseVector(0, Vector.zero))
diff --git a/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/vector.py b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/vector.py
new file mode 100644
index 0000000000..0a35b69b78
--- /dev/null
+++ b/sympy_env/lib/python3.9/site-packages/sympy-1.7.1-py3.9.egg/sympy/vector/vector.py
@@ -0,0 +1,617 @@
+from typing import Type
+
+from sympy.core.assumptions import StdFactKB
+from sympy.core import S, Pow, sympify
+from sympy.core.expr import AtomicExpr, Expr
+from sympy.core.compatibility import default_sort_key
+from sympy import sqrt, ImmutableMatrix as Matrix, Add
+from sympy.vector.coordsysrect import CoordSys3D
+from sympy.vector.basisdependent import (BasisDependent, BasisDependentAdd,
+                                         BasisDependentMul, BasisDependentZero)
+from sympy.vector.dyadic import BaseDyadic, Dyadic, DyadicAdd
+
+
+class Vector(BasisDependent):
+    """
+    Super class for all Vector classes.
+    Ideally, neither this class nor any of its subclasses should be
+    instantiated by the user.
+    """
+
+    is_Vector = True
+    _op_priority = 12.0
+
+    _expr_type = None  # type: Type[Vector]
+    _mul_func = None  # type: Type[Vector]
+    _add_func = None  # type: Type[Vector]
+    _zero_func = None  # type: Type[Vector]
+    _base_func = None  # type: Type[Vector]
+    zero = None  # type: VectorZero
+
+    @property
+    def components(self):
+        """
+        Returns the components of this vector in the form of a
+        Python dictionary mapping BaseVector instances to the
+        corresponding measure numbers.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> C = CoordSys3D('C')
+        >>> v = 3*C.i + 4*C.j + 5*C.k
+        >>> v.components
+        {C.i: 3, C.j: 4, C.k: 5}
+
+        """
+        # The '_components' attribute is defined according to the
+        # subclass of Vector the instance belongs to.
+        return self._components
+
+    def magnitude(self):
+        """
+        Returns the magnitude of this vector.
+        """
+        return sqrt(self & self)
+
+    def normalize(self):
+        """
+        Returns the normalized version of this vector.
+        """
+        return self / self.magnitude()
+
+    def dot(self, other):
+        """
+        Returns the dot product of this Vector, either with another
+        Vector, or a Dyadic, or a Del operator.
+        If 'other' is a Vector, returns the dot product scalar (Sympy
+        expression).
+        If 'other' is a Dyadic, the dot product is returned as a Vector.
+        If 'other' is an instance of Del, returns the directional
+        derivative operator as a Python function. If this function is
+        applied to a scalar expression, it returns the directional
+        derivative of the scalar field wrt this Vector.
+
+        Parameters
+        ==========
+
+        other: Vector/Dyadic/Del
+            The Vector or Dyadic we are dotting with, or a Del operator .
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D, Del
+        >>> C = CoordSys3D('C')
+        >>> delop = Del()
+        >>> C.i.dot(C.j)
+        0
+        >>> C.i & C.i
+        1
+        >>> v = 3*C.i + 4*C.j + 5*C.k
+        >>> v.dot(C.k)
+        5
+        >>> (C.i & delop)(C.x*C.y*C.z)
+        C.y*C.z
+        >>> d = C.i.outer(C.i)
+        >>> C.i.dot(d)
+        C.i
+
+        """
+
+        # Check special cases
+        if isinstance(other, Dyadic):
+            if isinstance(self, VectorZero):
+                return Vector.zero
+            outvec = Vector.zero
+            for k, v in other.components.items():
+                vect_dot = k.args[0].dot(self)
+                outvec += vect_dot * v * k.args[1]
+            return outvec
+        from sympy.vector.deloperator import Del
+        if not isinstance(other, Vector) and not isinstance(other, Del):
+            raise TypeError(str(other) + " is not a vector, dyadic or " +
+                            "del operator")
+
+        # Check if the other is a del operator
+        if isinstance(other, Del):
+            def directional_derivative(field):
+                from sympy.vector.functions import directional_derivative
+                return directional_derivative(field, self)
+            return directional_derivative
+
+        return dot(self, other)
+
+    def __and__(self, other):
+        return self.dot(other)
+
+    __and__.__doc__ = dot.__doc__
+
+    def cross(self, other):
+        """
+        Returns the cross product of this Vector with another Vector or
+        Dyadic instance.
+        The cross product is a Vector, if 'other' is a Vector. If 'other'
+        is a Dyadic, this returns a Dyadic instance.
+
+        Parameters
+        ==========
+
+        other: Vector/Dyadic
+            The Vector or Dyadic we are crossing with.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> C = CoordSys3D('C')
+        >>> C.i.cross(C.j)
+        C.k
+        >>> C.i ^ C.i
+        0
+        >>> v = 3*C.i + 4*C.j + 5*C.k
+        >>> v ^ C.i
+        5*C.j + (-4)*C.k
+        >>> d = C.i.outer(C.i)
+        >>> C.j.cross(d)
+        (-1)*(C.k|C.i)
+
+        """
+
+        # Check special cases
+        if isinstance(other, Dyadic):
+            if isinstance(self, VectorZero):
+                return Dyadic.zero
+            outdyad = Dyadic.zero
+            for k, v in other.components.items():
+                cross_product = self.cross(k.args[0])
+                outer = cross_product.outer(k.args[1])
+                outdyad += v * outer
+            return outdyad
+
+        return cross(self, other)
+
+    def __xor__(self, other):
+        return self.cross(other)
+
+    __xor__.__doc__ = cross.__doc__
+
+    def outer(self, other):
+        """
+        Returns the outer product of this vector with another, in the
+        form of a Dyadic instance.
+
+        Parameters
+        ==========
+
+        other : Vector
+            The Vector with respect to which the outer product is to
+            be computed.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> N = CoordSys3D('N')
+        >>> N.i.outer(N.j)
+        (N.i|N.j)
+
+        """
+
+        # Handle the special cases
+        if not isinstance(other, Vector):
+            raise TypeError("Invalid operand for outer product")
+        elif (isinstance(self, VectorZero) or
+                isinstance(other, VectorZero)):
+            return Dyadic.zero
+
+        # Iterate over components of both the vectors to generate
+        # the required Dyadic instance
+        args = []
+        for k1, v1 in self.components.items():
+            for k2, v2 in other.components.items():
+                args.append((v1 * v2) * BaseDyadic(k1, k2))
+
+        return DyadicAdd(*args)
+
+    def projection(self, other, scalar=False):
+        """
+        Returns the vector or scalar projection of the 'other' on 'self'.
+
+        Examples
+        ========
+
+        >>> from sympy.vector.coordsysrect import CoordSys3D
+        >>> C = CoordSys3D('C')
+        >>> i, j, k = C.base_vectors()
+        >>> v1 = i + j + k
+        >>> v2 = 3*i + 4*j
+        >>> v1.projection(v2)
+        7/3*C.i + 7/3*C.j + 7/3*C.k
+        >>> v1.projection(v2, scalar=True)
+        7/3
+
+        """
+        if self.equals(Vector.zero):
+            return S.zero if scalar else Vector.zero
+
+        if scalar:
+            return self.dot(other) / self.dot(self)
+        else:
+            return self.dot(other) / self.dot(self) * self
+
+    @property
+    def _projections(self):
+        """
+        Returns the components of this vector but the output includes
+        also zero values components.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D, Vector
+        >>> C = CoordSys3D('C')
+        >>> v1 = 3*C.i + 4*C.j + 5*C.k
+        >>> v1._projections
+        (3, 4, 5)
+        >>> v2 = C.x*C.y*C.z*C.i
+        >>> v2._projections
+        (C.x*C.y*C.z, 0, 0)
+        >>> v3 = Vector.zero
+        >>> v3._projections
+        (0, 0, 0)
+        """
+
+        from sympy.vector.operators import _get_coord_sys_from_expr
+        if isinstance(self, VectorZero):
+            return (S.Zero, S.Zero, S.Zero)
+        base_vec = next(iter(_get_coord_sys_from_expr(self))).base_vectors()
+        return tuple([self.dot(i) for i in base_vec])
+
+    def __or__(self, other):
+        return self.outer(other)
+
+    __or__.__doc__ = outer.__doc__
+
+    def to_matrix(self, system):
+        """
+        Returns the matrix form of this vector with respect to the
+        specified coordinate system.
+
+        Parameters
+        ==========
+
+        system : CoordSys3D
+            The system wrt which the matrix form is to be computed
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> C = CoordSys3D('C')
+        >>> from sympy.abc import a, b, c
+        >>> v = a*C.i + b*C.j + c*C.k
+        >>> v.to_matrix(C)
+        Matrix([
+        [a],
+        [b],
+        [c]])
+
+        """
+
+        return Matrix([self.dot(unit_vec) for unit_vec in
+                       system.base_vectors()])
+
+    def separate(self):
+        """
+        The constituents of this vector in different coordinate systems,
+        as per its definition.
+
+        Returns a dict mapping each CoordSys3D to the corresponding
+        constituent Vector.
+
+        Examples
+        ========
+
+        >>> from sympy.vector import CoordSys3D
+        >>> R1 = CoordSys3D('R1')
+        >>> R2 = CoordSys3D('R2')
+        >>> v = R1.i + R2.i
+        >>> v.separate() == {R1: R1.i, R2: R2.i}
+        True
+
+        """
+
+        parts = {}
+        for vect, measure in self.components.items():
+            parts[vect.system] = (parts.get(vect.system, Vector.zero) +
+                                  vect * measure)
+        return parts
+
+    def _div_helper(one, other):
+        """ Helper for division involving vectors. """
+        if isinstance(one, Vector) and isinstance(other, Vector):
+            raise TypeError("Cannot divide two vectors")
+        elif isinstance(one, Vector):
+            if other == S.Zero:
+                raise ValueError("Cannot divide a vector by zero")
+            return VectorMul(one, Pow(other, S.NegativeOne))
+        else:
+            raise TypeError("Invalid division involving a vector")
+
+
+class BaseVector(Vector, AtomicExpr):
+    """
+    Class to denote a base vector.
+
+    Unicode pretty forms in Python 2 should use the prefix ``u``.
+
+    """
+
+    def __new__(cls, index, system, pretty_str=None, latex_str=None):
+        if pretty_str is None:
+            pretty_str = "x{}".format(index)
+        if latex_str is None:
+            latex_str = "x_{}".format(index)
+        pretty_str = str(pretty_str)
+        latex_str = str(latex_str)
+        # Verify arguments
+        if index not in range(0, 3):
+            raise ValueError("index must be 0, 1 or 2")
+        if not isinstance(system, CoordSys3D):
+            raise TypeError("system should be a CoordSys3D")
+        name = system._vector_names[index]
+        # Initialize an object
+        obj = super().__new__(cls, S(index), system)
+        # Assign important attributes
+        obj._base_instance = obj
+        obj._components = {obj: S.One}
+        obj._measure_number = S.One
+        obj._name = system._name + '.' + name
+        obj._pretty_form = '' + pretty_str
+        obj._latex_form = latex_str
+        obj._system = system
+        # The _id is used for printing purposes
+        obj._id = (index, system)
+        assumptions = {'commutative': True}
+        obj._assumptions = StdFactKB(assumptions)
+
+        # This attr is used for re-expression to one of the systems
+        # involved in the definition of the Vector. Applies to
+        # VectorMul and VectorAdd too.
+        obj._sys = system
+
+        return obj
+
+    @property
+    def system(self):
+        return self._system
+
+    def _sympystr(self, printer):
+        return self._name
+
+    @property
+    def free_symbols(self):
+        return {self}
+
+
+class VectorAdd(BasisDependentAdd, Vector):
+    """
+    Class to denote sum of Vector instances.
+    """
+
+    def __new__(cls, *args, **options):
+        obj = BasisDependentAdd.__new__(cls, *args, **options)
+        return obj
+
+    def _sympystr(self, printer):
+        ret_str = ''
+        items = list(self.separate().items())
+        items.sort(key=lambda x: x[0].__str__())
+        for system, vect in items:
+            base_vects = system.base_vectors()
+            for x in base_vects:
+                if x in vect.components:
+                    temp_vect = self.components[x] * x
+                    ret_str += printer._print(temp_vect) + " + "
+        return ret_str[:-3]
+
+
+class VectorMul(BasisDependentMul, Vector):
+    """
+    Class to denote products of scalars and BaseVectors.
+    """
+
+    def __new__(cls, *args, **options):
+        obj = BasisDependentMul.__new__(cls, *args, **options)
+        return obj
+
+    @property
+    def base_vector(self):
+        """ The BaseVector involved in the product. """
+        return self._base_instance
+
+    @property
+    def measure_number(self):
+        """ The scalar expression involved in the definition of
+        this VectorMul.
+        """
+        return self._measure_number
+
+
+class VectorZero(BasisDependentZero, Vector):
+    """
+    Class to denote a zero vector
+    """
+
+    _op_priority = 12.1
+    _pretty_form = '0'
+    _latex_form = r'\mathbf{\hat{0}}'
+
+    def __new__(cls):
+        obj = BasisDependentZero.__new__(cls)
+        return obj
+
+
+class Cross(Vector):
+    """
+    Represents unevaluated Cross product.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, Cross
+    >>> R = CoordSys3D('R')
+    >>> v1 = R.i + R.j + R.k
+    >>> v2 = R.x * R.i + R.y * R.j + R.z * R.k
+    >>> Cross(v1, v2)
+    Cross(R.i + R.j + R.k, R.x*R.i + R.y*R.j + R.z*R.k)
+    >>> Cross(v1, v2).doit()
+    (-R.y + R.z)*R.i + (R.x - R.z)*R.j + (-R.x + R.y)*R.k
+
+    """
+
+    def __new__(cls, expr1, expr2):
+        expr1 = sympify(expr1)
+        expr2 = sympify(expr2)
+        if default_sort_key(expr1) > default_sort_key(expr2):
+            return -Cross(expr2, expr1)
+        obj = Expr.__new__(cls, expr1, expr2)
+        obj._expr1 = expr1
+        obj._expr2 = expr2
+        return obj
+
+    def doit(self, **kwargs):
+        return cross(self._expr1, self._expr2)
+
+
+class Dot(Expr):
+    """
+    Represents unevaluated Dot product.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D, Dot
+    >>> from sympy import symbols
+    >>> R = CoordSys3D('R')
+    >>> a, b, c = symbols('a b c')
+    >>> v1 = R.i + R.j + R.k
+    >>> v2 = a * R.i + b * R.j + c * R.k
+    >>> Dot(v1, v2)
+    Dot(R.i + R.j + R.k, a*R.i + b*R.j + c*R.k)
+    >>> Dot(v1, v2).doit()
+    a + b + c
+
+    """
+
+    def __new__(cls, expr1, expr2):
+        expr1 = sympify(expr1)
+        expr2 = sympify(expr2)
+        expr1, expr2 = sorted([expr1, expr2], key=default_sort_key)
+        obj = Expr.__new__(cls, expr1, expr2)
+        obj._expr1 = expr1
+        obj._expr2 = expr2
+        return obj
+
+    def doit(self, **kwargs):
+        return dot(self._expr1, self._expr2)
+
+
+def cross(vect1, vect2):
+    """
+    Returns cross product of two vectors.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D
+    >>> from sympy.vector.vector import cross
+    >>> R = CoordSys3D('R')
+    >>> v1 = R.i + R.j + R.k
+    >>> v2 = R.x * R.i + R.y * R.j + R.z * R.k
+    >>> cross(v1, v2)
+    (-R.y + R.z)*R.i + (R.x - R.z)*R.j + (-R.x + R.y)*R.k
+
+    """
+    if isinstance(vect1, Add):
+        return VectorAdd.fromiter(cross(i, vect2) for i in vect1.args)
+    if isinstance(vect2, Add):
+        return VectorAdd.fromiter(cross(vect1, i) for i in vect2.args)
+    if isinstance(vect1, BaseVector) and isinstance(vect2, BaseVector):
+        if vect1._sys == vect2._sys:
+            n1 = vect1.args[0]
+            n2 = vect2.args[0]
+            if n1 == n2:
+                return Vector.zero
+            n3 = ({0,1,2}.difference({n1, n2})).pop()
+            sign = 1 if ((n1 + 1) % 3 == n2) else -1
+            return sign*vect1._sys.base_vectors()[n3]
+        from .functions import express
+        try:
+            v = express(vect1, vect2._sys)
+        except ValueError:
+            return Cross(vect1, vect2)
+        else:
+            return cross(v, vect2)
+    if isinstance(vect1, VectorZero) or isinstance(vect2, VectorZero):
+        return Vector.zero
+    if isinstance(vect1, VectorMul):
+        v1, m1 = next(iter(vect1.components.items()))
+        return m1*cross(v1, vect2)
+    if isinstance(vect2, VectorMul):
+        v2, m2 = next(iter(vect2.components.items()))
+        return m2*cross(vect1, v2)
+
+    return Cross(vect1, vect2)
+
+
+def dot(vect1, vect2):
+    """
+    Returns dot product of two vectors.
+
+    Examples
+    ========
+
+    >>> from sympy.vector import CoordSys3D
+    >>> from sympy.vector.vector import dot
+    >>> R = CoordSys3D('R')
+    >>> v1 = R.i + R.j + R.k
+    >>> v2 = R.x * R.i + R.y * R.j + R.z * R.k
+    >>> dot(v1, v2)
+    R.x + R.y + R.z
+
+    """
+    if isinstance(vect1, Add):
+        return Add.fromiter(dot(i, vect2) for i in vect1.args)
+    if isinstance(vect2, Add):
+        return Add.fromiter(dot(vect1, i) for i in vect2.args)
+    if isinstance(vect1, BaseVector) and isinstance(vect2, BaseVector):
+        if vect1._sys == vect2._sys:
+            return S.One if vect1 == vect2 else S.Zero
+        from .functions import express
+        try:
+            v = express(vect2, vect1._sys)
+        except ValueError:
+            return Dot(vect1, vect2)
+        else:
+            return dot(vect1, v)
+    if isinstance(vect1, VectorZero) or isinstance(vect2, VectorZero):
+        return S.Zero
+    if isinstance(vect1, VectorMul):
+        v1, m1 = next(iter(vect1.components.items()))
+        return m1*dot(v1, vect2)
+    if isinstance(vect2, VectorMul):
+        v2, m2 = next(iter(vect2.components.items()))
+        return m2*dot(vect1, v2)
+
+    return Dot(vect1, vect2)
+
+
+Vector._expr_type = Vector
+Vector._mul_func = VectorMul
+Vector._add_func = VectorAdd
+Vector._zero_func = VectorZero
+Vector._base_func = BaseVector
+Vector.zero = VectorZero()
diff --git a/sympy_env/lib64 b/sympy_env/lib64
new file mode 120000
index 0000000000..7951405f85
--- /dev/null
+++ b/sympy_env/lib64
@@ -0,0 +1 @@
+lib
\ No newline at end of file
diff --git a/sympy_env/pyvenv.cfg b/sympy_env/pyvenv.cfg
new file mode 100644
index 0000000000..ef219d5716
--- /dev/null
+++ b/sympy_env/pyvenv.cfg
@@ -0,0 +1,3 @@
+home = /opt/miniconda3/envs/testbed/bin
+include-system-site-packages = false
+version = 3.9.19
diff --git a/test_symbol_dict.py b/test_symbol_dict.py
new file mode 100644
index 0000000000..1a5fac89ae
--- /dev/null
+++ b/test_symbol_dict.py
@@ -0,0 +1,7 @@
+import sympy
+
+s = sympy.Symbol('s')
+try:
+    print(s.__dict__)
+except AttributeError as e:
+    print(e)
\ No newline at end of file
--------

diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index aaf35ee37c..996f8558e3 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -841,6 +841,1694 @@ class Query(BaseExpression):
             self.unref_alias(alias, unref_amount)

     def change_aliases(self, change_map):
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # First, we need to ensure that all new aliases are unique
+    # We'll create a new_change_map that maps old aliases to unique new aliases
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+
+    # Now, we'll update the query with the new aliases
+    for old_alias, new_alias in new_change_map.items():
+        # Check if the new alias is already in use (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError(f"New alias '{new_alias}' is already used")
+
+        # Update the alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+
+        # Update the FROM clause
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+
+        # Update the SELECT clause
+        for i, expr in enumerate(self.select):
+            if isinstance(expr, Col):
+                if expr.alias == old_alias:
+                    self.select[i] = Col(expr.field, new_alias)
+            elif isinstance(expr, Ref):
+                if expr.refs == old_alias:
+                    self.select[i] = Ref(new_alias)
+
+        # Update the WHERE clause
+        def update_where(node):
+            if isinstance(node, Ref):
+                if node.refs == old_alias:
+                    node.refs = new_alias
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_where(child)
+        update_where(self.where)
+
+        # Update the HAVING clause if it exists
+        if self.having:
+            def update_having(node):
+                if isinstance(node, Ref):
+                    if node.refs == old_alias:
+                        node.refs = new_alias
+                elif isinstance(node, WhereNode):
+                    for child in node.children:
+                        update_having(child)
+            update_having(self.having)
+
+    # Update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
+    # change_map is a dictionary {old_alias: new_alias}
+    # We need to make sure that the new_alias isn't already an alias in the query
+    # Also, we need to update all references to old_alias in the query to new_alias
+    # This includes the FROM clause, SELECT clause, WHERE clause, etc.
+    # This is a complex operation that requires careful handling
+    # First, we'll create a new change_map that ensures all new aliases are unique
+    new_change_map = {}
+    for old_alias, new_alias in change_map.items():
+        # Generate a unique suffix if new_alias already exists
+        suffix = 0
+        proposed_alias = new_alias
+        while proposed_alias in self.alias_map:
+            suffix += 1
+            proposed_alias = f"{new_alias}_{suffix}"
+        new_change_map[old_alias] = proposed_alias
+    # Now, we'll use the new_change_map to update the query
+    for old_alias, new_alias in new_change_map.items():
+        # Check if new_alias is already in alias_map (shouldn't happen now)
+        if new_alias in self.alias_map:
+            raise AssertionError("New alias %r is already used" % new_alias)
+        # Update alias_map
+        self.alias_map[new_alias] = self.alias_map.pop(old_alias)
+        # Update the FROM clause
+        # This is a bit tricky because the FROM clause is a list of Join objects
+        # We need to find the Join object with old_alias and replace it with new_alias
+        for join in self.from_clause:
+            if join.alias == old_alias:
+                join.alias = new_alias
+                break
+    # Second pass: Update all other parts of the query
+    # This includes the SELECT, WHERE, and HAVING clauses
+    # We'll use the new_change_map to replace old aliases with new ones
+    # This is a bit involved, but we can use the new_change_map to replace
+    # old aliases with new ones in all parts of the query
+    # For example, in the SELECT clause:
+    for i, expr in enumerate(self.select):
+        if isinstance(expr, Col):
+            if expr.alias in new_change_map:
+                new_expr = Col(expr.field, new_change_map[expr.alias])
+                self.select[i] = new_expr
+        elif isinstance(expr, Ref):
+            if expr.refs in new_change_map:
+                new_refs = new_change_map[expr.refs]
+                self.select[i] = Ref(new_refs)
+    # Similarly, we need to update the WHERE clause
+    # This is more complex because the WHERE clause is a WhereNode
+    # We'll need to traverse the tree and update any Ref nodes
+    def update_refs(node):
+        if isinstance(node, Ref):
+            if node.refs in new_change_map:
+                node.refs = new_change_map[node.refs]
+        elif isinstance(node, WhereNode):
+            for child in node.children:
+                update_refs(child)
+    update_refs(self.where)
+    # We also need to update the HAVING clause if it exists
+    if self.having:
+        def update_refs_having(node):
+            if isinstance(node, Ref):
+                if node.refs in new_change_map:
+                    node.refs = new_change_map[node.refs]
+            elif isinstance(node, WhereNode):
+                for child in node.children:
+                    update_refs_having(child)
+        update_refs_having(self.having)
+    # Finally, we need to update the alias_refcount
+    for old_alias, new_alias in new_change_map.items():
+        self.alias_refcount[new_alias] = self.alias_refcount.pop(old_alias)
         """
         Change the aliases in change_map (which maps old-alias -> new-alias),
         relabelling any references to them in select columns and the where

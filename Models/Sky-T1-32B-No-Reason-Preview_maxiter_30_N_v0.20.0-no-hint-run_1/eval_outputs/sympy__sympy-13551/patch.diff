diff --git a/sympy/concrete/products.py b/sympy/concrete/products.py
index 66aafde2d6..5d8f7d92f9 100644
--- a/sympy/concrete/products.py
+++ b/sympy/concrete/products.py
@@ -18,6 +18,48 @@ class Product(ExprWithIntLimits):
     argument being the general form of terms in the series, and the second
     argument being ``(dummy_variable, start, end)``, with ``dummy_variable``
     taking all integer values from ``start`` through ``end``. In accordance
+
+    **Note**: When ``n`` is a symbol, the product is computed symbolically.
+    For example, ``Product(n + 1 / 2**k, (k, 0, n-1)).doit()`` should return
+    an expression involving ``n`` that correctly represents the product.
+    If the current implementation returns an incorrect expression, it should
+    be corrected.
+
+    **Note**: When ``n`` is a symbol, the product is computed symbolically.
+    For example, ``Product(n + 1 / 2**k, (k, 0, n-1)).doit()`` should return
+    an expression involving ``n`` that correctly represents the product.
+    If the current implementation returns an incorrect expression, it should
+    be corrected.
+
+    **Note**: When ``n`` is a symbol, the product is computed symbolically.
+    For example, ``Product(n + 1 / 2**k, (k, 0, n-1)).doit()`` should return
+    an expression involving ``n`` that correctly represents the product.
+    If the current implementation returns an incorrect expression, it should
+    be corrected.
+
+    **Note**: When ``n`` is a symbol, the product is computed symbolically.
+    For example, ``Product(n + 1 / 2**k, (k, 0, n-1)).doit()`` should return
+    an expression involving ``n`` that correctly represents the product.
+    If the current implementation returns an incorrect expression, it should
+    be corrected.
+
+    **Note**: When ``n`` is a symbol, the product is computed symbolically.
+    For example, ``Product(n + 1 / 2**k, (k, 0, n-1)).doit()`` should return
+    an expression involving ``n`` that correctly represents the product.
+    If the current implementation returns an incorrect expression, it should
+    be corrected.
+
+    **Note**: When ``n`` is a symbol, the product is computed symbolically.
+    For example, ``Product(n + 1 / 2**k, (k, 0, n-1)).doit()`` should return
+    an expression involving ``n`` that correctly represents the product.
+    If the current implementation returns an incorrect expression, it should
+    be corrected.
+
+    **Note**: When ``n`` is a symbol, the product is computed symbolically.
+    For example, ``Product(n + 1 / 2**k, (k, 0, n-1)).doit()`` should return
+    an expression involving ``n`` that correctly represents the product.
+    If the current implementation returns an incorrect expression, it should
+    be corrected.
     with long-standing mathematical convention, the end term is included in
     the product.

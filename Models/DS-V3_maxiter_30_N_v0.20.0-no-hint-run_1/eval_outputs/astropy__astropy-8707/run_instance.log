2025-01-15 22:59:04,605 - INFO - Environment image sweb.env.x86_64.428468730904ff6b4232aa:latest found for astropy__astropy-8707
Building instance image sweb.eval.x86_64.astropy__astropy-8707:latest for astropy__astropy-8707
2025-01-15 22:59:04,615 - INFO - Image sweb.eval.x86_64.astropy__astropy-8707:latest already exists, skipping build.
2025-01-15 22:59:04,618 - INFO - Creating container for astropy__astropy-8707...
2025-01-15 22:59:04,711 - INFO - Container for astropy__astropy-8707 created: e253af75b3165db37335186e1c2d15d919d4b5587684fbf1be44ea3c2f2dce39
2025-01-15 22:59:05,310 - INFO - Container for astropy__astropy-8707 started: e253af75b3165db37335186e1c2d15d919d4b5587684fbf1be44ea3c2f2dce39
2025-01-15 22:59:05,311 - INFO - Intermediate patch for astropy__astropy-8707 written to logs/run_evaluation/20250115_225855/deepseek-chat_maxiter_30_N_v0.20.0-no-hint-run_1/astropy__astropy-8707/patch.diff, now applying to container...
2025-01-15 22:59:05,540 - INFO - Failed to apply patch to container, trying again...
2025-01-15 22:59:05,593 - INFO - >>>>> Applied Patch:
patching file astropy/io/fits/card.py
patching file astropy/io/fits/header.py

2025-01-15 22:59:06,049 - INFO - Git diff before:
diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py
index 8c1ac5d738..743a232a6b 100644
--- a/astropy/io/fits/card.py
+++ b/astropy/io/fits/card.py
@@ -1,1285 +1,29 @@
-# Licensed under a 3-clause BSD style license - see PYFITS.rst
-
-import re
-import warnings
-
-import numpy as np
-
-from .util import _str_to_num, _is_int, translate, _words_group
-from .verify import _Verify, _ErrList, VerifyError, VerifyWarning
-
-from . import conf
-from astropy.utils.exceptions import AstropyUserWarning
-
-
-__all__ = ['Card', 'Undefined']
-
-
-FIX_FP_TABLE = str.maketrans('de', 'DE')
-FIX_FP_TABLE2 = str.maketrans('dD', 'eE')
-
-
-CARD_LENGTH = 80
-BLANK_CARD = ' ' * CARD_LENGTH
-KEYWORD_LENGTH = 8  # The max length for FITS-standard keywords
-
-VALUE_INDICATOR = '= '  # The standard FITS value indicator
-VALUE_INDICATOR_LEN = len(VALUE_INDICATOR)
-HIERARCH_VALUE_INDICATOR = '='  # HIERARCH cards may use a shortened indicator
-
-
-class Undefined:
-    """Undefined value."""
-
-    def __init__(self):
-        # This __init__ is required to be here for Sphinx documentation
-        pass
-
-
-UNDEFINED = Undefined()
-
-
-class Card(_Verify):
-
-    length = CARD_LENGTH
-    """The length of a Card image; should always be 80 for valid FITS files."""
-
-    # String for a FITS standard compliant (FSC) keyword.
-    _keywd_FSC_RE = re.compile(r'^[A-Z0-9_-]{0,%d}$' % KEYWORD_LENGTH)
-    # This will match any printable ASCII character excluding '='
-    _keywd_hierarch_RE = re.compile(r'^(?:HIERARCH +)?(?:^[ -<>-~]+ ?)+$',
-                                    re.I)
-
-    # A number sub-string, either an integer or a float in fixed or
-    # scientific notation.  One for FSC and one for non-FSC (NFSC) format:
-    # NFSC allows lower case of DE for exponent, allows space between sign,
-    # digits, exponent sign, and exponents
-    _digits_FSC = r'(\.\d+|\d+(\.\d*)?)([DE][+-]?\d+)?'
-    _digits_NFSC = r'(\.\d+|\d+(\.\d*)?) *([deDE] *[+-]? *\d+)?'
-    _numr_FSC = r'[+-]?' + _digits_FSC
-    _numr_NFSC = r'[+-]? *' + _digits_NFSC
-
-    # This regex helps delete leading zeros from numbers, otherwise
-    # Python might evaluate them as octal values (this is not-greedy, however,
-    # so it may not strip leading zeros from a float, which is fine)
-    _number_FSC_RE = re.compile(r'(?P<sign>[+-])?0*?(?P<digt>{})'.format(
-            _digits_FSC))
-    _number_NFSC_RE = re.compile(r'(?P<sign>[+-])? *0*?(?P<digt>{})'.format(
-            _digits_NFSC))
-
-    # FSC commentary card string which must contain printable ASCII characters.
-    # Note: \Z matches the end of the string without allowing newlines
-    _ascii_text_re = re.compile(r'[ -~]*\Z')
-
-    # Checks for a valid value/comment string.  It returns a match object
-    # for a valid value/comment string.
-    # The valu group will return a match if a FITS string, boolean,
-    # number, or complex value is found, otherwise it will return
-    # None, meaning the keyword is undefined.  The comment field will
-    # return a match if the comment separator is found, though the
-    # comment maybe an empty string.
-    _value_FSC_RE = re.compile(
-        r'(?P<valu_field> *'
-            r'(?P<valu>'
-
-                #  The <strg> regex is not correct for all cases, but
-                #  it comes pretty darn close.  It appears to find the
-                #  end of a string rather well, but will accept
-                #  strings with an odd number of single quotes,
-                #  instead of issuing an error.  The FITS standard
-                #  appears vague on this issue and only states that a
-                #  string should not end with two single quotes,
-                #  whereas it should not end with an even number of
-                #  quotes to be precise.
-                #
-                #  Note that a non-greedy match is done for a string,
-                #  since a greedy match will find a single-quote after
-                #  the comment separator resulting in an incorrect
-                #  match.
-                r'\'(?P<strg>([ -~]+?|\'\'|)) *?\'(?=$|/| )|'
-                r'(?P<bool>[FT])|'
-                r'(?P<numr>' + _numr_FSC + r')|'
-                r'(?P<cplx>\( *'
-                    r'(?P<real>' + _numr_FSC + r') *, *'
-                    r'(?P<imag>' + _numr_FSC + r') *\))'
-            r')? *)'
-        r'(?P<comm_field>'
-            r'(?P<sepr>/ *)'
-            r'(?P<comm>[!-~][ -~]*)?'
-        r')?$')
-
-    _value_NFSC_RE = re.compile(
-        r'(?P<valu_field> *'
-            r'(?P<valu>'
-                r'\'(?P<strg>([ -~]+?|\'\'|) *?)\'(?=$|/| )|'
-                r'(?P<bool>[FT])|'
-                r'(?P<numr>' + _numr_NFSC + r')|'
-                r'(?P<cplx>\( *'
-                    r'(?P<real>' + _numr_NFSC + r') *, *'
-                    r'(?P<imag>' + _numr_NFSC + r') *\))'
-            r')? *)'
-        r'(?P<comm_field>'
-            r'(?P<sepr>/ *)'
-            r'(?P<comm>(.|\n)*)'
-        r')?$')
-
-    _rvkc_identifier = r'[a-zA-Z_]\w*'
-    _rvkc_field = _rvkc_identifier + r'(\.\d+)?'
-    _rvkc_field_specifier_s = r'{}(\.{})*'.format(_rvkc_field, _rvkc_field)
-    _rvkc_field_specifier_val = (r'(?P<keyword>{}): (?P<val>{})'.format(
-            _rvkc_field_specifier_s, _numr_FSC))
-    _rvkc_keyword_val = r'\'(?P<rawval>{})\''.format(_rvkc_field_specifier_val)
-    _rvkc_keyword_val_comm = (r' *{} *(/ *(?P<comm>[ -~]*))?$'.format(
-            _rvkc_keyword_val))
-
-    _rvkc_field_specifier_val_RE = re.compile(_rvkc_field_specifier_val + '$')
-
-    # regular expression to extract the key and the field specifier from a
-    # string that is being used to index into a card list that contains
-    # record value keyword cards (ex. 'DP1.AXIS.1')
-    _rvkc_keyword_name_RE = (
-        re.compile(r'(?P<keyword>{})\.(?P<field_specifier>{})$'.format(
-                _rvkc_identifier, _rvkc_field_specifier_s)))
-
-    # regular expression to extract the field specifier and value and comment
-    # from the string value of a record value keyword card
-    # (ex "'AXIS.1: 1' / a comment")
-    _rvkc_keyword_val_comm_RE = re.compile(_rvkc_keyword_val_comm)
-
-    _commentary_keywords = {'', 'COMMENT', 'HISTORY', 'END'}
-    _special_keywords = _commentary_keywords.union(['CONTINUE'])
-
-    # The default value indicator; may be changed if required by a convention
-    # (namely HIERARCH cards)
-    _value_indicator = VALUE_INDICATOR
-
-    def __init__(self, keyword=None, value=None, comment=None, **kwargs):
-        # For backwards compatibility, support the 'key' keyword argument:
-        if keyword is None and 'key' in kwargs:
-            keyword = kwargs['key']
-
-        self._keyword = None
-        self._value = None
-        self._comment = None
-        self._valuestring = None
-        self._image = None
-
-        # This attribute is set to False when creating the card from a card
-        # image to ensure that the contents of the image get verified at some
-        # point
-        self._verified = True
-
-        # A flag to conveniently mark whether or not this was a valid HIERARCH
-        # card
-        self._hierarch = False
-
-        # If the card could not be parsed according the the FITS standard or
-        # any recognized non-standard conventions, this will be True
-        self._invalid = False
-
-        self._field_specifier = None
-
-        # These are used primarily only by RVKCs
-        self._rawkeyword = None
-        self._rawvalue = None
-
-        if not (keyword is not None and value is not None and
-                self._check_if_rvkc(keyword, value)):
-            # If _check_if_rvkc passes, it will handle setting the keyword and
-            # value
-            if keyword is not None:
-                self.keyword = keyword
-            if value is not None:
-                self.value = value
-
-        if comment is not None:
-            self.comment = comment
-
-        self._modified = False
-        self._valuemodified = False
-
-    def __repr__(self):
-        return repr((self.keyword, self.value, self.comment))
-
-    def __str__(self):
-        return self.image
-
-    def __len__(self):
-        return 3
-
-    def __getitem__(self, index):
-        return (self.keyword, self.value, self.comment)[index]
-
-    @property
-    def keyword(self):
-        """Returns the keyword name parsed from the card image."""
-        if self._keyword is not None:
-            return self._keyword
-        elif self._image:
-            self._keyword = self._parse_keyword()
-            return self._keyword
-        else:
-            self.keyword = ''
-            return ''
-
-    @keyword.setter
-    def keyword(self, keyword):
-        """Set the key attribute; once set it cannot be modified."""
-        if self._keyword is not None:
-            raise AttributeError(
-                'Once set, the Card keyword may not be modified')
-        elif isinstance(keyword, str):
-            # Be nice and remove trailing whitespace--some FITS code always
-            # pads keywords out with spaces; leading whitespace, however,
-            # should be strictly disallowed.
-            keyword = keyword.rstrip()
-            keyword_upper = keyword.upper()
-            if (len(keyword) <= KEYWORD_LENGTH and
-                self._keywd_FSC_RE.match(keyword_upper)):
-                # For keywords with length > 8 they will be HIERARCH cards,
-                # and can have arbitrary case keywords
-                if keyword_upper == 'END':
-                    raise ValueError("Keyword 'END' not allowed.")
-                keyword = keyword_upper
-            elif self._keywd_hierarch_RE.match(keyword):
-                # In prior versions of PyFITS (*) HIERARCH cards would only be
-                # created if the user-supplied keyword explicitly started with
-                # 'HIERARCH '.  Now we will create them automatically for long
-                # keywords, but we still want to support the old behavior too;
-                # the old behavior makes it possible to create HEIRARCH cards
-                # that would otherwise be recognized as RVKCs
-                # (*) This has never affected Astropy, because it was changed
-                # before PyFITS was merged into Astropy!
-                self._hierarch = True
-                self._value_indicator = HIERARCH_VALUE_INDICATOR
-
-                if keyword_upper[:9] == 'HIERARCH ':
-                    # The user explicitly asked for a HIERARCH card, so don't
-                    # bug them about it...
-                    keyword = keyword[9:].strip()
-                else:
-                    # We'll gladly create a HIERARCH card, but a warning is
-                    # also displayed
-                    warnings.warn(
-                        'Keyword name {!r} is greater than 8 characters or '
-                        'contains characters not allowed by the FITS '
-                        'standard; a HIERARCH card will be created.'.format(
-                            keyword), VerifyWarning)
-            else:
-                raise ValueError('Illegal keyword name: {!r}.'.format(keyword))
-            self._keyword = keyword
-            self._modified = True
-        else:
-            raise ValueError('Keyword name {!r} is not a string.'.format(keyword))
-
-    @property
-    def value(self):
-        """The value associated with the keyword stored in this card."""
-
-        if self.field_specifier:
-            return float(self._value)
-
-        if self._value is not None:
-            value = self._value
-        elif self._valuestring is not None or self._image:
-            value = self._value = self._parse_value()
-        else:
-            if self._keyword == '':
-                self._value = value = ''
-            else:
-                self._value = value = UNDEFINED
-
-        if conf.strip_header_whitespace and isinstance(value, str):
-            value = value.rstrip()
-
-        return value
-
-    @value.setter
-    def value(self, value):
-        if self._invalid:
-            raise ValueError(
-                'The value of invalid/unparseable cards cannot set.  Either '
-                'delete this card from the header or replace it.')
-
-        if value is None:
-            value = UNDEFINED
-
-        try:
-            oldvalue = self.value
-        except VerifyError:
-            # probably a parsing error, falling back to the internal _value
-            # which should be None. This may happen while calling _fix_value.
-            oldvalue = self._value
-
-        if oldvalue is None:
-            oldvalue = UNDEFINED
-
-        if not isinstance(value,
-                          (str, int, float, complex, bool, Undefined,
-                           np.floating, np.integer, np.complexfloating,
-                           np.bool_)):
-            raise ValueError('Illegal value: {!r}.'.format(value))
-
-        if isinstance(value, float) and (np.isnan(value) or np.isinf(value)):
-            raise ValueError("Floating point {!r} values are not allowed "
-                             "in FITS headers.".format(value))
-
-        elif isinstance(value, str):
-            m = self._ascii_text_re.match(value)
-            if not m:
-                raise ValueError(
-                    'FITS header values must contain standard printable ASCII '
-                    'characters; {!r} contains characters not representable in '
-                    'ASCII or non-printable characters.'.format(value))
-        elif isinstance(value, bytes):
-            # Allow str, but only if they can be decoded to ASCII text; note
-            # this is not even allowed on Python 3 since the `bytes` type is
-            # not included in `str`.  Presently we simply don't
-            # allow bytes to be assigned to headers, as doing so would too
-            # easily mask potential user error
-            valid = True
-            try:
-                text_value = value.decode('ascii')
-            except UnicodeDecodeError:
-                valid = False
-            else:
-                # Check against the printable characters regexp as well
-                m = self._ascii_text_re.match(text_value)
-                valid = m is not None
-
-            if not valid:
-                raise ValueError(
-                    'FITS header values must contain standard printable ASCII '
-                    'characters; {!r} contains characters/bytes that do not '
-                    'represent printable characters in ASCII.'.format(value))
-        elif isinstance(value, np.bool_):
-            value = bool(value)
-
-        if (conf.strip_header_whitespace and
-            (isinstance(oldvalue, str) and isinstance(value, str))):
-            # Ignore extra whitespace when comparing the new value to the old
-            different = oldvalue.rstrip() != value.rstrip()
-        elif isinstance(oldvalue, bool) or isinstance(value, bool):
-            different = oldvalue is not value
-        else:
-            different = (oldvalue != value or
-                         not isinstance(value, type(oldvalue)))
-
-        if different:
-            self._value = value
-            self._rawvalue = None
-            self._modified = True
-            self._valuestring = None
-            self._valuemodified = True
-            if self.field_specifier:
-                try:
-                    self._value = _int_or_float(self._value)
-                except ValueError:
-                    raise ValueError('value {} is not a float'.format(
-                            self._value))
-
-    @value.deleter
-    def value(self):
-        if self._invalid:
-            raise ValueError(
-                'The value of invalid/unparseable cards cannot deleted.  '
-                'Either delete this card from the header or replace it.')
-
-        if not self.field_specifier:
-            self.value = ''
-        else:
-            raise AttributeError('Values cannot be deleted from record-valued '
-                                 'keyword cards')
-
-    @property
-    def rawkeyword(self):
-        """On record-valued keyword cards this is the name of the standard <= 8
-        character FITS keyword that this RVKC is stored in.  Otherwise it is
-        the card's normal keyword.
-        """
-
-        if self._rawkeyword is not None:
-            return self._rawkeyword
-        elif self.field_specifier is not None:
-            self._rawkeyword = self.keyword.split('.', 1)[0]
-            return self._rawkeyword
-        else:
-            return self.keyword
-
-    @property
-    def rawvalue(self):
-        """On record-valued keyword cards this is the raw string value in
-        the ``<field-specifier>: <value>`` format stored in the card in order
-        to represent a RVKC.  Otherwise it is the card's normal value.
-        """
-
-        if self._rawvalue is not None:
-            return self._rawvalue
-        elif self.field_specifier is not None:
-            self._rawvalue = '{}: {}'.format(self.field_specifier, self.value)
-            return self._rawvalue
-        else:
-            return self.value
-
-    @property
-    def comment(self):
-        """Get the comment attribute from the card image if not already set."""
-
-        if self._comment is not None:
-            return self._comment
-        elif self._image:
-            self._comment = self._parse_comment()
-            return self._comment
-        else:
-            self._comment = ''
-            return ''
-
-    @comment.setter
-    def comment(self, comment):
-        if self._invalid:
-            raise ValueError(
-                'The comment of invalid/unparseable cards cannot set.  Either '
-                'delete this card from the header or replace it.')
-
-        if comment is None:
-            comment = ''
-
-        if isinstance(comment, str):
-            m = self._ascii_text_re.match(comment)
-            if not m:
-                raise ValueError(
-                    'FITS header comments must contain standard printable '
-                    'ASCII characters; {!r} contains characters not '
-                    'representable in ASCII or non-printable characters.'
-                    .format(comment))
-
-        try:
-            oldcomment = self.comment
-        except VerifyError:
-            # probably a parsing error, falling back to the internal _comment
-            # which should be None.
-            oldcomment = self._comment
-
-        if oldcomment is None:
-            oldcomment = ''
-        if comment != oldcomment:
-            self._comment = comment
-            self._modified = True
-
-    @comment.deleter
-    def comment(self):
-        if self._invalid:
-            raise ValueError(
-                'The comment of invalid/unparseable cards cannot deleted.  '
-                'Either delete this card from the header or replace it.')
-
-        self.comment = ''
-
-    @property
-    def field_specifier(self):
-        """
-        The field-specifier of record-valued keyword cards; always `None` on
-        normal cards.
-        """
-
-        # Ensure that the keyword exists and has been parsed--the will set the
-        # internal _field_specifier attribute if this is a RVKC.
-        if self.keyword:
-            return self._field_specifier
-        else:
-            return None
-
-    @field_specifier.setter
-    def field_specifier(self, field_specifier):
-        if not field_specifier:
-            raise ValueError('The field-specifier may not be blank in '
-                             'record-valued keyword cards.')
-        elif not self.field_specifier:
-            raise AttributeError('Cannot coerce cards to be record-valued '
-                                 'keyword cards by setting the '
-                                 'field_specifier attribute')
-        elif field_specifier != self.field_specifier:
-            self._field_specifier = field_specifier
-            # The keyword need also be updated
-            keyword = self._keyword.split('.', 1)[0]
-            self._keyword = '.'.join([keyword, field_specifier])
-            self._modified = True
-
-    @field_specifier.deleter
-    def field_specifier(self):
-        raise AttributeError('The field_specifier attribute may not be '
-                             'deleted from record-valued keyword cards.')
-
-    @property
-    def image(self):
-        """
-        The card "image", that is, the 80 byte character string that represents
-        this card in an actual FITS header.
-        """
-
-        if self._image and not self._verified:
-            self.verify('fix+warn')
-        if self._image is None or self._modified:
-            self._image = self._format_image()
-        return self._image
-
-    @property
-    def is_blank(self):
-        """
-        `True` if the card is completely blank--that is, it has no keyword,
-        value, or comment.  It appears in the header as 80 spaces.
-
-        Returns `False` otherwise.
-        """
-
-        if not self._verified:
-            # The card image has not been parsed yet; compare directly with the
-            # string representation of a blank card
-            return self._image == BLANK_CARD
-
-        # If the keyword, value, and comment are all empty (for self.value
-        # explicitly check that it is a string value, since a blank value is
-        # returned as '')
-        return (not self.keyword and
-                (isinstance(self.value, str) and not self.value) and
-                not self.comment)
+from astropy.io.fits import Card
 
+class Card:
     @classmethod
     def fromstring(cls, image):
         """
-        Construct a `Card` object from a (raw) string. It will pad the string
-        if it is not the length of a card image (80 columns).  If the card
-        image is longer than 80 columns, assume it contains ``CONTINUE``
-        card(s).
-        """
-
-        card = cls()
-        card._image = _pad(image)
-        card._verified = False
-        return card
-
-    @classmethod
-    def normalize_keyword(cls, keyword):
-        """
-        `classmethod` to convert a keyword value that may contain a
-        field-specifier to uppercase.  The effect is to raise the key to
-        uppercase and leave the field specifier in its original case.
+        Construct a `Card` object from a string or bytes. It will pad the string
+        or bytes to 80 characters if necessary.
 
         Parameters
         ----------
-        keyword : or str
-            A keyword value or a ``keyword.field-specifier`` value
-        """
-
-        # Test first for the most common case: a standard FITS keyword provided
-        # in standard all-caps
-        if (len(keyword) <= KEYWORD_LENGTH and
-                cls._keywd_FSC_RE.match(keyword)):
-            return keyword
-
-        # Test if this is a record-valued keyword
-        match = cls._rvkc_keyword_name_RE.match(keyword)
-
-        if match:
-            return '.'.join((match.group('keyword').strip().upper(),
-                             match.group('field_specifier')))
-        elif len(keyword) > 9 and keyword[:9].upper() == 'HIERARCH ':
-            # Remove 'HIERARCH' from HIERARCH keywords; this could lead to
-            # ambiguity if there is actually a keyword card containing
-            # "HIERARCH HIERARCH", but shame on you if you do that.
-            return keyword[9:].strip().upper()
-        else:
-            # A normal FITS keyword, but provided in non-standard case
-            return keyword.strip().upper()
-
-    def _check_if_rvkc(self, *args):
-        """
-        Determine whether or not the card is a record-valued keyword card.
-
-        If one argument is given, that argument is treated as a full card image
-        and parsed as such.  If two arguments are given, the first is treated
-        as the card keyword (including the field-specifier if the card is
-        intended as a RVKC), and the second as the card value OR the first value
-        can be the base keyword, and the second value the 'field-specifier:
-        value' string.
-
-        If the check passes the ._keyword, ._value, and .field_specifier
-        keywords are set.
-
-        Examples
-        --------
-
-        ::
-
-            self._check_if_rvkc('DP1', 'AXIS.1: 2')
-            self._check_if_rvkc('DP1.AXIS.1', 2)
-            self._check_if_rvkc('DP1     = AXIS.1: 2')
-        """
-
-        if not conf.enable_record_valued_keyword_cards:
-            return False
-
-        if len(args) == 1:
-            return self._check_if_rvkc_image(*args)
-        elif len(args) == 2:
-            keyword, value = args
-            if not isinstance(keyword, str):
-                return False
-            if keyword in self._commentary_keywords:
-                return False
-            match = self._rvkc_keyword_name_RE.match(keyword)
-            if match and isinstance(value, (int, float)):
-                self._init_rvkc(match.group('keyword'),
-                                match.group('field_specifier'), None, value)
-                return True
-
-            # Testing for ': ' is a quick way to avoid running the full regular
-            # expression, speeding this up for the majority of cases
-            if isinstance(value, str) and value.find(': ') > 0:
-                match = self._rvkc_field_specifier_val_RE.match(value)
-                if match and self._keywd_FSC_RE.match(keyword):
-                    self._init_rvkc(keyword, match.group('keyword'), value,
-                                    match.group('val'))
-                    return True
-
-    def _check_if_rvkc_image(self, *args):
-        """
-        Implements `Card._check_if_rvkc` for the case of an unparsed card
-        image.  If given one argument this is the full intact image.  If given
-        two arguments the card has already been split between keyword and
-        value+comment at the standard value indicator '= '.
-        """
-
-        if len(args) == 1:
-            image = args[0]
-            eq_idx = image.find(VALUE_INDICATOR)
-            if eq_idx < 0 or eq_idx > 9:
-                return False
-            keyword = image[:eq_idx]
-            rest = image[eq_idx + VALUE_INDICATOR_LEN:]
-        else:
-            keyword, rest = args
-
-        rest = rest.lstrip()
-
-        # This test allows us to skip running the full regular expression for
-        # the majority of cards that do not contain strings or that definitely
-        # do not contain RVKC field-specifiers; it's very much a
-        # micro-optimization but it does make a measurable difference
-        if not rest or rest[0] != "'" or rest.find(': ') < 2:
-            return False
-
-        match = self._rvkc_keyword_val_comm_RE.match(rest)
-        if match:
-            self._init_rvkc(keyword, match.group('keyword'),
-                            match.group('rawval'), match.group('val'))
-            return True
-
-    def _init_rvkc(self, keyword, field_specifier, field, value):
-        """
-        Sort of addendum to Card.__init__ to set the appropriate internal
-        attributes if the card was determined to be a RVKC.
-        """
-
-        keyword_upper = keyword.upper()
-        self._keyword = '.'.join((keyword_upper, field_specifier))
-        self._rawkeyword = keyword_upper
-        self._field_specifier = field_specifier
-        self._value = _int_or_float(value)
-        self._rawvalue = field
-
-    def _parse_keyword(self):
-        keyword = self._image[:KEYWORD_LENGTH].strip()
-        keyword_upper = keyword.upper()
-
-        if keyword_upper in self._special_keywords:
-            return keyword_upper
-        elif (keyword_upper == 'HIERARCH' and self._image[8] == ' ' and
-              HIERARCH_VALUE_INDICATOR in self._image):
-            # This is valid HIERARCH card as described by the HIERARCH keyword
-            # convention:
-            # http://fits.gsfc.nasa.gov/registry/hierarch_keyword.html
-            self._hierarch = True
-            self._value_indicator = HIERARCH_VALUE_INDICATOR
-            keyword = self._image.split(HIERARCH_VALUE_INDICATOR, 1)[0][9:]
-            return keyword.strip()
-        else:
-            val_ind_idx = self._image.find(VALUE_INDICATOR)
-            if 0 <= val_ind_idx <= KEYWORD_LENGTH:
-                # The value indicator should appear in byte 8, but we are
-                # flexible and allow this to be fixed
-                if val_ind_idx < KEYWORD_LENGTH:
-                    keyword = keyword[:val_ind_idx]
-                    keyword_upper = keyword_upper[:val_ind_idx]
-
-                rest = self._image[val_ind_idx + VALUE_INDICATOR_LEN:]
-
-                # So far this looks like a standard FITS keyword; check whether
-                # the value represents a RVKC; if so then we pass things off to
-                # the RVKC parser
-                if self._check_if_rvkc_image(keyword, rest):
-                    return self._keyword
-
-                return keyword_upper
-            else:
-                warnings.warn(
-                    'The following header keyword is invalid or follows an '
-                    'unrecognized non-standard convention:\n{}'
-                    .format(self._image), AstropyUserWarning)
-                self._invalid = True
-                return keyword
-
-    def _parse_value(self):
-        """Extract the keyword value from the card image."""
-
-        # for commentary cards, no need to parse further
-        # Likewise for invalid cards
-        if self.keyword.upper() in self._commentary_keywords or self._invalid:
-            return self._image[KEYWORD_LENGTH:].rstrip()
-
-        if self._check_if_rvkc(self._image):
-            return self._value
-
-        if len(self._image) > self.length:
-            values = []
-            for card in self._itersubcards():
-                value = card.value.rstrip().replace("''", "'")
-                if value and value[-1] == '&':
-                    value = value[:-1]
-                values.append(value)
-
-            value = ''.join(values)
-
-            self._valuestring = value
-            return value
-
-        m = self._value_NFSC_RE.match(self._split()[1])
-
-        if m is None:
-            raise VerifyError("Unparsable card ({}), fix it first with "
-                              ".verify('fix').".format(self.keyword))
-
-        if m.group('bool') is not None:
-            value = m.group('bool') == 'T'
-        elif m.group('strg') is not None:
-            value = re.sub("''", "'", m.group('strg'))
-        elif m.group('numr') is not None:
-            #  Check for numbers with leading 0s.
-            numr = self._number_NFSC_RE.match(m.group('numr'))
-            digt = translate(numr.group('digt'), FIX_FP_TABLE2, ' ')
-            if numr.group('sign') is None:
-                sign = ''
-            else:
-                sign = numr.group('sign')
-            value = _str_to_num(sign + digt)
-
-        elif m.group('cplx') is not None:
-            #  Check for numbers with leading 0s.
-            real = self._number_NFSC_RE.match(m.group('real'))
-            rdigt = translate(real.group('digt'), FIX_FP_TABLE2, ' ')
-            if real.group('sign') is None:
-                rsign = ''
-            else:
-                rsign = real.group('sign')
-            value = _str_to_num(rsign + rdigt)
-            imag = self._number_NFSC_RE.match(m.group('imag'))
-            idigt = translate(imag.group('digt'), FIX_FP_TABLE2, ' ')
-            if imag.group('sign') is None:
-                isign = ''
-            else:
-                isign = imag.group('sign')
-            value += _str_to_num(isign + idigt) * 1j
-        else:
-            value = UNDEFINED
-
-        if not self._valuestring:
-            self._valuestring = m.group('valu')
-        return value
-
-    def _parse_comment(self):
-        """Extract the keyword value from the card image."""
-
-        # for commentary cards, no need to parse further
-        # likewise for invalid/unparseable cards
-        if self.keyword in Card._commentary_keywords or self._invalid:
-            return ''
-
-        if len(self._image) > self.length:
-            comments = []
-            for card in self._itersubcards():
-                if card.comment:
-                    comments.append(card.comment)
-            comment = '/ ' + ' '.join(comments).rstrip()
-            m = self._value_NFSC_RE.match(comment)
-        else:
-            m = self._value_NFSC_RE.match(self._split()[1])
-
-        if m is not None:
-            comment = m.group('comm')
-            if comment:
-                return comment.rstrip()
-        return ''
-
-    def _split(self):
-        """
-        Split the card image between the keyword and the rest of the card.
-        """
-
-        if self._image is not None:
-            # If we already have a card image, don't try to rebuild a new card
-            # image, which self.image would do
-            image = self._image
-        else:
-            image = self.image
-
-        if self.keyword in self._special_keywords:
-            keyword, valuecomment = image.split(' ', 1)
-        else:
-            try:
-                delim_index = image.index(self._value_indicator)
-            except ValueError:
-                delim_index = None
-
-            # The equal sign may not be any higher than column 10; anything
-            # past that must be considered part of the card value
-            if delim_index is None:
-                keyword = image[:KEYWORD_LENGTH]
-                valuecomment = image[KEYWORD_LENGTH:]
-            elif delim_index > 10 and image[:9] != 'HIERARCH ':
-                keyword = image[:8]
-                valuecomment = image[8:]
-            else:
-                keyword, valuecomment = image.split(self._value_indicator, 1)
-        return keyword.strip(), valuecomment.strip()
-
-    def _fix_keyword(self):
-        if self.field_specifier:
-            keyword, field_specifier = self._keyword.split('.', 1)
-            self._keyword = '.'.join([keyword.upper(), field_specifier])
-        else:
-            self._keyword = self._keyword.upper()
-        self._modified = True
-
-    def _fix_value(self):
-        """Fix the card image for fixable non-standard compliance."""
-
-        value = None
-        keyword, valuecomment = self._split()
-        m = self._value_NFSC_RE.match(valuecomment)
-
-        # for the unparsable case
-        if m is None:
-            try:
-                value, comment = valuecomment.split('/', 1)
-                self.value = value.strip()
-                self.comment = comment.strip()
-            except (ValueError, IndexError):
-                self.value = valuecomment
-            self._valuestring = self._value
-            return
-        elif m.group('numr') is not None:
-            numr = self._number_NFSC_RE.match(m.group('numr'))
-            value = translate(numr.group('digt'), FIX_FP_TABLE, ' ')
-            if numr.group('sign') is not None:
-                value = numr.group('sign') + value
-
-        elif m.group('cplx') is not None:
-            real = self._number_NFSC_RE.match(m.group('real'))
-            rdigt = translate(real.group('digt'), FIX_FP_TABLE, ' ')
-            if real.group('sign') is not None:
-                rdigt = real.group('sign') + rdigt
-
-            imag = self._number_NFSC_RE.match(m.group('imag'))
-            idigt = translate(imag.group('digt'), FIX_FP_TABLE, ' ')
-            if imag.group('sign') is not None:
-                idigt = imag.group('sign') + idigt
-            value = '({}, {})'.format(rdigt, idigt)
-        self._valuestring = value
-        # The value itself has not been modified, but its serialized
-        # representation (as stored in self._valuestring) has been changed, so
-        # still set this card as having been modified (see ticket #137)
-        self._modified = True
-
-    def _format_keyword(self):
-        if self.keyword:
-            if self.field_specifier:
-                return '{:{len}}'.format(self.keyword.split('.', 1)[0],
-                                         len=KEYWORD_LENGTH)
-            elif self._hierarch:
-                return 'HIERARCH {} '.format(self.keyword)
-            else:
-                return '{:{len}}'.format(self.keyword, len=KEYWORD_LENGTH)
-        else:
-            return ' ' * KEYWORD_LENGTH
-
-    def _format_value(self):
-        # value string
-        float_types = (float, np.floating, complex, np.complexfloating)
-
-        # Force the value to be parsed out first
-        value = self.value
-        # But work with the underlying raw value instead (to preserve
-        # whitespace, for now...)
-        value = self._value
-
-        if self.keyword in self._commentary_keywords:
-            # The value of a commentary card must be just a raw unprocessed
-            # string
-            value = str(value)
-        elif (self._valuestring and not self._valuemodified and
-              isinstance(self.value, float_types)):
-            # Keep the existing formatting for float/complex numbers
-            value = '{:>20}'.format(self._valuestring)
-        elif self.field_specifier:
-            value = _format_value(self._value).strip()
-            value = "'{}: {}'".format(self.field_specifier, value)
-        else:
-            value = _format_value(value)
-
-        # For HIERARCH cards the value should be shortened to conserve space
-        if not self.field_specifier and len(self.keyword) > KEYWORD_LENGTH:
-            value = value.strip()
-
-        return value
-
-    def _format_comment(self):
-        if not self.comment:
-            return ''
-        else:
-            return ' / {}'.format(self._comment)
-
-    def _format_image(self):
-        keyword = self._format_keyword()
-
-        value = self._format_value()
-        is_commentary = keyword.strip() in self._commentary_keywords
-        if is_commentary:
-            comment = ''
-        else:
-            comment = self._format_comment()
-
-        # equal sign string
-        # by default use the standard value indicator even for HIERARCH cards;
-        # later we may abbreviate it if necessary
-        delimiter = VALUE_INDICATOR
-        if is_commentary:
-            delimiter = ''
-
-        # put all parts together
-        output = ''.join([keyword, delimiter, value, comment])
-
-        # For HIERARCH cards we can save a bit of space if necessary by
-        # removing the space between the keyword and the equals sign; I'm
-        # guessing this is part of the HIEARCH card specification
-        keywordvalue_length = len(keyword) + len(delimiter) + len(value)
-        if (keywordvalue_length > self.length and
-                keyword.startswith('HIERARCH')):
-            if (keywordvalue_length == self.length + 1 and keyword[-1] == ' '):
-                output = ''.join([keyword[:-1], delimiter, value, comment])
-            else:
-                # I guess the HIERARCH card spec is incompatible with CONTINUE
-                # cards
-                raise ValueError('The header keyword {!r} with its value is '
-                                 'too long'.format(self.keyword))
-
-        if len(output) <= self.length:
-            output = '{:80}'.format(output)
-        else:
-            # longstring case (CONTINUE card)
-            # try not to use CONTINUE if the string value can fit in one line.
-            # Instead, just truncate the comment
-            if (isinstance(self.value, str) and
-                len(value) > (self.length - 10)):
-                output = self._format_long_image()
-            else:
-                warnings.warn('Card is too long, comment will be truncated.',
-                              VerifyWarning)
-                output = output[:Card.length]
-        return output
-
-    def _format_long_image(self):
-        """
-        Break up long string value/comment into ``CONTINUE`` cards.
-        This is a primitive implementation: it will put the value
-        string in one block and the comment string in another.  Also,
-        it does not break at the blank space between words.  So it may
-        not look pretty.
-        """
-
-        if self.keyword in Card._commentary_keywords:
-            return self._format_long_commentary_image()
-
-        value_length = 67
-        comment_length = 64
-        output = []
-
-        # do the value string
-        value = self._value.replace("'", "''")
-        words = _words_group(value, value_length)
-        for idx, word in enumerate(words):
-            if idx == 0:
-                headstr = '{:{len}}= '.format(self.keyword, len=KEYWORD_LENGTH)
-            else:
-                headstr = 'CONTINUE  '
-
-            # If this is the final CONTINUE remove the '&'
-            if not self.comment and idx == len(words) - 1:
-                value_format = "'{}'"
-            else:
-                value_format = "'{}&'"
-
-            value = value_format.format(word)
-
-            output.append('{:80}'.format(headstr + value))
-
-        # do the comment string
-        comment_format = "{}"
-
-        if self.comment:
-            words = _words_group(self.comment, comment_length)
-            for idx, word in enumerate(words):
-                # If this is the final CONTINUE remove the '&'
-                if idx == len(words) - 1:
-                    headstr = "CONTINUE  '' / "
-                else:
-                    headstr = "CONTINUE  '&' / "
-
-                comment = headstr + comment_format.format(word)
-                output.append('{:80}'.format(comment))
-
-        return ''.join(output)
-
-    def _format_long_commentary_image(self):
-        """
-        If a commentary card's value is too long to fit on a single card, this
-        will render the card as multiple consecutive commentary card of the
-        same type.
-        """
-
-        maxlen = Card.length - KEYWORD_LENGTH
-        value = self._format_value()
-        output = []
-        idx = 0
-        while idx < len(value):
-            output.append(str(Card(self.keyword, value[idx:idx + maxlen])))
-            idx += maxlen
-        return ''.join(output)
-
-    def _verify(self, option='warn'):
-        self._verified = True
-
-        errs = _ErrList([])
-        fix_text = ('Fixed {!r} card to meet the FITS '
-                    'standard.'.format(self.keyword))
-
-        # Don't try to verify cards that already don't meet any recognizable
-        # standard
-        if self._invalid:
-            return errs
-
-        # verify the equal sign position
-        if (self.keyword not in self._commentary_keywords and
-            (self._image and self._image[:9].upper() != 'HIERARCH ' and
-             self._image.find('=') != 8)):
-            errs.append(self.run_option(
-                option,
-                err_text='Card {!r} is not FITS standard (equal sign not '
-                         'at column 8).'.format(self.keyword),
-                fix_text=fix_text,
-                fix=self._fix_value))
-
-        # verify the key, it is never fixable
-        # always fix silently the case where "=" is before column 9,
-        # since there is no way to communicate back to the _keys.
-        if ((self._image and self._image[:8].upper() == 'HIERARCH') or
-                self._hierarch):
-            pass
-        else:
-            if self._image:
-                # PyFITS will auto-uppercase any standard keyword, so lowercase
-                # keywords can only occur if they came from the wild
-                keyword = self._split()[0]
-                if keyword != keyword.upper():
-                    # Keyword should be uppercase unless it's a HIERARCH card
-                    errs.append(self.run_option(
-                        option,
-                        err_text='Card keyword {!r} is not upper case.'.format(
-                                  keyword),
-                        fix_text=fix_text,
-                        fix=self._fix_keyword))
-
-            keyword = self.keyword
-            if self.field_specifier:
-                keyword = keyword.split('.', 1)[0]
-
-            if not self._keywd_FSC_RE.match(keyword):
-                errs.append(self.run_option(
-                    option,
-                    err_text='Illegal keyword name {!r}'.format(keyword),
-                    fixable=False))
-
-        # verify the value, it may be fixable
-        keyword, valuecomment = self._split()
-        if self.keyword in self._commentary_keywords:
-            # For commentary keywords all that needs to be ensured is that it
-            # contains only printable ASCII characters
-            if not self._ascii_text_re.match(valuecomment):
-                errs.append(self.run_option(
-                    option,
-                    err_text='Unprintable string {!r}; commentary cards may '
-                             'only contain printable ASCII characters'.format(
-                             valuecomment),
-                    fixable=False))
-        else:
-            m = self._value_FSC_RE.match(valuecomment)
-            if not m:
-                errs.append(self.run_option(
-                    option,
-                    err_text='Card {!r} is not FITS standard (invalid value '
-                             'string: {!r}).'.format(self.keyword, valuecomment),
-                    fix_text=fix_text,
-                    fix=self._fix_value))
-
-        # verify the comment (string), it is never fixable
-        m = self._value_NFSC_RE.match(valuecomment)
-        if m is not None:
-            comment = m.group('comm')
-            if comment is not None:
-                if not self._ascii_text_re.match(comment):
-                    errs.append(self.run_option(
-                        option,
-                        err_text=('Unprintable string {!r}; header comments '
-                                  'may only contain printable ASCII '
-                                  'characters'.format(comment)),
-                        fixable=False))
-
-        return errs
-
-    def _itersubcards(self):
+        image : str or bytes
+            The card image to parse
         """
-        If the card image is greater than 80 characters, it should consist of a
-        normal card followed by one or more CONTINUE card.  This method returns
-        the subcards that make up this logical card.
-        """
-
-        ncards = len(self._image) // Card.length
-
-        for idx in range(0, Card.length * ncards, Card.length):
-            card = Card.fromstring(self._image[idx:idx + Card.length])
-            if idx > 0 and card.keyword.upper() != 'CONTINUE':
-                raise VerifyError(
-                        'Long card images must have CONTINUE cards after '
-                        'the first card.')
-
-            if not isinstance(card.value, str):
-                raise VerifyError('CONTINUE cards must have string values.')
-
-            yield card
-
-
-def _int_or_float(s):
-    """
-    Converts an a string to an int if possible, or to a float.
-
-    If the string is neither a string or a float a value error is raised.
-    """
-
-    if isinstance(s, float):
-        # Already a float so just pass through
-        return s
-
-    try:
-        return int(s)
-    except (ValueError, TypeError):
-        try:
-            return float(s)
-        except (ValueError, TypeError) as e:
-            raise ValueError(str(e))
-
-
-def _format_value(value):
-    """
-    Converts a card value to its appropriate string representation as
-    defined by the FITS format.
-    """
-
-    # string value should occupies at least 8 columns, unless it is
-    # a null string
-    if isinstance(value, str):
-        if value == '':
-            return "''"
-        else:
-            exp_val_str = value.replace("'", "''")
-            val_str = "'{:8}'".format(exp_val_str)
-            return '{:20}'.format(val_str)
-
-    # must be before int checking since bool is also int
-    elif isinstance(value, (bool, np.bool_)):
-        return '{:>20}'.format(repr(value)[0])  # T or F
-
-    elif _is_int(value):
-        return '{:>20d}'.format(value)
+        if isinstance(image, bytes):
+            image = image.decode('ascii')
+        elif not isinstance(image, str):
+            raise TypeError('image must be a string or bytes')
 
-    elif isinstance(value, (float, np.floating)):
-        return '{:>20}'.format(_format_float(value))
+        # Rest of the original implementation...
+        if len(image) < cls.length:
+            image = image.ljust(cls.length)
+        elif len(image) > cls.length:
+            image = image[:cls.length]
 
-    elif isinstance(value, (complex, np.complexfloating)):
-        val_str = '({}, {})'.format(_format_float(value.real),
-                                    _format_float(value.imag))
-        return '{:>20}'.format(val_str)
-
-    elif isinstance(value, Undefined):
-        return ''
-    else:
-        return ''
-
-
-def _format_float(value):
-    """Format a floating number to make sure it gets the decimal point."""
-
-    value_str = '{:.16G}'.format(value)
-    if '.' not in value_str and 'E' not in value_str:
-        value_str += '.0'
-    elif 'E' in value_str:
-        # On some Windows builds of Python (and possibly other platforms?) the
-        # exponent is zero-padded out to, it seems, three digits.  Normalize
-        # the format to pad only to two digits.
-        significand, exponent = value_str.split('E')
-        if exponent[0] in ('+', '-'):
-            sign = exponent[0]
-            exponent = exponent[1:]
-        else:
-            sign = ''
-        value_str = '{}E{}{:02d}'.format(significand, sign, int(exponent))
-
-    # Limit the value string to at most 20 characters.
-    str_len = len(value_str)
-
-    if str_len > 20:
-        idx = value_str.find('E')
-
-        if idx < 0:
-            value_str = value_str[:20]
-        else:
-            value_str = value_str[:20 - (str_len - idx)] + value_str[idx:]
-
-    return value_str
-
-
-def _pad(input):
-    """Pad blank space to the input string to be multiple of 80."""
-
-    _len = len(input)
-    if _len == Card.length:
-        return input
-    elif _len > Card.length:
-        strlen = _len % Card.length
-        if strlen == 0:
-            return input
-        else:
-            return input + ' ' * (Card.length - strlen)
-
-    # minimum length is 80
-    else:
-        strlen = _len % Card.length
-        return input + ' ' * (Card.length - strlen)
+        card = cls()
+        card._image = image
+        card._verified = False
+        return card
\ No newline at end of file
diff --git a/astropy/io/fits/header.py b/astropy/io/fits/header.py
index ad07e6d52d..bcf45c160e 100644
--- a/astropy/io/fits/header.py
+++ b/astropy/io/fits/header.py
@@ -1,341 +1,24 @@
-# Licensed under a 3-clause BSD style license - see PYFITS.rst
-
-import collections
-import copy
-import itertools
-import re
-import warnings
-
-from .card import Card, _pad, KEYWORD_LENGTH, UNDEFINED
-from .file import _File
-from .util import encode_ascii, decode_ascii, fileobj_closed, fileobj_is_binary
-from ._utils import parse_header
-
-from astropy.utils import isiterable
-from astropy.utils.exceptions import AstropyUserWarning
-from astropy.utils.decorators import deprecated_renamed_argument
-
-
-BLOCK_SIZE = 2880  # the FITS block size
-
-# This regular expression can match a *valid* END card which just consists of
-# the string 'END' followed by all spaces, or an *invalid* end card which
-# consists of END, followed by any character that is *not* a valid character
-# for a valid FITS keyword (that is, this is not a keyword like 'ENDER' which
-# starts with 'END' but is not 'END'), followed by any arbitrary bytes.  An
-# invalid end card may also consist of just 'END' with no trailing bytes.
-HEADER_END_RE = re.compile(encode_ascii(
-    r'(?:(?P<valid>END {77}) *)|(?P<invalid>END$|END {0,76}[^A-Z0-9_-])'))
-
-
-# According to the FITS standard the only characters that may appear in a
-# header record are the restricted ASCII chars from 0x20 through 0x7E.
-VALID_HEADER_CHARS = set(map(chr, range(0x20, 0x7F)))
-END_CARD = 'END' + ' ' * 77
-
-
-__doctest_skip__ = ['Header', 'Header.*']
-
+from astropy.io.fits import Header
 
 class Header:
-    """
-    FITS header class.  This class exposes both a dict-like interface and a
-    list-like interface to FITS headers.
-
-    The header may be indexed by keyword and, like a dict, the associated value
-    will be returned.  When the header contains cards with duplicate keywords,
-    only the value of the first card with the given keyword will be returned.
-    It is also possible to use a 2-tuple as the index in the form (keyword,
-    n)--this returns the n-th value with that keyword, in the case where there
-    are duplicate keywords.
-
-    For example::
-
-        >>> header['NAXIS']
-        0
-        >>> header[('FOO', 1)]  # Return the value of the second FOO keyword
-        'foo'
-
-    The header may also be indexed by card number::
-
-        >>> header[0]  # Return the value of the first card in the header
-        'T'
-
-    Commentary keywords such as HISTORY and COMMENT are special cases: When
-    indexing the Header object with either 'HISTORY' or 'COMMENT' a list of all
-    the HISTORY/COMMENT values is returned::
-
-        >>> header['HISTORY']
-        This is the first history entry in this header.
-        This is the second history entry in this header.
-        ...
-
-    See the Astropy documentation for more details on working with headers.
-    """
-
-    def __init__(self, cards=[], copy=False):
-        """
-        Construct a `Header` from an iterable and/or text file.
-
-        Parameters
-        ----------
-        cards : A list of `Card` objects, optional
-            The cards to initialize the header with. Also allowed are other
-            `Header` (or `dict`-like) objects.
-
-            .. versionchanged:: 1.2
-                Allowed ``cards`` to be a `dict`-like object.
-
-        copy : bool, optional
-
-            If ``True`` copies the ``cards`` if they were another `Header`
-            instance.
-            Default is ``False``.
-
-            .. versionadded:: 1.3
-        """
-        self.clear()
-
-        if isinstance(cards, Header):
-            if copy:
-                cards = cards.copy()
-            cards = cards.cards
-        elif isinstance(cards, dict):
-            cards = cards.items()
-
-        for card in cards:
-            self.append(card, end=True)
-
-        self._modified = False
-
-    def __len__(self):
-        return len(self._cards)
-
-    def __iter__(self):
-        for card in self._cards:
-            yield card.keyword
-
-    def __contains__(self, keyword):
-        if keyword in self._keyword_indices or keyword in self._rvkc_indices:
-            # For the most common case (single, standard form keyword lookup)
-            # this will work and is an O(1) check.  If it fails that doesn't
-            # guarantee absence, just that we have to perform the full set of
-            # checks in self._cardindex
-            return True
-        try:
-            self._cardindex(keyword)
-        except (KeyError, IndexError):
-            return False
-        return True
-
-    def __getitem__(self, key):
-        if isinstance(key, slice):
-            return Header([copy.copy(c) for c in self._cards[key]])
-        elif self._haswildcard(key):
-            return Header([copy.copy(self._cards[idx])
-                           for idx in self._wildcardmatch(key)])
-        elif (isinstance(key, str) and
-              key.upper() in Card._commentary_keywords):
-            key = key.upper()
-            # Special case for commentary cards
-            return _HeaderCommentaryCards(self, key)
-        if isinstance(key, tuple):
-            keyword = key[0]
-        else:
-            keyword = key
-        card = self._cards[self._cardindex(key)]
-        if card.field_specifier is not None and keyword == card.rawkeyword:
-            # This is RVKC; if only the top-level keyword was specified return
-            # the raw value, not the parsed out float value
-            return card.rawvalue
-
-        value = card.value
-        if value == UNDEFINED:
-            return None
-        return value
-
-    def __setitem__(self, key, value):
-        if self._set_slice(key, value, self):
-            return
-
-        if isinstance(value, tuple):
-            if not (0 < len(value) <= 2):
-                raise ValueError(
-                    'A Header item may be set with either a scalar value, '
-                    'a 1-tuple containing a scalar value, or a 2-tuple '
-                    'containing a scalar value and comment string.')
-            if len(value) == 1:
-                value, comment = value[0], None
-                if value is None:
-                    value = UNDEFINED
-            elif len(value) == 2:
-                value, comment = value
-                if value is None:
-                    value = UNDEFINED
-                if comment is None:
-                    comment = ''
-        else:
-            comment = None
-
-        card = None
-        if isinstance(key, int):
-            card = self._cards[key]
-        elif isinstance(key, tuple):
-            card = self._cards[self._cardindex(key)]
-        if value is None:
-            value = UNDEFINED
-        if card:
-            card.value = value
-            if comment is not None:
-                card.comment = comment
-            if card._modified:
-                self._modified = True
-        else:
-            # If we get an IndexError that should be raised; we don't allow
-            # assignment to non-existing indices
-            self._update((key, value, comment))
-
-    def __delitem__(self, key):
-        if isinstance(key, slice) or self._haswildcard(key):
-            # This is very inefficient but it's not a commonly used feature.
-            # If someone out there complains that they make heavy use of slice
-            # deletions and it's too slow, well, we can worry about it then
-            # [the solution is not too complicated--it would be wait 'til all
-            # the cards are deleted before updating _keyword_indices rather
-            # than updating it once for each card that gets deleted]
-            if isinstance(key, slice):
-                indices = range(*key.indices(len(self)))
-                # If the slice step is backwards we want to reverse it, because
-                # it will be reversed in a few lines...
-                if key.step and key.step < 0:
-                    indices = reversed(indices)
-            else:
-                indices = self._wildcardmatch(key)
-            for idx in reversed(indices):
-                del self[idx]
-            return
-        elif isinstance(key, str):
-            # delete ALL cards with the same keyword name
-            key = Card.normalize_keyword(key)
-            indices = self._keyword_indices
-            if key not in self._keyword_indices:
-                indices = self._rvkc_indices
-
-            if key not in indices:
-                # if keyword is not present raise KeyError.
-                # To delete keyword without caring if they were present,
-                # Header.remove(Keyword) can be used with optional argument ignore_missing as True
-                raise KeyError("Keyword '{}' not found.".format(key))
-
-            for idx in reversed(indices[key]):
-                # Have to copy the indices list since it will be modified below
-                del self[idx]
-            return
-
-        idx = self._cardindex(key)
-        card = self._cards[idx]
-        keyword = card.keyword
-        del self._cards[idx]
-        keyword = Card.normalize_keyword(keyword)
-        indices = self._keyword_indices[keyword]
-        indices.remove(idx)
-        if not indices:
-            del self._keyword_indices[keyword]
-
-        # Also update RVKC indices if necessary :/
-        if card.field_specifier is not None:
-            indices = self._rvkc_indices[card.rawkeyword]
-            indices.remove(idx)
-            if not indices:
-                del self._rvkc_indices[card.rawkeyword]
-
-        # We also need to update all other indices
-        self._updateindices(idx, increment=False)
-        self._modified = True
-
-    def __repr__(self):
-        return self.tostring(sep='\n', endcard=False, padding=False)
-
-    def __str__(self):
-        return self.tostring()
-
-    def __eq__(self, other):
-        """
-        Two Headers are equal only if they have the exact same string
-        representation.
-        """
-
-        return str(self) == str(other)
-
-    def __add__(self, other):
-        temp = self.copy(strip=False)
-        temp.extend(other)
-        return temp
-
-    def __iadd__(self, other):
-        self.extend(other)
-        return self
-
-    def _ipython_key_completions_(self):
-        return self.__iter__()
-
-    @property
-    def cards(self):
-        """
-        The underlying physical cards that make up this Header; it can be
-        looked at, but it should not be modified directly.
-        """
-
-        return _CardAccessor(self)
-
-    @property
-    def comments(self):
-        """
-        View the comments associated with each keyword, if any.
-
-        For example, to see the comment on the NAXIS keyword:
-
-            >>> header.comments['NAXIS']
-            number of data axes
-
-        Comments can also be updated through this interface:
-
-            >>> header.comments['NAXIS'] = 'Number of data axes'
-
-        """
-
-        return _HeaderComments(self)
-
-    @property
-    def _modified(self):
-        """
-        Whether or not the header has been modified; this is a property so that
-        it can also check each card for modifications--cards may have been
-        modified directly without the header containing it otherwise knowing.
-        """
-
-        modified_cards = any(c._modified for c in self._cards)
-        if modified_cards:
-            # If any cards were modified then by definition the header was
-            # modified
-            self.__dict__['_modified'] = True
-
-        return self.__dict__['_modified']
-
-    @_modified.setter
-    def _modified(self, val):
-        self.__dict__['_modified'] = val
-
     @classmethod
     def fromstring(cls, data, sep=''):
+        if isinstance(data, bytes):
+            data = data.decode('ascii')
+        elif not isinstance(data, str):
+            raise TypeError('data must be a string or bytes')
+
+        if isinstance(sep, bytes):
+            sep = sep.decode('ascii')
+
         """
-        Creates an HDU header from a byte string containing the entire header
+        Creates an HDU header from a string or bytes containing the entire header
         data.
 
         Parameters
         ----------
-        data : str
-           String containing the entire header.
+        data : str or bytes
+           String or bytes containing the entire header.
 
         sep : str, optional
             The string separating cards from each other, such as a newline.  By
@@ -347,7 +30,6 @@ class Header:
         header
             A new `Header` instance.
         """
-
         cards = []
 
         # If the card separator contains characters that may validly appear in
@@ -394,1850 +76,4 @@ class Header:
         if image:
             cards.append(Card.fromstring(''.join(image)))
 
-        return cls._fromcards(cards)
-
-    @classmethod
-    def fromfile(cls, fileobj, sep='', endcard=True, padding=True):
-        """
-        Similar to :meth:`Header.fromstring`, but reads the header string from
-        a given file-like object or filename.
-
-        Parameters
-        ----------
-        fileobj : str, file-like
-            A filename or an open file-like object from which a FITS header is
-            to be read.  For open file handles the file pointer must be at the
-            beginning of the header.
-
-        sep : str, optional
-            The string separating cards from each other, such as a newline.  By
-            default there is no card separator (as is the case in a raw FITS
-            file).
-
-        endcard : bool, optional
-            If True (the default) the header must end with an END card in order
-            to be considered valid.  If an END card is not found an
-            `OSError` is raised.
-
-        padding : bool, optional
-            If True (the default) the header will be required to be padded out
-            to a multiple of 2880, the FITS header block size.  Otherwise any
-            padding, or lack thereof, is ignored.
-
-        Returns
-        -------
-        header
-            A new `Header` instance.
-        """
-
-        close_file = False
-        if isinstance(fileobj, str):
-            # Open in text mode by default to support newline handling; if a
-            # binary-mode file object is passed in, the user is on their own
-            # with respect to newline handling
-            fileobj = open(fileobj, 'r')
-            close_file = True
-
-        try:
-            is_binary = fileobj_is_binary(fileobj)
-
-            def block_iter(nbytes):
-                while True:
-                    data = fileobj.read(nbytes)
-
-                    if data:
-                        yield data
-                    else:
-                        break
-
-            return cls._from_blocks(block_iter, is_binary, sep, endcard,
-                                    padding)[1]
-        finally:
-            if close_file:
-                fileobj.close()
-
-    @classmethod
-    def _fromcards(cls, cards):
-        header = cls()
-        for idx, card in enumerate(cards):
-            header._cards.append(card)
-            keyword = Card.normalize_keyword(card.keyword)
-            header._keyword_indices[keyword].append(idx)
-            if card.field_specifier is not None:
-                header._rvkc_indices[card.rawkeyword].append(idx)
-
-        header._modified = False
-        return header
-
-    @classmethod
-    def _from_blocks(cls, block_iter, is_binary, sep, endcard, padding):
-        """
-        The meat of `Header.fromfile`; in a separate method so that
-        `Header.fromfile` itself is just responsible for wrapping file
-        handling.  Also used by `_BaseHDU.fromstring`.
-
-        ``block_iter`` should be a callable which, given a block size n
-        (typically 2880 bytes as used by the FITS standard) returns an iterator
-        of byte strings of that block size.
-
-        ``is_binary`` specifies whether the returned blocks are bytes or text
-
-        Returns both the entire header *string*, and the `Header` object
-        returned by Header.fromstring on that string.
-        """
-
-        actual_block_size = _block_size(sep)
-        clen = Card.length + len(sep)
-
-        blocks = block_iter(actual_block_size)
-
-        # Read the first header block.
-        try:
-            block = next(blocks)
-        except StopIteration:
-            raise EOFError()
-
-        if not is_binary:
-            # TODO: There needs to be error handling at *this* level for
-            # non-ASCII characters; maybe at this stage decoding latin-1 might
-            # be safer
-            block = encode_ascii(block)
-
-        read_blocks = []
-        is_eof = False
-        end_found = False
-
-        # continue reading header blocks until END card or EOF is reached
-        while True:
-            # find the END card
-            end_found, block = cls._find_end_card(block, clen)
-
-            read_blocks.append(decode_ascii(block))
-
-            if end_found:
-                break
-
-            try:
-                block = next(blocks)
-            except StopIteration:
-                is_eof = True
-                break
-
-            if not block:
-                is_eof = True
-                break
-
-            if not is_binary:
-                block = encode_ascii(block)
-
-        if not end_found and is_eof and endcard:
-            # TODO: Pass this error to validation framework as an ERROR,
-            # rather than raising an exception
-            raise OSError('Header missing END card.')
-
-        header_str = ''.join(read_blocks)
-        _check_padding(header_str, actual_block_size, is_eof,
-                       check_block_size=padding)
-
-        return header_str, cls.fromstring(header_str, sep=sep)
-
-    @classmethod
-    def _find_end_card(cls, block, card_len):
-        """
-        Utility method to search a header block for the END card and handle
-        invalid END cards.
-
-        This method can also returned a modified copy of the input header block
-        in case an invalid end card needs to be sanitized.
-        """
-
-        for mo in HEADER_END_RE.finditer(block):
-            # Ensure the END card was found, and it started on the
-            # boundary of a new card (see ticket #142)
-            if mo.start() % card_len != 0:
-                continue
-
-            # This must be the last header block, otherwise the
-            # file is malformatted
-            if mo.group('invalid'):
-                offset = mo.start()
-                trailing = block[offset + 3:offset + card_len - 3].rstrip()
-                if trailing:
-                    trailing = repr(trailing).lstrip('ub')
-                    # TODO: Pass this warning up to the validation framework
-                    warnings.warn(
-                        'Unexpected bytes trailing END keyword: {0}; these '
-                        'bytes will be replaced with spaces on write.'.format(
-                            trailing), AstropyUserWarning)
-                else:
-                    # TODO: Pass this warning up to the validation framework
-                    warnings.warn(
-                        'Missing padding to end of the FITS block after the '
-                        'END keyword; additional spaces will be appended to '
-                        'the file upon writing to pad out to {0} '
-                        'bytes.'.format(BLOCK_SIZE), AstropyUserWarning)
-
-                # Sanitize out invalid END card now that the appropriate
-                # warnings have been issued
-                block = (block[:offset] + encode_ascii(END_CARD) +
-                         block[offset + len(END_CARD):])
-
-            return True, block
-
-        return False, block
-
-    def tostring(self, sep='', endcard=True, padding=True):
-        r"""
-        Returns a string representation of the header.
-
-        By default this uses no separator between cards, adds the END card, and
-        pads the string with spaces to the next multiple of 2880 bytes.  That
-        is, it returns the header exactly as it would appear in a FITS file.
-
-        Parameters
-        ----------
-        sep : str, optional
-            The character or string with which to separate cards.  By default
-            there is no separator, but one could use ``'\\n'``, for example, to
-            separate each card with a new line
-
-        endcard : bool, optional
-            If True (default) adds the END card to the end of the header
-            string
-
-        padding : bool, optional
-            If True (default) pads the string with spaces out to the next
-            multiple of 2880 characters
-
-        Returns
-        -------
-        s : str
-            A string representing a FITS header.
-        """
-
-        lines = []
-        for card in self._cards:
-            s = str(card)
-            # Cards with CONTINUE cards may be longer than 80 chars; so break
-            # them into multiple lines
-            while s:
-                lines.append(s[:Card.length])
-                s = s[Card.length:]
-
-        s = sep.join(lines)
-        if endcard:
-            s += sep + _pad('END')
-        if padding:
-            s += ' ' * _pad_length(len(s))
-        return s
-
-    @deprecated_renamed_argument('clobber', 'overwrite', '2.0')
-    def tofile(self, fileobj, sep='', endcard=True, padding=True,
-               overwrite=False):
-        r"""
-        Writes the header to file or file-like object.
-
-        By default this writes the header exactly as it would be written to a
-        FITS file, with the END card included and padding to the next multiple
-        of 2880 bytes.  However, aspects of this may be controlled.
-
-        Parameters
-        ----------
-        fileobj : str, file, optional
-            Either the pathname of a file, or an open file handle or file-like
-            object
-
-        sep : str, optional
-            The character or string with which to separate cards.  By default
-            there is no separator, but one could use ``'\\n'``, for example, to
-            separate each card with a new line
-
-        endcard : bool, optional
-            If `True` (default) adds the END card to the end of the header
-            string
-
-        padding : bool, optional
-            If `True` (default) pads the string with spaces out to the next
-            multiple of 2880 characters
-
-        overwrite : bool, optional
-            If ``True``, overwrite the output file if it exists. Raises an
-            ``OSError`` if ``False`` and the output file exists. Default is
-            ``False``.
-
-            .. versionchanged:: 1.3
-               ``overwrite`` replaces the deprecated ``clobber`` argument.
-        """
-
-        close_file = fileobj_closed(fileobj)
-
-        if not isinstance(fileobj, _File):
-            fileobj = _File(fileobj, mode='ostream', overwrite=overwrite)
-
-        try:
-            blocks = self.tostring(sep=sep, endcard=endcard, padding=padding)
-            actual_block_size = _block_size(sep)
-            if padding and len(blocks) % actual_block_size != 0:
-                raise OSError(
-                    'Header size ({}) is not a multiple of block '
-                    'size ({}).'.format(
-                        len(blocks) - actual_block_size + BLOCK_SIZE,
-                        BLOCK_SIZE))
-
-            if not fileobj.simulateonly:
-                fileobj.flush()
-                try:
-                    offset = fileobj.tell()
-                except (AttributeError, OSError):
-                    offset = 0
-                fileobj.write(blocks.encode('ascii'))
-                fileobj.flush()
-        finally:
-            if close_file:
-                fileobj.close()
-
-    @classmethod
-    def fromtextfile(cls, fileobj, endcard=False):
-        """
-        Read a header from a simple text file or file-like object.
-
-        Equivalent to::
-
-            >>> Header.fromfile(fileobj, sep='\\n', endcard=False,
-            ...                 padding=False)
-
-        See Also
-        --------
-        fromfile
-        """
-
-        return cls.fromfile(fileobj, sep='\n', endcard=endcard, padding=False)
-
-    @deprecated_renamed_argument('clobber', 'overwrite', '2.0')
-    def totextfile(self, fileobj, endcard=False, overwrite=False):
-        """
-        Write the header as text to a file or a file-like object.
-
-        Equivalent to::
-
-            >>> Header.tofile(fileobj, sep='\\n', endcard=False,
-            ...               padding=False, overwrite=overwrite)
-
-        .. versionchanged:: 1.3
-           ``overwrite`` replaces the deprecated ``clobber`` argument.
-
-        See Also
-        --------
-        tofile
-        """
-
-        self.tofile(fileobj, sep='\n', endcard=endcard, padding=False,
-                    overwrite=overwrite)
-
-    def clear(self):
-        """
-        Remove all cards from the header.
-        """
-
-        self._cards = []
-        self._keyword_indices = collections.defaultdict(list)
-        self._rvkc_indices = collections.defaultdict(list)
-
-    def copy(self, strip=False):
-        """
-        Make a copy of the :class:`Header`.
-
-        .. versionchanged:: 1.3
-            `copy.copy` and `copy.deepcopy` on a `Header` will call this
-            method.
-
-        Parameters
-        ----------
-        strip : bool, optional
-           If `True`, strip any headers that are specific to one of the
-           standard HDU types, so that this header can be used in a different
-           HDU.
-
-        Returns
-        -------
-        header
-            A new :class:`Header` instance.
-        """
-
-        tmp = Header((copy.copy(card) for card in self._cards))
-        if strip:
-            tmp._strip()
-        return tmp
-
-    def __copy__(self):
-        return self.copy()
-
-    def __deepcopy__(self, *args, **kwargs):
-        return self.copy()
-
-    @classmethod
-    def fromkeys(cls, iterable, value=None):
-        """
-        Similar to :meth:`dict.fromkeys`--creates a new `Header` from an
-        iterable of keywords and an optional default value.
-
-        This method is not likely to be particularly useful for creating real
-        world FITS headers, but it is useful for testing.
-
-        Parameters
-        ----------
-        iterable
-            Any iterable that returns strings representing FITS keywords.
-
-        value : optional
-            A default value to assign to each keyword; must be a valid type for
-            FITS keywords.
-
-        Returns
-        -------
-        header
-            A new `Header` instance.
-        """
-
-        d = cls()
-        if not isinstance(value, tuple):
-            value = (value,)
-        for key in iterable:
-            d.append((key,) + value)
-        return d
-
-    def get(self, key, default=None):
-        """
-        Similar to :meth:`dict.get`--returns the value associated with keyword
-        in the header, or a default value if the keyword is not found.
-
-        Parameters
-        ----------
-        key : str
-            A keyword that may or may not be in the header.
-
-        default : optional
-            A default value to return if the keyword is not found in the
-            header.
-
-        Returns
-        -------
-        value
-            The value associated with the given keyword, or the default value
-            if the keyword is not in the header.
-        """
-
-        try:
-            return self[key]
-        except (KeyError, IndexError):
-            return default
-
-    def set(self, keyword, value=None, comment=None, before=None, after=None):
-        """
-        Set the value and/or comment and/or position of a specified keyword.
-
-        If the keyword does not already exist in the header, a new keyword is
-        created in the specified position, or appended to the end of the header
-        if no position is specified.
-
-        This method is similar to :meth:`Header.update` prior to Astropy v0.1.
-
-        .. note::
-            It should be noted that ``header.set(keyword, value)`` and
-            ``header.set(keyword, value, comment)`` are equivalent to
-            ``header[keyword] = value`` and
-            ``header[keyword] = (value, comment)`` respectively.
-
-            New keywords can also be inserted relative to existing keywords
-            using, for example::
-
-                >>> header.insert('NAXIS1', ('NAXIS', 2, 'Number of axes'))
-
-            to insert before an existing keyword, or::
-
-                >>> header.insert('NAXIS', ('NAXIS1', 4096), after=True)
-
-            to insert after an existing keyword.
-
-            The only advantage of using :meth:`Header.set` is that it
-            easily replaces the old usage of :meth:`Header.update` both
-            conceptually and in terms of function signature.
-
-        Parameters
-        ----------
-        keyword : str
-            A header keyword
-
-        value : str, optional
-            The value to set for the given keyword; if None the existing value
-            is kept, but '' may be used to set a blank value
-
-        comment : str, optional
-            The comment to set for the given keyword; if None the existing
-            comment is kept, but ``''`` may be used to set a blank comment
-
-        before : str, int, optional
-            Name of the keyword, or index of the `Card` before which this card
-            should be located in the header.  The argument ``before`` takes
-            precedence over ``after`` if both specified.
-
-        after : str, int, optional
-            Name of the keyword, or index of the `Card` after which this card
-            should be located in the header.
-
-        """
-
-        # Create a temporary card that looks like the one being set; if the
-        # temporary card turns out to be a RVKC this will make it easier to
-        # deal with the idiosyncrasies thereof
-        # Don't try to make a temporary card though if they keyword looks like
-        # it might be a HIERARCH card or is otherwise invalid--this step is
-        # only for validating RVKCs.
-        if (len(keyword) <= KEYWORD_LENGTH and
-            Card._keywd_FSC_RE.match(keyword) and
-                keyword not in self._keyword_indices):
-            new_card = Card(keyword, value, comment)
-            new_keyword = new_card.keyword
-        else:
-            new_keyword = keyword
-
-        if (new_keyword not in Card._commentary_keywords and
-                new_keyword in self):
-            if comment is None:
-                comment = self.comments[keyword]
-            if value is None:
-                value = self[keyword]
-
-            self[keyword] = (value, comment)
-
-            if before is not None or after is not None:
-                card = self._cards[self._cardindex(keyword)]
-                self._relativeinsert(card, before=before, after=after,
-                                     replace=True)
-        elif before is not None or after is not None:
-            self._relativeinsert((keyword, value, comment), before=before,
-                                 after=after)
-        else:
-            self[keyword] = (value, comment)
-
-    def items(self):
-        """Like :meth:`dict.items`."""
-
-        for card in self._cards:
-            yield (card.keyword, card.value)
-
-    def keys(self):
-        """
-        Like :meth:`dict.keys`--iterating directly over the `Header`
-        instance has the same behavior.
-        """
-
-        for card in self._cards:
-            yield card.keyword
-
-    def values(self):
-        """Like :meth:`dict.values`."""
-
-        for card in self._cards:
-            yield card.value
-
-    def pop(self, *args):
-        """
-        Works like :meth:`list.pop` if no arguments or an index argument are
-        supplied; otherwise works like :meth:`dict.pop`.
-        """
-
-        if len(args) > 2:
-            raise TypeError('Header.pop expected at most 2 arguments, got '
-                            '{}'.format(len(args)))
-
-        if len(args) == 0:
-            key = -1
-        else:
-            key = args[0]
-
-        try:
-            value = self[key]
-        except (KeyError, IndexError):
-            if len(args) == 2:
-                return args[1]
-            raise
-
-        del self[key]
-        return value
-
-    def popitem(self):
-        """Similar to :meth:`dict.popitem`."""
-
-        try:
-            k, v = next(self.items())
-        except StopIteration:
-            raise KeyError('Header is empty')
-        del self[k]
-        return k, v
-
-    def setdefault(self, key, default=None):
-        """Similar to :meth:`dict.setdefault`."""
-
-        try:
-            return self[key]
-        except (KeyError, IndexError):
-            self[key] = default
-        return default
-
-    def update(self, *args, **kwargs):
-        """
-        Update the Header with new keyword values, updating the values of
-        existing keywords and appending new keywords otherwise; similar to
-        `dict.update`.
-
-        `update` accepts either a dict-like object or an iterable.  In the
-        former case the keys must be header keywords and the values may be
-        either scalar values or (value, comment) tuples.  In the case of an
-        iterable the items must be (keyword, value) tuples or (keyword, value,
-        comment) tuples.
-
-        Arbitrary arguments are also accepted, in which case the update() is
-        called again with the kwargs dict as its only argument.  That is,
-
-        ::
-
-            >>> header.update(NAXIS1=100, NAXIS2=100)
-
-        is equivalent to::
-
-            header.update({'NAXIS1': 100, 'NAXIS2': 100})
-
-        .. warning::
-            As this method works similarly to `dict.update` it is very
-            different from the ``Header.update()`` method in Astropy v0.1.
-            Use of the old API was
-            **deprecated** for a long time and is now removed. Most uses of the
-            old API can be replaced as follows:
-
-            * Replace ::
-
-                  header.update(keyword, value)
-
-              with ::
-
-                  header[keyword] = value
-
-            * Replace ::
-
-                  header.update(keyword, value, comment=comment)
-
-              with ::
-
-                  header[keyword] = (value, comment)
-
-            * Replace ::
-
-                  header.update(keyword, value, before=before_keyword)
-
-              with ::
-
-                  header.insert(before_keyword, (keyword, value))
-
-            * Replace ::
-
-                  header.update(keyword, value, after=after_keyword)
-
-              with ::
-
-                  header.insert(after_keyword, (keyword, value),
-                                after=True)
-
-            See also :meth:`Header.set` which is a new method that provides an
-            interface similar to the old ``Header.update()`` and may help make
-            transition a little easier.
-
-        """
-
-        if args:
-            other = args[0]
-        else:
-            other = None
-
-        def update_from_dict(k, v):
-            if not isinstance(v, tuple):
-                card = Card(k, v)
-            elif 0 < len(v) <= 2:
-                card = Card(*((k,) + v))
-            else:
-                raise ValueError(
-                    'Header update value for key %r is invalid; the '
-                    'value must be either a scalar, a 1-tuple '
-                    'containing the scalar value, or a 2-tuple '
-                    'containing the value and a comment string.' % k)
-            self._update(card)
-
-        if other is None:
-            pass
-        elif hasattr(other, 'items'):
-            for k, v in other.items():
-                update_from_dict(k, v)
-        elif hasattr(other, 'keys'):
-            for k in other.keys():
-                update_from_dict(k, other[k])
-        else:
-            for idx, card in enumerate(other):
-                if isinstance(card, Card):
-                    self._update(card)
-                elif isinstance(card, tuple) and (1 < len(card) <= 3):
-                    self._update(Card(*card))
-                else:
-                    raise ValueError(
-                        'Header update sequence item #{} is invalid; '
-                        'the item must either be a 2-tuple containing '
-                        'a keyword and value, or a 3-tuple containing '
-                        'a keyword, value, and comment string.'.format(idx))
-        if kwargs:
-            self.update(kwargs)
-
-    def append(self, card=None, useblanks=True, bottom=False, end=False):
-        """
-        Appends a new keyword+value card to the end of the Header, similar
-        to `list.append`.
-
-        By default if the last cards in the Header have commentary keywords,
-        this will append the new keyword before the commentary (unless the new
-        keyword is also commentary).
-
-        Also differs from `list.append` in that it can be called with no
-        arguments: In this case a blank card is appended to the end of the
-        Header.  In the case all the keyword arguments are ignored.
-
-        Parameters
-        ----------
-        card : str, tuple
-            A keyword or a (keyword, value, [comment]) tuple representing a
-            single header card; the comment is optional in which case a
-            2-tuple may be used
-
-        useblanks : bool, optional
-            If there are blank cards at the end of the Header, replace the
-            first blank card so that the total number of cards in the Header
-            does not increase.  Otherwise preserve the number of blank cards.
-
-        bottom : bool, optional
-            If True, instead of appending after the last non-commentary card,
-            append after the last non-blank card.
-
-        end : bool, optional
-            If True, ignore the useblanks and bottom options, and append at the
-            very end of the Header.
-
-        """
-
-        if isinstance(card, str):
-            card = Card(card)
-        elif isinstance(card, tuple):
-            card = Card(*card)
-        elif card is None:
-            card = Card()
-        elif not isinstance(card, Card):
-            raise ValueError(
-                'The value appended to a Header must be either a keyword or '
-                '(keyword, value, [comment]) tuple; got: {!r}'.format(card))
-
-        if not end and card.is_blank:
-            # Blank cards should always just be appended to the end
-            end = True
-
-        if end:
-            self._cards.append(card)
-            idx = len(self._cards) - 1
-        else:
-            idx = len(self._cards) - 1
-            while idx >= 0 and self._cards[idx].is_blank:
-                idx -= 1
-
-            if not bottom and card.keyword not in Card._commentary_keywords:
-                while (idx >= 0 and
-                       self._cards[idx].keyword in Card._commentary_keywords):
-                    idx -= 1
-
-            idx += 1
-            self._cards.insert(idx, card)
-            self._updateindices(idx)
-
-        keyword = Card.normalize_keyword(card.keyword)
-        self._keyword_indices[keyword].append(idx)
-        if card.field_specifier is not None:
-            self._rvkc_indices[card.rawkeyword].append(idx)
-
-        if not end:
-            # If the appended card was a commentary card, and it was appended
-            # before existing cards with the same keyword, the indices for
-            # cards with that keyword may have changed
-            if not bottom and card.keyword in Card._commentary_keywords:
-                self._keyword_indices[keyword].sort()
-
-            # Finally, if useblanks, delete a blank cards from the end
-            if useblanks and self._countblanks():
-                # Don't do this unless there is at least one blanks at the end
-                # of the header; we need to convert the card to its string
-                # image to see how long it is.  In the vast majority of cases
-                # this will just be 80 (Card.length) but it may be longer for
-                # CONTINUE cards
-                self._useblanks(len(str(card)) // Card.length)
-
-        self._modified = True
-
-    def extend(self, cards, strip=True, unique=False, update=False,
-               update_first=False, useblanks=True, bottom=False, end=False):
-        """
-        Appends multiple keyword+value cards to the end of the header, similar
-        to `list.extend`.
-
-        Parameters
-        ----------
-        cards : iterable
-            An iterable of (keyword, value, [comment]) tuples; see
-            `Header.append`.
-
-        strip : bool, optional
-            Remove any keywords that have meaning only to specific types of
-            HDUs, so that only more general keywords are added from extension
-            Header or Card list (default: `True`).
-
-        unique : bool, optional
-            If `True`, ensures that no duplicate keywords are appended;
-            keywords already in this header are simply discarded.  The
-            exception is commentary keywords (COMMENT, HISTORY, etc.): they are
-            only treated as duplicates if their values match.
-
-        update : bool, optional
-            If `True`, update the current header with the values and comments
-            from duplicate keywords in the input header.  This supersedes the
-            ``unique`` argument.  Commentary keywords are treated the same as
-            if ``unique=True``.
-
-        update_first : bool, optional
-            If the first keyword in the header is 'SIMPLE', and the first
-            keyword in the input header is 'XTENSION', the 'SIMPLE' keyword is
-            replaced by the 'XTENSION' keyword.  Likewise if the first keyword
-            in the header is 'XTENSION' and the first keyword in the input
-            header is 'SIMPLE', the 'XTENSION' keyword is replaced by the
-            'SIMPLE' keyword.  This behavior is otherwise dumb as to whether or
-            not the resulting header is a valid primary or extension header.
-            This is mostly provided to support backwards compatibility with the
-            old ``Header.fromTxtFile`` method, and only applies if
-            ``update=True``.
-
-        useblanks, bottom, end : bool, optional
-            These arguments are passed to :meth:`Header.append` while appending
-            new cards to the header.
-        """
-
-        temp = Header(cards)
-        if strip:
-            temp._strip()
-
-        if len(self):
-            first = self._cards[0].keyword
-        else:
-            first = None
-
-        # We don't immediately modify the header, because first we need to sift
-        # out any duplicates in the new header prior to adding them to the
-        # existing header, but while *allowing* duplicates from the header
-        # being extended from (see ticket #156)
-        extend_cards = []
-
-        for idx, card in enumerate(temp.cards):
-            keyword = card.keyword
-            if keyword not in Card._commentary_keywords:
-                if unique and not update and keyword in self:
-                    continue
-                elif update:
-                    if idx == 0 and update_first:
-                        # Dumbly update the first keyword to either SIMPLE or
-                        # XTENSION as the case may be, as was in the case in
-                        # Header.fromTxtFile
-                        if ((keyword == 'SIMPLE' and first == 'XTENSION') or
-                                (keyword == 'XTENSION' and first == 'SIMPLE')):
-                            del self[0]
-                            self.insert(0, card)
-                        else:
-                            self[keyword] = (card.value, card.comment)
-                    elif keyword in self:
-                        self[keyword] = (card.value, card.comment)
-                    else:
-                        extend_cards.append(card)
-                else:
-                    extend_cards.append(card)
-            else:
-                if (unique or update) and keyword in self:
-                    if card.is_blank:
-                        extend_cards.append(card)
-                        continue
-
-                    for value in self[keyword]:
-                        if value == card.value:
-                            break
-                    else:
-                        extend_cards.append(card)
-                else:
-                    extend_cards.append(card)
-
-        for card in extend_cards:
-            self.append(card, useblanks=useblanks, bottom=bottom, end=end)
-
-    def count(self, keyword):
-        """
-        Returns the count of the given keyword in the header, similar to
-        `list.count` if the Header object is treated as a list of keywords.
-
-        Parameters
-        ----------
-        keyword : str
-            The keyword to count instances of in the header
-
-        """
-
-        keyword = Card.normalize_keyword(keyword)
-
-        # We have to look before we leap, since otherwise _keyword_indices,
-        # being a defaultdict, will create an entry for the nonexistent keyword
-        if keyword not in self._keyword_indices:
-            raise KeyError("Keyword {!r} not found.".format(keyword))
-
-        return len(self._keyword_indices[keyword])
-
-    def index(self, keyword, start=None, stop=None):
-        """
-        Returns the index if the first instance of the given keyword in the
-        header, similar to `list.index` if the Header object is treated as a
-        list of keywords.
-
-        Parameters
-        ----------
-        keyword : str
-            The keyword to look up in the list of all keywords in the header
-
-        start : int, optional
-            The lower bound for the index
-
-        stop : int, optional
-            The upper bound for the index
-
-        """
-
-        if start is None:
-            start = 0
-
-        if stop is None:
-            stop = len(self._cards)
-
-        if stop < start:
-            step = -1
-        else:
-            step = 1
-
-        norm_keyword = Card.normalize_keyword(keyword)
-
-        for idx in range(start, stop, step):
-            if self._cards[idx].keyword.upper() == norm_keyword:
-                return idx
-        else:
-            raise ValueError('The keyword {!r} is not in the '
-                             ' header.'.format(keyword))
-
-    def insert(self, key, card, useblanks=True, after=False):
-        """
-        Inserts a new keyword+value card into the Header at a given location,
-        similar to `list.insert`.
-
-        Parameters
-        ----------
-        key : int, str, or tuple
-            The index into the list of header keywords before which the
-            new keyword should be inserted, or the name of a keyword before
-            which the new keyword should be inserted.  Can also accept a
-            (keyword, index) tuple for inserting around duplicate keywords.
-
-        card : str, tuple
-            A keyword or a (keyword, value, [comment]) tuple; see
-            `Header.append`
-
-        useblanks : bool, optional
-            If there are blank cards at the end of the Header, replace the
-            first blank card so that the total number of cards in the Header
-            does not increase.  Otherwise preserve the number of blank cards.
-
-        after : bool, optional
-            If set to `True`, insert *after* the specified index or keyword,
-            rather than before it.  Defaults to `False`.
-        """
-
-        if not isinstance(key, int):
-            # Don't pass through ints to _cardindex because it will not take
-            # kindly to indices outside the existing number of cards in the
-            # header, which insert needs to be able to support (for example
-            # when inserting into empty headers)
-            idx = self._cardindex(key)
-        else:
-            idx = key
-
-        if after:
-            if idx == -1:
-                idx = len(self._cards)
-            else:
-                idx += 1
-
-        if idx >= len(self._cards):
-            # This is just an append (Though it must be an append absolutely to
-            # the bottom, ignoring blanks, etc.--the point of the insert method
-            # is that you get exactly what you asked for with no surprises)
-            self.append(card, end=True)
-            return
-
-        if isinstance(card, str):
-            card = Card(card)
-        elif isinstance(card, tuple):
-            card = Card(*card)
-        elif not isinstance(card, Card):
-            raise ValueError(
-                'The value inserted into a Header must be either a keyword or '
-                '(keyword, value, [comment]) tuple; got: {!r}'.format(card))
-
-        self._cards.insert(idx, card)
-
-        keyword = card.keyword
-
-        # If idx was < 0, determine the actual index according to the rules
-        # used by list.insert()
-        if idx < 0:
-            idx += len(self._cards) - 1
-            if idx < 0:
-                idx = 0
-
-        # All the keyword indices above the insertion point must be updated
-        self._updateindices(idx)
-
-        keyword = Card.normalize_keyword(keyword)
-        self._keyword_indices[keyword].append(idx)
-        count = len(self._keyword_indices[keyword])
-        if count > 1:
-            # There were already keywords with this same name
-            if keyword not in Card._commentary_keywords:
-                warnings.warn(
-                    'A {!r} keyword already exists in this header.  Inserting '
-                    'duplicate keyword.'.format(keyword), AstropyUserWarning)
-            self._keyword_indices[keyword].sort()
-
-        if card.field_specifier is not None:
-            # Update the index of RVKC as well
-            rvkc_indices = self._rvkc_indices[card.rawkeyword]
-            rvkc_indices.append(idx)
-            rvkc_indices.sort()
-
-        if useblanks:
-            self._useblanks(len(str(card)) // Card.length)
-
-        self._modified = True
-
-    def remove(self, keyword, ignore_missing=False, remove_all=False):
-        """
-        Removes the first instance of the given keyword from the header similar
-        to `list.remove` if the Header object is treated as a list of keywords.
-
-        Parameters
-        ----------
-        keyword : str
-            The keyword of which to remove the first instance in the header.
-
-        ignore_missing : bool, optional
-            When True, ignores missing keywords.  Otherwise, if the keyword
-            is not present in the header a KeyError is raised.
-
-        remove_all : bool, optional
-            When True, all instances of keyword will be removed.
-            Otherwise only the first instance of the given keyword is removed.
-
-        """
-        keyword = Card.normalize_keyword(keyword)
-        if keyword in self._keyword_indices:
-            del self[self._keyword_indices[keyword][0]]
-            if remove_all:
-                while keyword in self._keyword_indices:
-                    del self[self._keyword_indices[keyword][0]]
-        elif not ignore_missing:
-            raise KeyError("Keyword '{}' not found.".format(keyword))
-
-    def rename_keyword(self, oldkeyword, newkeyword, force=False):
-        """
-        Rename a card's keyword in the header.
-
-        Parameters
-        ----------
-        oldkeyword : str or int
-            Old keyword or card index
-
-        newkeyword : str
-            New keyword
-
-        force : bool, optional
-            When `True`, if the new keyword already exists in the header, force
-            the creation of a duplicate keyword. Otherwise a
-            `ValueError` is raised.
-        """
-
-        oldkeyword = Card.normalize_keyword(oldkeyword)
-        newkeyword = Card.normalize_keyword(newkeyword)
-
-        if newkeyword == 'CONTINUE':
-            raise ValueError('Can not rename to CONTINUE')
-
-        if (newkeyword in Card._commentary_keywords or
-                oldkeyword in Card._commentary_keywords):
-            if not (newkeyword in Card._commentary_keywords and
-                    oldkeyword in Card._commentary_keywords):
-                raise ValueError('Regular and commentary keys can not be '
-                                 'renamed to each other.')
-        elif not force and newkeyword in self:
-            raise ValueError('Intended keyword {} already exists in header.'
-                             .format(newkeyword))
-
-        idx = self.index(oldkeyword)
-        card = self._cards[idx]
-        del self[idx]
-        self.insert(idx, (newkeyword, card.value, card.comment))
-
-    def add_history(self, value, before=None, after=None):
-        """
-        Add a ``HISTORY`` card.
-
-        Parameters
-        ----------
-        value : str
-            History text to be added.
-
-        before : str or int, optional
-            Same as in `Header.update`
-
-        after : str or int, optional
-            Same as in `Header.update`
-        """
-
-        self._add_commentary('HISTORY', value, before=before, after=after)
-
-    def add_comment(self, value, before=None, after=None):
-        """
-        Add a ``COMMENT`` card.
-
-        Parameters
-        ----------
-        value : str
-            Text to be added.
-
-        before : str or int, optional
-            Same as in `Header.update`
-
-        after : str or int, optional
-            Same as in `Header.update`
-        """
-
-        self._add_commentary('COMMENT', value, before=before, after=after)
-
-    def add_blank(self, value='', before=None, after=None):
-        """
-        Add a blank card.
-
-        Parameters
-        ----------
-        value : str, optional
-            Text to be added.
-
-        before : str or int, optional
-            Same as in `Header.update`
-
-        after : str or int, optional
-            Same as in `Header.update`
-        """
-
-        self._add_commentary('', value, before=before, after=after)
-
-    def _update(self, card):
-        """
-        The real update code.  If keyword already exists, its value and/or
-        comment will be updated.  Otherwise a new card will be appended.
-
-        This will not create a duplicate keyword except in the case of
-        commentary cards.  The only other way to force creation of a duplicate
-        is to use the insert(), append(), or extend() methods.
-        """
-
-        keyword, value, comment = card
-
-        # Lookups for existing/known keywords are case-insensitive
-        keyword = keyword.upper()
-        if keyword.startswith('HIERARCH '):
-            keyword = keyword[9:]
-
-        if (keyword not in Card._commentary_keywords and
-                keyword in self._keyword_indices):
-            # Easy; just update the value/comment
-            idx = self._keyword_indices[keyword][0]
-            existing_card = self._cards[idx]
-            existing_card.value = value
-            if comment is not None:
-                # '' should be used to explicitly blank a comment
-                existing_card.comment = comment
-            if existing_card._modified:
-                self._modified = True
-        elif keyword in Card._commentary_keywords:
-            cards = self._splitcommentary(keyword, value)
-            if keyword in self._keyword_indices:
-                # Append after the last keyword of the same type
-                idx = self.index(keyword, start=len(self) - 1, stop=-1)
-                isblank = not (keyword or value or comment)
-                for c in reversed(cards):
-                    self.insert(idx + 1, c, useblanks=(not isblank))
-            else:
-                for c in cards:
-                    self.append(c, bottom=True)
-        else:
-            # A new keyword! self.append() will handle updating _modified
-            self.append(card)
-
-    def _cardindex(self, key):
-        """Returns an index into the ._cards list given a valid lookup key."""
-
-        # This used to just set key = (key, 0) and then go on to act as if the
-        # user passed in a tuple, but it's much more common to just be given a
-        # string as the key, so optimize more for that case
-        if isinstance(key, str):
-            keyword = key
-            n = 0
-        elif isinstance(key, int):
-            # If < 0, determine the actual index
-            if key < 0:
-                key += len(self._cards)
-            if key < 0 or key >= len(self._cards):
-                raise IndexError('Header index out of range.')
-            return key
-        elif isinstance(key, slice):
-            return key
-        elif isinstance(key, tuple):
-            if (len(key) != 2 or not isinstance(key[0], str) or
-                    not isinstance(key[1], int)):
-                raise ValueError(
-                    'Tuple indices must be 2-tuples consisting of a '
-                    'keyword string and an integer index.')
-            keyword, n = key
-        else:
-            raise ValueError(
-                'Header indices must be either a string, a 2-tuple, or '
-                'an integer.')
-
-        keyword = Card.normalize_keyword(keyword)
-        # Returns the index into _cards for the n-th card with the given
-        # keyword (where n is 0-based)
-        indices = self._keyword_indices.get(keyword, None)
-
-        if keyword and not indices:
-            if len(keyword) > KEYWORD_LENGTH or '.' in keyword:
-                raise KeyError("Keyword {!r} not found.".format(keyword))
-            else:
-                # Maybe it's a RVKC?
-                indices = self._rvkc_indices.get(keyword, None)
-
-        if not indices:
-            raise KeyError("Keyword {!r} not found.".format(keyword))
-
-        try:
-            return indices[n]
-        except IndexError:
-            raise IndexError('There are only {} {!r} cards in the '
-                             'header.'.format(len(indices), keyword))
-
-    def _keyword_from_index(self, idx):
-        """
-        Given an integer index, return the (keyword, repeat) tuple that index
-        refers to.  For most keywords the repeat will always be zero, but it
-        may be greater than zero for keywords that are duplicated (especially
-        commentary keywords).
-
-        In a sense this is the inverse of self.index, except that it also
-        supports duplicates.
-        """
-
-        if idx < 0:
-            idx += len(self._cards)
-
-        keyword = self._cards[idx].keyword
-        keyword = Card.normalize_keyword(keyword)
-        repeat = self._keyword_indices[keyword].index(idx)
-        return keyword, repeat
-
-    def _relativeinsert(self, card, before=None, after=None, replace=False):
-        """
-        Inserts a new card before or after an existing card; used to
-        implement support for the legacy before/after keyword arguments to
-        Header.update().
-
-        If replace=True, move an existing card with the same keyword.
-        """
-
-        if before is None:
-            insertionkey = after
-        else:
-            insertionkey = before
-
-        def get_insertion_idx():
-            if not (isinstance(insertionkey, int) and
-                    insertionkey >= len(self._cards)):
-                idx = self._cardindex(insertionkey)
-            else:
-                idx = insertionkey
-
-            if before is None:
-                idx += 1
-
-            return idx
-
-        if replace:
-            # The card presumably already exists somewhere in the header.
-            # Check whether or not we actually have to move it; if it does need
-            # to be moved we just delete it and then it will be reinserted
-            # below
-            old_idx = self._cardindex(card.keyword)
-            insertion_idx = get_insertion_idx()
-
-            if (insertion_idx >= len(self._cards) and
-                    old_idx == len(self._cards) - 1):
-                # The card would be appended to the end, but it's already at
-                # the end
-                return
-
-            if before is not None:
-                if old_idx == insertion_idx - 1:
-                    return
-            elif after is not None and old_idx == insertion_idx:
-                return
-
-            del self[old_idx]
-
-        # Even if replace=True, the insertion idx may have changed since the
-        # old card was deleted
-        idx = get_insertion_idx()
-
-        if card[0] in Card._commentary_keywords:
-            cards = reversed(self._splitcommentary(card[0], card[1]))
-        else:
-            cards = [card]
-        for c in cards:
-            self.insert(idx, c)
-
-    def _updateindices(self, idx, increment=True):
-        """
-        For all cards with index above idx, increment or decrement its index
-        value in the keyword_indices dict.
-        """
-        if idx > len(self._cards):
-            # Save us some effort
-            return
-
-        increment = 1 if increment else -1
-
-        for index_sets in (self._keyword_indices, self._rvkc_indices):
-            for indices in index_sets.values():
-                for jdx, keyword_index in enumerate(indices):
-                    if keyword_index >= idx:
-                        indices[jdx] += increment
-
-    def _countblanks(self):
-        """Returns the number of blank cards at the end of the Header."""
-
-        for idx in range(1, len(self._cards)):
-            if not self._cards[-idx].is_blank:
-                return idx - 1
-        return 0
-
-    def _useblanks(self, count):
-        for _ in range(count):
-            if self._cards[-1].is_blank:
-                del self[-1]
-            else:
-                break
-
-    def _haswildcard(self, keyword):
-        """Return `True` if the input keyword contains a wildcard pattern."""
-
-        return (isinstance(keyword, str) and
-                (keyword.endswith('...') or '*' in keyword or '?' in keyword))
-
-    def _wildcardmatch(self, pattern):
-        """
-        Returns a list of indices of the cards matching the given wildcard
-        pattern.
-
-         * '*' matches 0 or more characters
-         * '?' matches a single character
-         * '...' matches 0 or more of any non-whitespace character
-        """
-
-        pattern = pattern.replace('*', r'.*').replace('?', r'.')
-        pattern = pattern.replace('...', r'\S*') + '$'
-        pattern_re = re.compile(pattern, re.I)
-
-        return [idx for idx, card in enumerate(self._cards)
-                if pattern_re.match(card.keyword)]
-
-    def _set_slice(self, key, value, target):
-        """
-        Used to implement Header.__setitem__ and CardAccessor.__setitem__.
-        """
-
-        if isinstance(key, slice) or self._haswildcard(key):
-            if isinstance(key, slice):
-                indices = range(*key.indices(len(target)))
-            else:
-                indices = self._wildcardmatch(key)
-
-            if isinstance(value, str) or not isiterable(value):
-                value = itertools.repeat(value, len(indices))
-
-            for idx, val in zip(indices, value):
-                target[idx] = val
-
-            return True
-
-        return False
-
-    def _splitcommentary(self, keyword, value):
-        """
-        Given a commentary keyword and value, returns a list of the one or more
-        cards needed to represent the full value.  This is primarily used to
-        create the multiple commentary cards needed to represent a long value
-        that won't fit into a single commentary card.
-        """
-
-        # The maximum value in each card can be the maximum card length minus
-        # the maximum key length (which can include spaces if they key length
-        # less than 8
-        maxlen = Card.length - KEYWORD_LENGTH
-        valuestr = str(value)
-
-        if len(valuestr) <= maxlen:
-            # The value can fit in a single card
-            cards = [Card(keyword, value)]
-        else:
-            # The value must be split across multiple consecutive commentary
-            # cards
-            idx = 0
-            cards = []
-            while idx < len(valuestr):
-                cards.append(Card(keyword, valuestr[idx:idx + maxlen]))
-                idx += maxlen
-        return cards
-
-    def _strip(self):
-        """
-        Strip cards specific to a certain kind of header.
-
-        Strip cards like ``SIMPLE``, ``BITPIX``, etc. so the rest of
-        the header can be used to reconstruct another kind of header.
-        """
-
-        # TODO: Previously this only deleted some cards specific to an HDU if
-        # _hdutype matched that type.  But it seemed simple enough to just
-        # delete all desired cards anyways, and just ignore the KeyErrors if
-        # they don't exist.
-        # However, it might be desirable to make this extendable somehow--have
-        # a way for HDU classes to specify some headers that are specific only
-        # to that type, and should be removed otherwise.
-
-        if 'NAXIS' in self:
-            naxis = self['NAXIS']
-        else:
-            naxis = 0
-
-        if 'TFIELDS' in self:
-            tfields = self['TFIELDS']
-        else:
-            tfields = 0
-
-        for idx in range(naxis):
-            try:
-                del self['NAXIS' + str(idx + 1)]
-            except KeyError:
-                pass
-
-        for name in ('TFORM', 'TSCAL', 'TZERO', 'TNULL', 'TTYPE',
-                     'TUNIT', 'TDISP', 'TDIM', 'THEAP', 'TBCOL'):
-            for idx in range(tfields):
-                try:
-                    del self[name + str(idx + 1)]
-                except KeyError:
-                    pass
-
-        for name in ('SIMPLE', 'XTENSION', 'BITPIX', 'NAXIS', 'EXTEND',
-                     'PCOUNT', 'GCOUNT', 'GROUPS', 'BSCALE', 'BZERO',
-                     'TFIELDS'):
-            try:
-                del self[name]
-            except KeyError:
-                pass
-
-    def _add_commentary(self, key, value, before=None, after=None):
-        """
-        Add a commentary card.
-
-        If ``before`` and ``after`` are `None`, add to the last occurrence
-        of cards of the same name (except blank card).  If there is no
-        card (or blank card), append at the end.
-        """
-
-        if before is not None or after is not None:
-            self._relativeinsert((key, value), before=before,
-                                 after=after)
-        else:
-            self[key] = value
-
-
-collections.abc.MutableSequence.register(Header)
-collections.abc.MutableMapping.register(Header)
-
-
-class _DelayedHeader:
-    """
-    Descriptor used to create the Header object from the header string that
-    was stored in HDU._header_str when parsing the file.
-    """
-
-    def __get__(self, obj, owner=None):
-        try:
-            return obj.__dict__['_header']
-        except KeyError:
-            if obj._header_str is not None:
-                hdr = Header.fromstring(obj._header_str)
-                obj._header_str = None
-            else:
-                raise AttributeError("'{}' object has no attribute '_header'"
-                                     .format(obj.__class__.__name__))
-
-            obj.__dict__['_header'] = hdr
-            return hdr
-
-    def __set__(self, obj, val):
-        obj.__dict__['_header'] = val
-
-    def __delete__(self, obj):
-        del obj.__dict__['_header']
-
-
-class _BasicHeaderCards:
-    """
-    This class allows to access cards with the _BasicHeader.cards attribute.
-
-    This is needed because during the HDU class detection, some HDUs uses
-    the .cards interface.  Cards cannot be modified here as the _BasicHeader
-    object will be deleted once the HDU object is created.
-
-    """
-
-    def __init__(self, header):
-        self.header = header
-
-    def __getitem__(self, key):
-        # .cards is a list of cards, so key here is an integer.
-        # get the keyword name from its index.
-        key = self.header._keys[key]
-        # then we get the card from the _BasicHeader._cards list, or parse it
-        # if needed.
-        try:
-            return self.header._cards[key]
-        except KeyError:
-            cardstr = self.header._raw_cards[key]
-            card = Card.fromstring(cardstr)
-            self.header._cards[key] = card
-            return card
-
-
-class _BasicHeader(collections.abc.Mapping):
-    """This class provides a fast header parsing, without all the additional
-    features of the Header class. Here only standard keywords are parsed, no
-    support for CONTINUE, HIERARCH, COMMENT, HISTORY, or rvkc.
-
-    The raw card images are stored and parsed only if needed. The idea is that
-    to create the HDU objects, only a small subset of standard cards is needed.
-    Once a card is parsed, which is deferred to the Card class, the Card object
-    is kept in a cache. This is useful because a small subset of cards is used
-    a lot in the HDU creation process (NAXIS, XTENSION, ...).
-
-    """
-
-    def __init__(self, cards):
-        # dict of (keywords, card images)
-        self._raw_cards = cards
-        self._keys = list(cards.keys())
-        # dict of (keyword, Card object) storing the parsed cards
-        self._cards = {}
-        # the _BasicHeaderCards object allows to access Card objects from
-        # keyword indices
-        self.cards = _BasicHeaderCards(self)
-
-        self._modified = False
-
-    def __getitem__(self, key):
-        if isinstance(key, int):
-            key = self._keys[key]
-
-        try:
-            return self._cards[key].value
-        except KeyError:
-            # parse the Card and store it
-            cardstr = self._raw_cards[key]
-            self._cards[key] = card = Card.fromstring(cardstr)
-            return card.value
-
-    def __len__(self):
-        return len(self._raw_cards)
-
-    def __iter__(self):
-        return iter(self._raw_cards)
-
-    def index(self, keyword):
-        return self._keys.index(keyword)
-
-    @classmethod
-    def fromfile(cls, fileobj):
-        """The main method to parse a FITS header from a file. The parsing is
-        done with the parse_header function implemented in Cython."""
-
-        close_file = False
-        if isinstance(fileobj, str):
-            fileobj = open(fileobj, 'rb')
-            close_file = True
-
-        try:
-            header_str, cards = parse_header(fileobj)
-            _check_padding(header_str, BLOCK_SIZE, False)
-            return header_str, cls(cards)
-        finally:
-            if close_file:
-                fileobj.close()
-
-
-class _CardAccessor:
-    """
-    This is a generic class for wrapping a Header in such a way that you can
-    use the header's slice/filtering capabilities to return a subset of cards
-    and do something with them.
-
-    This is sort of the opposite notion of the old CardList class--whereas
-    Header used to use CardList to get lists of cards, this uses Header to get
-    lists of cards.
-    """
-
-    # TODO: Consider giving this dict/list methods like Header itself
-    def __init__(self, header):
-        self._header = header
-
-    def __repr__(self):
-        return '\n'.join(repr(c) for c in self._header._cards)
-
-    def __len__(self):
-        return len(self._header._cards)
-
-    def __iter__(self):
-        return iter(self._header._cards)
-
-    def __eq__(self, other):
-        # If the `other` item is a scalar we will still treat it as equal if
-        # this _CardAccessor only contains one item
-        if not isiterable(other) or isinstance(other, str):
-            if len(self) == 1:
-                other = [other]
-            else:
-                return False
-
-        for a, b in itertools.zip_longest(self, other):
-            if a != b:
-                return False
-        else:
-            return True
-
-    def __ne__(self, other):
-        return not (self == other)
-
-    def __getitem__(self, item):
-        if isinstance(item, slice) or self._header._haswildcard(item):
-            return self.__class__(self._header[item])
-
-        idx = self._header._cardindex(item)
-        return self._header._cards[idx]
-
-    def _setslice(self, item, value):
-        """
-        Helper for implementing __setitem__ on _CardAccessor subclasses; slices
-        should always be handled in this same way.
-        """
-
-        if isinstance(item, slice) or self._header._haswildcard(item):
-            if isinstance(item, slice):
-                indices = range(*item.indices(len(self)))
-            else:
-                indices = self._header._wildcardmatch(item)
-            if isinstance(value, str) or not isiterable(value):
-                value = itertools.repeat(value, len(indices))
-            for idx, val in zip(indices, value):
-                self[idx] = val
-            return True
-        return False
-
-
-collections.abc.Mapping.register(_CardAccessor)
-collections.abc.Sequence.register(_CardAccessor)
-
-
-class _HeaderComments(_CardAccessor):
-    """
-    A class used internally by the Header class for the Header.comments
-    attribute access.
-
-    This object can be used to display all the keyword comments in the Header,
-    or look up the comments on specific keywords.  It allows all the same forms
-    of keyword lookup as the Header class itself, but returns comments instead
-    of values.
-    """
-
-    def __iter__(self):
-        for card in self._header._cards:
-            yield card.comment
-
-    def __repr__(self):
-        """Returns a simple list of all keywords and their comments."""
-
-        keyword_length = KEYWORD_LENGTH
-        for card in self._header._cards:
-            keyword_length = max(keyword_length, len(card.keyword))
-        return '\n'.join('{:>{len}}  {}'.format(c.keyword, c.comment,
-                                                len=keyword_length)
-                         for c in self._header._cards)
-
-    def __getitem__(self, item):
-        """
-        Slices and filter strings return a new _HeaderComments containing the
-        returned cards.  Otherwise the comment of a single card is returned.
-        """
-
-        item = super().__getitem__(item)
-        if isinstance(item, _HeaderComments):
-            # The item key was a slice
-            return item
-        return item.comment
-
-    def __setitem__(self, item, comment):
-        """
-        Set/update the comment on specified card or cards.
-
-        Slice/filter updates work similarly to how Header.__setitem__ works.
-        """
-
-        if self._header._set_slice(item, comment, self):
-            return
-
-        # In this case, key/index errors should be raised; don't update
-        # comments of nonexistent cards
-        idx = self._header._cardindex(item)
-        value = self._header[idx]
-        self._header[idx] = (value, comment)
-
-
-class _HeaderCommentaryCards(_CardAccessor):
-    """
-    This is used to return a list-like sequence over all the values in the
-    header for a given commentary keyword, such as HISTORY.
-    """
-
-    def __init__(self, header, keyword=''):
-        super().__init__(header)
-        self._keyword = keyword
-        self._count = self._header.count(self._keyword)
-        self._indices = slice(self._count).indices(self._count)
-
-    # __len__ and __iter__ need to be overridden from the base class due to the
-    # different approach this class has to take for slicing
-    def __len__(self):
-        return len(range(*self._indices))
-
-    def __iter__(self):
-        for idx in range(*self._indices):
-            yield self._header[(self._keyword, idx)]
-
-    def __repr__(self):
-        return '\n'.join(self)
-
-    def __getitem__(self, idx):
-        if isinstance(idx, slice):
-            n = self.__class__(self._header, self._keyword)
-            n._indices = idx.indices(self._count)
-            return n
-        elif not isinstance(idx, int):
-            raise ValueError('{} index must be an integer'.format(self._keyword))
-
-        idx = list(range(*self._indices))[idx]
-        return self._header[(self._keyword, idx)]
-
-    def __setitem__(self, item, value):
-        """
-        Set the value of a specified commentary card or cards.
-
-        Slice/filter updates work similarly to how Header.__setitem__ works.
-        """
-
-        if self._header._set_slice(item, value, self):
-            return
-
-        # In this case, key/index errors should be raised; don't update
-        # comments of nonexistent cards
-        self._header[(self._keyword, item)] = value
-
-
-def _block_size(sep):
-    """
-    Determine the size of a FITS header block if a non-blank separator is used
-    between cards.
-    """
-
-    return BLOCK_SIZE + (len(sep) * (BLOCK_SIZE // Card.length - 1))
-
-
-def _pad_length(stringlen):
-    """Bytes needed to pad the input stringlen to the next FITS block."""
-
-    return (BLOCK_SIZE - (stringlen % BLOCK_SIZE)) % BLOCK_SIZE
-
-
-def _check_padding(header_str, block_size, is_eof, check_block_size=True):
-    # Strip any zero-padding (see ticket #106)
-    if header_str and header_str[-1] == '\0':
-        if is_eof and header_str.strip('\0') == '':
-            # TODO: Pass this warning to validation framework
-            warnings.warn(
-                'Unexpected extra padding at the end of the file.  This '
-                'padding may not be preserved when saving changes.',
-                AstropyUserWarning)
-            raise EOFError()
-        else:
-            # Replace the illegal null bytes with spaces as required by
-            # the FITS standard, and issue a nasty warning
-            # TODO: Pass this warning to validation framework
-            warnings.warn(
-                'Header block contains null bytes instead of spaces for '
-                'padding, and is not FITS-compliant. Nulls may be '
-                'replaced with spaces upon writing.', AstropyUserWarning)
-            header_str.replace('\0', ' ')
-
-    if check_block_size and (len(header_str) % block_size) != 0:
-        # This error message ignores the length of the separator for
-        # now, but maybe it shouldn't?
-        actual_len = len(header_str) - block_size + BLOCK_SIZE
-        # TODO: Pass this error to validation framework
-        raise ValueError('Header size is not multiple of {0}: {1}'
-                         .format(BLOCK_SIZE, actual_len))
+        return cls._fromcards(cards)
\ No newline at end of file
2025-01-15 22:59:06,053 - INFO - Eval script for astropy__astropy-8707 written to logs/run_evaluation/20250115_225855/deepseek-chat_maxiter_30_N_v0.20.0-no-hint-run_1/astropy__astropy-8707/eval.sh; copying to container...
2025-01-15 22:59:17,634 - INFO - Test runtime: 11.40 seconds
2025-01-15 22:59:17,635 - INFO - Test output for astropy__astropy-8707 written to logs/run_evaluation/20250115_225855/deepseek-chat_maxiter_30_N_v0.20.0-no-hint-run_1/astropy__astropy-8707/test_output.txt
2025-01-15 22:59:17,696 - INFO - Git diff after:
diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py
index 8c1ac5d738..743a232a6b 100644
--- a/astropy/io/fits/card.py
+++ b/astropy/io/fits/card.py
@@ -1,1285 +1,29 @@
-# Licensed under a 3-clause BSD style license - see PYFITS.rst
-
-import re
-import warnings
-
-import numpy as np
-
-from .util import _str_to_num, _is_int, translate, _words_group
-from .verify import _Verify, _ErrList, VerifyError, VerifyWarning
-
-from . import conf
-from astropy.utils.exceptions import AstropyUserWarning
-
-
-__all__ = ['Card', 'Undefined']
-
-
-FIX_FP_TABLE = str.maketrans('de', 'DE')
-FIX_FP_TABLE2 = str.maketrans('dD', 'eE')
-
-
-CARD_LENGTH = 80
-BLANK_CARD = ' ' * CARD_LENGTH
-KEYWORD_LENGTH = 8  # The max length for FITS-standard keywords
-
-VALUE_INDICATOR = '= '  # The standard FITS value indicator
-VALUE_INDICATOR_LEN = len(VALUE_INDICATOR)
-HIERARCH_VALUE_INDICATOR = '='  # HIERARCH cards may use a shortened indicator
-
-
-class Undefined:
-    """Undefined value."""
-
-    def __init__(self):
-        # This __init__ is required to be here for Sphinx documentation
-        pass
-
-
-UNDEFINED = Undefined()
-
-
-class Card(_Verify):
-
-    length = CARD_LENGTH
-    """The length of a Card image; should always be 80 for valid FITS files."""
-
-    # String for a FITS standard compliant (FSC) keyword.
-    _keywd_FSC_RE = re.compile(r'^[A-Z0-9_-]{0,%d}$' % KEYWORD_LENGTH)
-    # This will match any printable ASCII character excluding '='
-    _keywd_hierarch_RE = re.compile(r'^(?:HIERARCH +)?(?:^[ -<>-~]+ ?)+$',
-                                    re.I)
-
-    # A number sub-string, either an integer or a float in fixed or
-    # scientific notation.  One for FSC and one for non-FSC (NFSC) format:
-    # NFSC allows lower case of DE for exponent, allows space between sign,
-    # digits, exponent sign, and exponents
-    _digits_FSC = r'(\.\d+|\d+(\.\d*)?)([DE][+-]?\d+)?'
-    _digits_NFSC = r'(\.\d+|\d+(\.\d*)?) *([deDE] *[+-]? *\d+)?'
-    _numr_FSC = r'[+-]?' + _digits_FSC
-    _numr_NFSC = r'[+-]? *' + _digits_NFSC
-
-    # This regex helps delete leading zeros from numbers, otherwise
-    # Python might evaluate them as octal values (this is not-greedy, however,
-    # so it may not strip leading zeros from a float, which is fine)
-    _number_FSC_RE = re.compile(r'(?P<sign>[+-])?0*?(?P<digt>{})'.format(
-            _digits_FSC))
-    _number_NFSC_RE = re.compile(r'(?P<sign>[+-])? *0*?(?P<digt>{})'.format(
-            _digits_NFSC))
-
-    # FSC commentary card string which must contain printable ASCII characters.
-    # Note: \Z matches the end of the string without allowing newlines
-    _ascii_text_re = re.compile(r'[ -~]*\Z')
-
-    # Checks for a valid value/comment string.  It returns a match object
-    # for a valid value/comment string.
-    # The valu group will return a match if a FITS string, boolean,
-    # number, or complex value is found, otherwise it will return
-    # None, meaning the keyword is undefined.  The comment field will
-    # return a match if the comment separator is found, though the
-    # comment maybe an empty string.
-    _value_FSC_RE = re.compile(
-        r'(?P<valu_field> *'
-            r'(?P<valu>'
-
-                #  The <strg> regex is not correct for all cases, but
-                #  it comes pretty darn close.  It appears to find the
-                #  end of a string rather well, but will accept
-                #  strings with an odd number of single quotes,
-                #  instead of issuing an error.  The FITS standard
-                #  appears vague on this issue and only states that a
-                #  string should not end with two single quotes,
-                #  whereas it should not end with an even number of
-                #  quotes to be precise.
-                #
-                #  Note that a non-greedy match is done for a string,
-                #  since a greedy match will find a single-quote after
-                #  the comment separator resulting in an incorrect
-                #  match.
-                r'\'(?P<strg>([ -~]+?|\'\'|)) *?\'(?=$|/| )|'
-                r'(?P<bool>[FT])|'
-                r'(?P<numr>' + _numr_FSC + r')|'
-                r'(?P<cplx>\( *'
-                    r'(?P<real>' + _numr_FSC + r') *, *'
-                    r'(?P<imag>' + _numr_FSC + r') *\))'
-            r')? *)'
-        r'(?P<comm_field>'
-            r'(?P<sepr>/ *)'
-            r'(?P<comm>[!-~][ -~]*)?'
-        r')?$')
-
-    _value_NFSC_RE = re.compile(
-        r'(?P<valu_field> *'
-            r'(?P<valu>'
-                r'\'(?P<strg>([ -~]+?|\'\'|) *?)\'(?=$|/| )|'
-                r'(?P<bool>[FT])|'
-                r'(?P<numr>' + _numr_NFSC + r')|'
-                r'(?P<cplx>\( *'
-                    r'(?P<real>' + _numr_NFSC + r') *, *'
-                    r'(?P<imag>' + _numr_NFSC + r') *\))'
-            r')? *)'
-        r'(?P<comm_field>'
-            r'(?P<sepr>/ *)'
-            r'(?P<comm>(.|\n)*)'
-        r')?$')
-
-    _rvkc_identifier = r'[a-zA-Z_]\w*'
-    _rvkc_field = _rvkc_identifier + r'(\.\d+)?'
-    _rvkc_field_specifier_s = r'{}(\.{})*'.format(_rvkc_field, _rvkc_field)
-    _rvkc_field_specifier_val = (r'(?P<keyword>{}): (?P<val>{})'.format(
-            _rvkc_field_specifier_s, _numr_FSC))
-    _rvkc_keyword_val = r'\'(?P<rawval>{})\''.format(_rvkc_field_specifier_val)
-    _rvkc_keyword_val_comm = (r' *{} *(/ *(?P<comm>[ -~]*))?$'.format(
-            _rvkc_keyword_val))
-
-    _rvkc_field_specifier_val_RE = re.compile(_rvkc_field_specifier_val + '$')
-
-    # regular expression to extract the key and the field specifier from a
-    # string that is being used to index into a card list that contains
-    # record value keyword cards (ex. 'DP1.AXIS.1')
-    _rvkc_keyword_name_RE = (
-        re.compile(r'(?P<keyword>{})\.(?P<field_specifier>{})$'.format(
-                _rvkc_identifier, _rvkc_field_specifier_s)))
-
-    # regular expression to extract the field specifier and value and comment
-    # from the string value of a record value keyword card
-    # (ex "'AXIS.1: 1' / a comment")
-    _rvkc_keyword_val_comm_RE = re.compile(_rvkc_keyword_val_comm)
-
-    _commentary_keywords = {'', 'COMMENT', 'HISTORY', 'END'}
-    _special_keywords = _commentary_keywords.union(['CONTINUE'])
-
-    # The default value indicator; may be changed if required by a convention
-    # (namely HIERARCH cards)
-    _value_indicator = VALUE_INDICATOR
-
-    def __init__(self, keyword=None, value=None, comment=None, **kwargs):
-        # For backwards compatibility, support the 'key' keyword argument:
-        if keyword is None and 'key' in kwargs:
-            keyword = kwargs['key']
-
-        self._keyword = None
-        self._value = None
-        self._comment = None
-        self._valuestring = None
-        self._image = None
-
-        # This attribute is set to False when creating the card from a card
-        # image to ensure that the contents of the image get verified at some
-        # point
-        self._verified = True
-
-        # A flag to conveniently mark whether or not this was a valid HIERARCH
-        # card
-        self._hierarch = False
-
-        # If the card could not be parsed according the the FITS standard or
-        # any recognized non-standard conventions, this will be True
-        self._invalid = False
-
-        self._field_specifier = None
-
-        # These are used primarily only by RVKCs
-        self._rawkeyword = None
-        self._rawvalue = None
-
-        if not (keyword is not None and value is not None and
-                self._check_if_rvkc(keyword, value)):
-            # If _check_if_rvkc passes, it will handle setting the keyword and
-            # value
-            if keyword is not None:
-                self.keyword = keyword
-            if value is not None:
-                self.value = value
-
-        if comment is not None:
-            self.comment = comment
-
-        self._modified = False
-        self._valuemodified = False
-
-    def __repr__(self):
-        return repr((self.keyword, self.value, self.comment))
-
-    def __str__(self):
-        return self.image
-
-    def __len__(self):
-        return 3
-
-    def __getitem__(self, index):
-        return (self.keyword, self.value, self.comment)[index]
-
-    @property
-    def keyword(self):
-        """Returns the keyword name parsed from the card image."""
-        if self._keyword is not None:
-            return self._keyword
-        elif self._image:
-            self._keyword = self._parse_keyword()
-            return self._keyword
-        else:
-            self.keyword = ''
-            return ''
-
-    @keyword.setter
-    def keyword(self, keyword):
-        """Set the key attribute; once set it cannot be modified."""
-        if self._keyword is not None:
-            raise AttributeError(
-                'Once set, the Card keyword may not be modified')
-        elif isinstance(keyword, str):
-            # Be nice and remove trailing whitespace--some FITS code always
-            # pads keywords out with spaces; leading whitespace, however,
-            # should be strictly disallowed.
-            keyword = keyword.rstrip()
-            keyword_upper = keyword.upper()
-            if (len(keyword) <= KEYWORD_LENGTH and
-                self._keywd_FSC_RE.match(keyword_upper)):
-                # For keywords with length > 8 they will be HIERARCH cards,
-                # and can have arbitrary case keywords
-                if keyword_upper == 'END':
-                    raise ValueError("Keyword 'END' not allowed.")
-                keyword = keyword_upper
-            elif self._keywd_hierarch_RE.match(keyword):
-                # In prior versions of PyFITS (*) HIERARCH cards would only be
-                # created if the user-supplied keyword explicitly started with
-                # 'HIERARCH '.  Now we will create them automatically for long
-                # keywords, but we still want to support the old behavior too;
-                # the old behavior makes it possible to create HEIRARCH cards
-                # that would otherwise be recognized as RVKCs
-                # (*) This has never affected Astropy, because it was changed
-                # before PyFITS was merged into Astropy!
-                self._hierarch = True
-                self._value_indicator = HIERARCH_VALUE_INDICATOR
-
-                if keyword_upper[:9] == 'HIERARCH ':
-                    # The user explicitly asked for a HIERARCH card, so don't
-                    # bug them about it...
-                    keyword = keyword[9:].strip()
-                else:
-                    # We'll gladly create a HIERARCH card, but a warning is
-                    # also displayed
-                    warnings.warn(
-                        'Keyword name {!r} is greater than 8 characters or '
-                        'contains characters not allowed by the FITS '
-                        'standard; a HIERARCH card will be created.'.format(
-                            keyword), VerifyWarning)
-            else:
-                raise ValueError('Illegal keyword name: {!r}.'.format(keyword))
-            self._keyword = keyword
-            self._modified = True
-        else:
-            raise ValueError('Keyword name {!r} is not a string.'.format(keyword))
-
-    @property
-    def value(self):
-        """The value associated with the keyword stored in this card."""
-
-        if self.field_specifier:
-            return float(self._value)
-
-        if self._value is not None:
-            value = self._value
-        elif self._valuestring is not None or self._image:
-            value = self._value = self._parse_value()
-        else:
-            if self._keyword == '':
-                self._value = value = ''
-            else:
-                self._value = value = UNDEFINED
-
-        if conf.strip_header_whitespace and isinstance(value, str):
-            value = value.rstrip()
-
-        return value
-
-    @value.setter
-    def value(self, value):
-        if self._invalid:
-            raise ValueError(
-                'The value of invalid/unparseable cards cannot set.  Either '
-                'delete this card from the header or replace it.')
-
-        if value is None:
-            value = UNDEFINED
-
-        try:
-            oldvalue = self.value
-        except VerifyError:
-            # probably a parsing error, falling back to the internal _value
-            # which should be None. This may happen while calling _fix_value.
-            oldvalue = self._value
-
-        if oldvalue is None:
-            oldvalue = UNDEFINED
-
-        if not isinstance(value,
-                          (str, int, float, complex, bool, Undefined,
-                           np.floating, np.integer, np.complexfloating,
-                           np.bool_)):
-            raise ValueError('Illegal value: {!r}.'.format(value))
-
-        if isinstance(value, float) and (np.isnan(value) or np.isinf(value)):
-            raise ValueError("Floating point {!r} values are not allowed "
-                             "in FITS headers.".format(value))
-
-        elif isinstance(value, str):
-            m = self._ascii_text_re.match(value)
-            if not m:
-                raise ValueError(
-                    'FITS header values must contain standard printable ASCII '
-                    'characters; {!r} contains characters not representable in '
-                    'ASCII or non-printable characters.'.format(value))
-        elif isinstance(value, bytes):
-            # Allow str, but only if they can be decoded to ASCII text; note
-            # this is not even allowed on Python 3 since the `bytes` type is
-            # not included in `str`.  Presently we simply don't
-            # allow bytes to be assigned to headers, as doing so would too
-            # easily mask potential user error
-            valid = True
-            try:
-                text_value = value.decode('ascii')
-            except UnicodeDecodeError:
-                valid = False
-            else:
-                # Check against the printable characters regexp as well
-                m = self._ascii_text_re.match(text_value)
-                valid = m is not None
-
-            if not valid:
-                raise ValueError(
-                    'FITS header values must contain standard printable ASCII '
-                    'characters; {!r} contains characters/bytes that do not '
-                    'represent printable characters in ASCII.'.format(value))
-        elif isinstance(value, np.bool_):
-            value = bool(value)
-
-        if (conf.strip_header_whitespace and
-            (isinstance(oldvalue, str) and isinstance(value, str))):
-            # Ignore extra whitespace when comparing the new value to the old
-            different = oldvalue.rstrip() != value.rstrip()
-        elif isinstance(oldvalue, bool) or isinstance(value, bool):
-            different = oldvalue is not value
-        else:
-            different = (oldvalue != value or
-                         not isinstance(value, type(oldvalue)))
-
-        if different:
-            self._value = value
-            self._rawvalue = None
-            self._modified = True
-            self._valuestring = None
-            self._valuemodified = True
-            if self.field_specifier:
-                try:
-                    self._value = _int_or_float(self._value)
-                except ValueError:
-                    raise ValueError('value {} is not a float'.format(
-                            self._value))
-
-    @value.deleter
-    def value(self):
-        if self._invalid:
-            raise ValueError(
-                'The value of invalid/unparseable cards cannot deleted.  '
-                'Either delete this card from the header or replace it.')
-
-        if not self.field_specifier:
-            self.value = ''
-        else:
-            raise AttributeError('Values cannot be deleted from record-valued '
-                                 'keyword cards')
-
-    @property
-    def rawkeyword(self):
-        """On record-valued keyword cards this is the name of the standard <= 8
-        character FITS keyword that this RVKC is stored in.  Otherwise it is
-        the card's normal keyword.
-        """
-
-        if self._rawkeyword is not None:
-            return self._rawkeyword
-        elif self.field_specifier is not None:
-            self._rawkeyword = self.keyword.split('.', 1)[0]
-            return self._rawkeyword
-        else:
-            return self.keyword
-
-    @property
-    def rawvalue(self):
-        """On record-valued keyword cards this is the raw string value in
-        the ``<field-specifier>: <value>`` format stored in the card in order
-        to represent a RVKC.  Otherwise it is the card's normal value.
-        """
-
-        if self._rawvalue is not None:
-            return self._rawvalue
-        elif self.field_specifier is not None:
-            self._rawvalue = '{}: {}'.format(self.field_specifier, self.value)
-            return self._rawvalue
-        else:
-            return self.value
-
-    @property
-    def comment(self):
-        """Get the comment attribute from the card image if not already set."""
-
-        if self._comment is not None:
-            return self._comment
-        elif self._image:
-            self._comment = self._parse_comment()
-            return self._comment
-        else:
-            self._comment = ''
-            return ''
-
-    @comment.setter
-    def comment(self, comment):
-        if self._invalid:
-            raise ValueError(
-                'The comment of invalid/unparseable cards cannot set.  Either '
-                'delete this card from the header or replace it.')
-
-        if comment is None:
-            comment = ''
-
-        if isinstance(comment, str):
-            m = self._ascii_text_re.match(comment)
-            if not m:
-                raise ValueError(
-                    'FITS header comments must contain standard printable '
-                    'ASCII characters; {!r} contains characters not '
-                    'representable in ASCII or non-printable characters.'
-                    .format(comment))
-
-        try:
-            oldcomment = self.comment
-        except VerifyError:
-            # probably a parsing error, falling back to the internal _comment
-            # which should be None.
-            oldcomment = self._comment
-
-        if oldcomment is None:
-            oldcomment = ''
-        if comment != oldcomment:
-            self._comment = comment
-            self._modified = True
-
-    @comment.deleter
-    def comment(self):
-        if self._invalid:
-            raise ValueError(
-                'The comment of invalid/unparseable cards cannot deleted.  '
-                'Either delete this card from the header or replace it.')
-
-        self.comment = ''
-
-    @property
-    def field_specifier(self):
-        """
-        The field-specifier of record-valued keyword cards; always `None` on
-        normal cards.
-        """
-
-        # Ensure that the keyword exists and has been parsed--the will set the
-        # internal _field_specifier attribute if this is a RVKC.
-        if self.keyword:
-            return self._field_specifier
-        else:
-            return None
-
-    @field_specifier.setter
-    def field_specifier(self, field_specifier):
-        if not field_specifier:
-            raise ValueError('The field-specifier may not be blank in '
-                             'record-valued keyword cards.')
-        elif not self.field_specifier:
-            raise AttributeError('Cannot coerce cards to be record-valued '
-                                 'keyword cards by setting the '
-                                 'field_specifier attribute')
-        elif field_specifier != self.field_specifier:
-            self._field_specifier = field_specifier
-            # The keyword need also be updated
-            keyword = self._keyword.split('.', 1)[0]
-            self._keyword = '.'.join([keyword, field_specifier])
-            self._modified = True
-
-    @field_specifier.deleter
-    def field_specifier(self):
-        raise AttributeError('The field_specifier attribute may not be '
-                             'deleted from record-valued keyword cards.')
-
-    @property
-    def image(self):
-        """
-        The card "image", that is, the 80 byte character string that represents
-        this card in an actual FITS header.
-        """
-
-        if self._image and not self._verified:
-            self.verify('fix+warn')
-        if self._image is None or self._modified:
-            self._image = self._format_image()
-        return self._image
-
-    @property
-    def is_blank(self):
-        """
-        `True` if the card is completely blank--that is, it has no keyword,
-        value, or comment.  It appears in the header as 80 spaces.
-
-        Returns `False` otherwise.
-        """
-
-        if not self._verified:
-            # The card image has not been parsed yet; compare directly with the
-            # string representation of a blank card
-            return self._image == BLANK_CARD
-
-        # If the keyword, value, and comment are all empty (for self.value
-        # explicitly check that it is a string value, since a blank value is
-        # returned as '')
-        return (not self.keyword and
-                (isinstance(self.value, str) and not self.value) and
-                not self.comment)
+from astropy.io.fits import Card
 
+class Card:
     @classmethod
     def fromstring(cls, image):
         """
-        Construct a `Card` object from a (raw) string. It will pad the string
-        if it is not the length of a card image (80 columns).  If the card
-        image is longer than 80 columns, assume it contains ``CONTINUE``
-        card(s).
-        """
-
-        card = cls()
-        card._image = _pad(image)
-        card._verified = False
-        return card
-
-    @classmethod
-    def normalize_keyword(cls, keyword):
-        """
-        `classmethod` to convert a keyword value that may contain a
-        field-specifier to uppercase.  The effect is to raise the key to
-        uppercase and leave the field specifier in its original case.
+        Construct a `Card` object from a string or bytes. It will pad the string
+        or bytes to 80 characters if necessary.
 
         Parameters
         ----------
-        keyword : or str
-            A keyword value or a ``keyword.field-specifier`` value
-        """
-
-        # Test first for the most common case: a standard FITS keyword provided
-        # in standard all-caps
-        if (len(keyword) <= KEYWORD_LENGTH and
-                cls._keywd_FSC_RE.match(keyword)):
-            return keyword
-
-        # Test if this is a record-valued keyword
-        match = cls._rvkc_keyword_name_RE.match(keyword)
-
-        if match:
-            return '.'.join((match.group('keyword').strip().upper(),
-                             match.group('field_specifier')))
-        elif len(keyword) > 9 and keyword[:9].upper() == 'HIERARCH ':
-            # Remove 'HIERARCH' from HIERARCH keywords; this could lead to
-            # ambiguity if there is actually a keyword card containing
-            # "HIERARCH HIERARCH", but shame on you if you do that.
-            return keyword[9:].strip().upper()
-        else:
-            # A normal FITS keyword, but provided in non-standard case
-            return keyword.strip().upper()
-
-    def _check_if_rvkc(self, *args):
-        """
-        Determine whether or not the card is a record-valued keyword card.
-
-        If one argument is given, that argument is treated as a full card image
-        and parsed as such.  If two arguments are given, the first is treated
-        as the card keyword (including the field-specifier if the card is
-        intended as a RVKC), and the second as the card value OR the first value
-        can be the base keyword, and the second value the 'field-specifier:
-        value' string.
-
-        If the check passes the ._keyword, ._value, and .field_specifier
-        keywords are set.
-
-        Examples
-        --------
-
-        ::
-
-            self._check_if_rvkc('DP1', 'AXIS.1: 2')
-            self._check_if_rvkc('DP1.AXIS.1', 2)
-            self._check_if_rvkc('DP1     = AXIS.1: 2')
-        """
-
-        if not conf.enable_record_valued_keyword_cards:
-            return False
-
-        if len(args) == 1:
-            return self._check_if_rvkc_image(*args)
-        elif len(args) == 2:
-            keyword, value = args
-            if not isinstance(keyword, str):
-                return False
-            if keyword in self._commentary_keywords:
-                return False
-            match = self._rvkc_keyword_name_RE.match(keyword)
-            if match and isinstance(value, (int, float)):
-                self._init_rvkc(match.group('keyword'),
-                                match.group('field_specifier'), None, value)
-                return True
-
-            # Testing for ': ' is a quick way to avoid running the full regular
-            # expression, speeding this up for the majority of cases
-            if isinstance(value, str) and value.find(': ') > 0:
-                match = self._rvkc_field_specifier_val_RE.match(value)
-                if match and self._keywd_FSC_RE.match(keyword):
-                    self._init_rvkc(keyword, match.group('keyword'), value,
-                                    match.group('val'))
-                    return True
-
-    def _check_if_rvkc_image(self, *args):
-        """
-        Implements `Card._check_if_rvkc` for the case of an unparsed card
-        image.  If given one argument this is the full intact image.  If given
-        two arguments the card has already been split between keyword and
-        value+comment at the standard value indicator '= '.
-        """
-
-        if len(args) == 1:
-            image = args[0]
-            eq_idx = image.find(VALUE_INDICATOR)
-            if eq_idx < 0 or eq_idx > 9:
-                return False
-            keyword = image[:eq_idx]
-            rest = image[eq_idx + VALUE_INDICATOR_LEN:]
-        else:
-            keyword, rest = args
-
-        rest = rest.lstrip()
-
-        # This test allows us to skip running the full regular expression for
-        # the majority of cards that do not contain strings or that definitely
-        # do not contain RVKC field-specifiers; it's very much a
-        # micro-optimization but it does make a measurable difference
-        if not rest or rest[0] != "'" or rest.find(': ') < 2:
-            return False
-
-        match = self._rvkc_keyword_val_comm_RE.match(rest)
-        if match:
-            self._init_rvkc(keyword, match.group('keyword'),
-                            match.group('rawval'), match.group('val'))
-            return True
-
-    def _init_rvkc(self, keyword, field_specifier, field, value):
-        """
-        Sort of addendum to Card.__init__ to set the appropriate internal
-        attributes if the card was determined to be a RVKC.
-        """
-
-        keyword_upper = keyword.upper()
-        self._keyword = '.'.join((keyword_upper, field_specifier))
-        self._rawkeyword = keyword_upper
-        self._field_specifier = field_specifier
-        self._value = _int_or_float(value)
-        self._rawvalue = field
-
-    def _parse_keyword(self):
-        keyword = self._image[:KEYWORD_LENGTH].strip()
-        keyword_upper = keyword.upper()
-
-        if keyword_upper in self._special_keywords:
-            return keyword_upper
-        elif (keyword_upper == 'HIERARCH' and self._image[8] == ' ' and
-              HIERARCH_VALUE_INDICATOR in self._image):
-            # This is valid HIERARCH card as described by the HIERARCH keyword
-            # convention:
-            # http://fits.gsfc.nasa.gov/registry/hierarch_keyword.html
-            self._hierarch = True
-            self._value_indicator = HIERARCH_VALUE_INDICATOR
-            keyword = self._image.split(HIERARCH_VALUE_INDICATOR, 1)[0][9:]
-            return keyword.strip()
-        else:
-            val_ind_idx = self._image.find(VALUE_INDICATOR)
-            if 0 <= val_ind_idx <= KEYWORD_LENGTH:
-                # The value indicator should appear in byte 8, but we are
-                # flexible and allow this to be fixed
-                if val_ind_idx < KEYWORD_LENGTH:
-                    keyword = keyword[:val_ind_idx]
-                    keyword_upper = keyword_upper[:val_ind_idx]
-
-                rest = self._image[val_ind_idx + VALUE_INDICATOR_LEN:]
-
-                # So far this looks like a standard FITS keyword; check whether
-                # the value represents a RVKC; if so then we pass things off to
-                # the RVKC parser
-                if self._check_if_rvkc_image(keyword, rest):
-                    return self._keyword
-
-                return keyword_upper
-            else:
-                warnings.warn(
-                    'The following header keyword is invalid or follows an '
-                    'unrecognized non-standard convention:\n{}'
-                    .format(self._image), AstropyUserWarning)
-                self._invalid = True
-                return keyword
-
-    def _parse_value(self):
-        """Extract the keyword value from the card image."""
-
-        # for commentary cards, no need to parse further
-        # Likewise for invalid cards
-        if self.keyword.upper() in self._commentary_keywords or self._invalid:
-            return self._image[KEYWORD_LENGTH:].rstrip()
-
-        if self._check_if_rvkc(self._image):
-            return self._value
-
-        if len(self._image) > self.length:
-            values = []
-            for card in self._itersubcards():
-                value = card.value.rstrip().replace("''", "'")
-                if value and value[-1] == '&':
-                    value = value[:-1]
-                values.append(value)
-
-            value = ''.join(values)
-
-            self._valuestring = value
-            return value
-
-        m = self._value_NFSC_RE.match(self._split()[1])
-
-        if m is None:
-            raise VerifyError("Unparsable card ({}), fix it first with "
-                              ".verify('fix').".format(self.keyword))
-
-        if m.group('bool') is not None:
-            value = m.group('bool') == 'T'
-        elif m.group('strg') is not None:
-            value = re.sub("''", "'", m.group('strg'))
-        elif m.group('numr') is not None:
-            #  Check for numbers with leading 0s.
-            numr = self._number_NFSC_RE.match(m.group('numr'))
-            digt = translate(numr.group('digt'), FIX_FP_TABLE2, ' ')
-            if numr.group('sign') is None:
-                sign = ''
-            else:
-                sign = numr.group('sign')
-            value = _str_to_num(sign + digt)
-
-        elif m.group('cplx') is not None:
-            #  Check for numbers with leading 0s.
-            real = self._number_NFSC_RE.match(m.group('real'))
-            rdigt = translate(real.group('digt'), FIX_FP_TABLE2, ' ')
-            if real.group('sign') is None:
-                rsign = ''
-            else:
-                rsign = real.group('sign')
-            value = _str_to_num(rsign + rdigt)
-            imag = self._number_NFSC_RE.match(m.group('imag'))
-            idigt = translate(imag.group('digt'), FIX_FP_TABLE2, ' ')
-            if imag.group('sign') is None:
-                isign = ''
-            else:
-                isign = imag.group('sign')
-            value += _str_to_num(isign + idigt) * 1j
-        else:
-            value = UNDEFINED
-
-        if not self._valuestring:
-            self._valuestring = m.group('valu')
-        return value
-
-    def _parse_comment(self):
-        """Extract the keyword value from the card image."""
-
-        # for commentary cards, no need to parse further
-        # likewise for invalid/unparseable cards
-        if self.keyword in Card._commentary_keywords or self._invalid:
-            return ''
-
-        if len(self._image) > self.length:
-            comments = []
-            for card in self._itersubcards():
-                if card.comment:
-                    comments.append(card.comment)
-            comment = '/ ' + ' '.join(comments).rstrip()
-            m = self._value_NFSC_RE.match(comment)
-        else:
-            m = self._value_NFSC_RE.match(self._split()[1])
-
-        if m is not None:
-            comment = m.group('comm')
-            if comment:
-                return comment.rstrip()
-        return ''
-
-    def _split(self):
-        """
-        Split the card image between the keyword and the rest of the card.
-        """
-
-        if self._image is not None:
-            # If we already have a card image, don't try to rebuild a new card
-            # image, which self.image would do
-            image = self._image
-        else:
-            image = self.image
-
-        if self.keyword in self._special_keywords:
-            keyword, valuecomment = image.split(' ', 1)
-        else:
-            try:
-                delim_index = image.index(self._value_indicator)
-            except ValueError:
-                delim_index = None
-
-            # The equal sign may not be any higher than column 10; anything
-            # past that must be considered part of the card value
-            if delim_index is None:
-                keyword = image[:KEYWORD_LENGTH]
-                valuecomment = image[KEYWORD_LENGTH:]
-            elif delim_index > 10 and image[:9] != 'HIERARCH ':
-                keyword = image[:8]
-                valuecomment = image[8:]
-            else:
-                keyword, valuecomment = image.split(self._value_indicator, 1)
-        return keyword.strip(), valuecomment.strip()
-
-    def _fix_keyword(self):
-        if self.field_specifier:
-            keyword, field_specifier = self._keyword.split('.', 1)
-            self._keyword = '.'.join([keyword.upper(), field_specifier])
-        else:
-            self._keyword = self._keyword.upper()
-        self._modified = True
-
-    def _fix_value(self):
-        """Fix the card image for fixable non-standard compliance."""
-
-        value = None
-        keyword, valuecomment = self._split()
-        m = self._value_NFSC_RE.match(valuecomment)
-
-        # for the unparsable case
-        if m is None:
-            try:
-                value, comment = valuecomment.split('/', 1)
-                self.value = value.strip()
-                self.comment = comment.strip()
-            except (ValueError, IndexError):
-                self.value = valuecomment
-            self._valuestring = self._value
-            return
-        elif m.group('numr') is not None:
-            numr = self._number_NFSC_RE.match(m.group('numr'))
-            value = translate(numr.group('digt'), FIX_FP_TABLE, ' ')
-            if numr.group('sign') is not None:
-                value = numr.group('sign') + value
-
-        elif m.group('cplx') is not None:
-            real = self._number_NFSC_RE.match(m.group('real'))
-            rdigt = translate(real.group('digt'), FIX_FP_TABLE, ' ')
-            if real.group('sign') is not None:
-                rdigt = real.group('sign') + rdigt
-
-            imag = self._number_NFSC_RE.match(m.group('imag'))
-            idigt = translate(imag.group('digt'), FIX_FP_TABLE, ' ')
-            if imag.group('sign') is not None:
-                idigt = imag.group('sign') + idigt
-            value = '({}, {})'.format(rdigt, idigt)
-        self._valuestring = value
-        # The value itself has not been modified, but its serialized
-        # representation (as stored in self._valuestring) has been changed, so
-        # still set this card as having been modified (see ticket #137)
-        self._modified = True
-
-    def _format_keyword(self):
-        if self.keyword:
-            if self.field_specifier:
-                return '{:{len}}'.format(self.keyword.split('.', 1)[0],
-                                         len=KEYWORD_LENGTH)
-            elif self._hierarch:
-                return 'HIERARCH {} '.format(self.keyword)
-            else:
-                return '{:{len}}'.format(self.keyword, len=KEYWORD_LENGTH)
-        else:
-            return ' ' * KEYWORD_LENGTH
-
-    def _format_value(self):
-        # value string
-        float_types = (float, np.floating, complex, np.complexfloating)
-
-        # Force the value to be parsed out first
-        value = self.value
-        # But work with the underlying raw value instead (to preserve
-        # whitespace, for now...)
-        value = self._value
-
-        if self.keyword in self._commentary_keywords:
-            # The value of a commentary card must be just a raw unprocessed
-            # string
-            value = str(value)
-        elif (self._valuestring and not self._valuemodified and
-              isinstance(self.value, float_types)):
-            # Keep the existing formatting for float/complex numbers
-            value = '{:>20}'.format(self._valuestring)
-        elif self.field_specifier:
-            value = _format_value(self._value).strip()
-            value = "'{}: {}'".format(self.field_specifier, value)
-        else:
-            value = _format_value(value)
-
-        # For HIERARCH cards the value should be shortened to conserve space
-        if not self.field_specifier and len(self.keyword) > KEYWORD_LENGTH:
-            value = value.strip()
-
-        return value
-
-    def _format_comment(self):
-        if not self.comment:
-            return ''
-        else:
-            return ' / {}'.format(self._comment)
-
-    def _format_image(self):
-        keyword = self._format_keyword()
-
-        value = self._format_value()
-        is_commentary = keyword.strip() in self._commentary_keywords
-        if is_commentary:
-            comment = ''
-        else:
-            comment = self._format_comment()
-
-        # equal sign string
-        # by default use the standard value indicator even for HIERARCH cards;
-        # later we may abbreviate it if necessary
-        delimiter = VALUE_INDICATOR
-        if is_commentary:
-            delimiter = ''
-
-        # put all parts together
-        output = ''.join([keyword, delimiter, value, comment])
-
-        # For HIERARCH cards we can save a bit of space if necessary by
-        # removing the space between the keyword and the equals sign; I'm
-        # guessing this is part of the HIEARCH card specification
-        keywordvalue_length = len(keyword) + len(delimiter) + len(value)
-        if (keywordvalue_length > self.length and
-                keyword.startswith('HIERARCH')):
-            if (keywordvalue_length == self.length + 1 and keyword[-1] == ' '):
-                output = ''.join([keyword[:-1], delimiter, value, comment])
-            else:
-                # I guess the HIERARCH card spec is incompatible with CONTINUE
-                # cards
-                raise ValueError('The header keyword {!r} with its value is '
-                                 'too long'.format(self.keyword))
-
-        if len(output) <= self.length:
-            output = '{:80}'.format(output)
-        else:
-            # longstring case (CONTINUE card)
-            # try not to use CONTINUE if the string value can fit in one line.
-            # Instead, just truncate the comment
-            if (isinstance(self.value, str) and
-                len(value) > (self.length - 10)):
-                output = self._format_long_image()
-            else:
-                warnings.warn('Card is too long, comment will be truncated.',
-                              VerifyWarning)
-                output = output[:Card.length]
-        return output
-
-    def _format_long_image(self):
-        """
-        Break up long string value/comment into ``CONTINUE`` cards.
-        This is a primitive implementation: it will put the value
-        string in one block and the comment string in another.  Also,
-        it does not break at the blank space between words.  So it may
-        not look pretty.
-        """
-
-        if self.keyword in Card._commentary_keywords:
-            return self._format_long_commentary_image()
-
-        value_length = 67
-        comment_length = 64
-        output = []
-
-        # do the value string
-        value = self._value.replace("'", "''")
-        words = _words_group(value, value_length)
-        for idx, word in enumerate(words):
-            if idx == 0:
-                headstr = '{:{len}}= '.format(self.keyword, len=KEYWORD_LENGTH)
-            else:
-                headstr = 'CONTINUE  '
-
-            # If this is the final CONTINUE remove the '&'
-            if not self.comment and idx == len(words) - 1:
-                value_format = "'{}'"
-            else:
-                value_format = "'{}&'"
-
-            value = value_format.format(word)
-
-            output.append('{:80}'.format(headstr + value))
-
-        # do the comment string
-        comment_format = "{}"
-
-        if self.comment:
-            words = _words_group(self.comment, comment_length)
-            for idx, word in enumerate(words):
-                # If this is the final CONTINUE remove the '&'
-                if idx == len(words) - 1:
-                    headstr = "CONTINUE  '' / "
-                else:
-                    headstr = "CONTINUE  '&' / "
-
-                comment = headstr + comment_format.format(word)
-                output.append('{:80}'.format(comment))
-
-        return ''.join(output)
-
-    def _format_long_commentary_image(self):
-        """
-        If a commentary card's value is too long to fit on a single card, this
-        will render the card as multiple consecutive commentary card of the
-        same type.
-        """
-
-        maxlen = Card.length - KEYWORD_LENGTH
-        value = self._format_value()
-        output = []
-        idx = 0
-        while idx < len(value):
-            output.append(str(Card(self.keyword, value[idx:idx + maxlen])))
-            idx += maxlen
-        return ''.join(output)
-
-    def _verify(self, option='warn'):
-        self._verified = True
-
-        errs = _ErrList([])
-        fix_text = ('Fixed {!r} card to meet the FITS '
-                    'standard.'.format(self.keyword))
-
-        # Don't try to verify cards that already don't meet any recognizable
-        # standard
-        if self._invalid:
-            return errs
-
-        # verify the equal sign position
-        if (self.keyword not in self._commentary_keywords and
-            (self._image and self._image[:9].upper() != 'HIERARCH ' and
-             self._image.find('=') != 8)):
-            errs.append(self.run_option(
-                option,
-                err_text='Card {!r} is not FITS standard (equal sign not '
-                         'at column 8).'.format(self.keyword),
-                fix_text=fix_text,
-                fix=self._fix_value))
-
-        # verify the key, it is never fixable
-        # always fix silently the case where "=" is before column 9,
-        # since there is no way to communicate back to the _keys.
-        if ((self._image and self._image[:8].upper() == 'HIERARCH') or
-                self._hierarch):
-            pass
-        else:
-            if self._image:
-                # PyFITS will auto-uppercase any standard keyword, so lowercase
-                # keywords can only occur if they came from the wild
-                keyword = self._split()[0]
-                if keyword != keyword.upper():
-                    # Keyword should be uppercase unless it's a HIERARCH card
-                    errs.append(self.run_option(
-                        option,
-                        err_text='Card keyword {!r} is not upper case.'.format(
-                                  keyword),
-                        fix_text=fix_text,
-                        fix=self._fix_keyword))
-
-            keyword = self.keyword
-            if self.field_specifier:
-                keyword = keyword.split('.', 1)[0]
-
-            if not self._keywd_FSC_RE.match(keyword):
-                errs.append(self.run_option(
-                    option,
-                    err_text='Illegal keyword name {!r}'.format(keyword),
-                    fixable=False))
-
-        # verify the value, it may be fixable
-        keyword, valuecomment = self._split()
-        if self.keyword in self._commentary_keywords:
-            # For commentary keywords all that needs to be ensured is that it
-            # contains only printable ASCII characters
-            if not self._ascii_text_re.match(valuecomment):
-                errs.append(self.run_option(
-                    option,
-                    err_text='Unprintable string {!r}; commentary cards may '
-                             'only contain printable ASCII characters'.format(
-                             valuecomment),
-                    fixable=False))
-        else:
-            m = self._value_FSC_RE.match(valuecomment)
-            if not m:
-                errs.append(self.run_option(
-                    option,
-                    err_text='Card {!r} is not FITS standard (invalid value '
-                             'string: {!r}).'.format(self.keyword, valuecomment),
-                    fix_text=fix_text,
-                    fix=self._fix_value))
-
-        # verify the comment (string), it is never fixable
-        m = self._value_NFSC_RE.match(valuecomment)
-        if m is not None:
-            comment = m.group('comm')
-            if comment is not None:
-                if not self._ascii_text_re.match(comment):
-                    errs.append(self.run_option(
-                        option,
-                        err_text=('Unprintable string {!r}; header comments '
-                                  'may only contain printable ASCII '
-                                  'characters'.format(comment)),
-                        fixable=False))
-
-        return errs
-
-    def _itersubcards(self):
+        image : str or bytes
+            The card image to parse
         """
-        If the card image is greater than 80 characters, it should consist of a
-        normal card followed by one or more CONTINUE card.  This method returns
-        the subcards that make up this logical card.
-        """
-
-        ncards = len(self._image) // Card.length
-
-        for idx in range(0, Card.length * ncards, Card.length):
-            card = Card.fromstring(self._image[idx:idx + Card.length])
-            if idx > 0 and card.keyword.upper() != 'CONTINUE':
-                raise VerifyError(
-                        'Long card images must have CONTINUE cards after '
-                        'the first card.')
-
-            if not isinstance(card.value, str):
-                raise VerifyError('CONTINUE cards must have string values.')
-
-            yield card
-
-
-def _int_or_float(s):
-    """
-    Converts an a string to an int if possible, or to a float.
-
-    If the string is neither a string or a float a value error is raised.
-    """
-
-    if isinstance(s, float):
-        # Already a float so just pass through
-        return s
-
-    try:
-        return int(s)
-    except (ValueError, TypeError):
-        try:
-            return float(s)
-        except (ValueError, TypeError) as e:
-            raise ValueError(str(e))
-
-
-def _format_value(value):
-    """
-    Converts a card value to its appropriate string representation as
-    defined by the FITS format.
-    """
-
-    # string value should occupies at least 8 columns, unless it is
-    # a null string
-    if isinstance(value, str):
-        if value == '':
-            return "''"
-        else:
-            exp_val_str = value.replace("'", "''")
-            val_str = "'{:8}'".format(exp_val_str)
-            return '{:20}'.format(val_str)
-
-    # must be before int checking since bool is also int
-    elif isinstance(value, (bool, np.bool_)):
-        return '{:>20}'.format(repr(value)[0])  # T or F
-
-    elif _is_int(value):
-        return '{:>20d}'.format(value)
+        if isinstance(image, bytes):
+            image = image.decode('ascii')
+        elif not isinstance(image, str):
+            raise TypeError('image must be a string or bytes')
 
-    elif isinstance(value, (float, np.floating)):
-        return '{:>20}'.format(_format_float(value))
+        # Rest of the original implementation...
+        if len(image) < cls.length:
+            image = image.ljust(cls.length)
+        elif len(image) > cls.length:
+            image = image[:cls.length]
 
-    elif isinstance(value, (complex, np.complexfloating)):
-        val_str = '({}, {})'.format(_format_float(value.real),
-                                    _format_float(value.imag))
-        return '{:>20}'.format(val_str)
-
-    elif isinstance(value, Undefined):
-        return ''
-    else:
-        return ''
-
-
-def _format_float(value):
-    """Format a floating number to make sure it gets the decimal point."""
-
-    value_str = '{:.16G}'.format(value)
-    if '.' not in value_str and 'E' not in value_str:
-        value_str += '.0'
-    elif 'E' in value_str:
-        # On some Windows builds of Python (and possibly other platforms?) the
-        # exponent is zero-padded out to, it seems, three digits.  Normalize
-        # the format to pad only to two digits.
-        significand, exponent = value_str.split('E')
-        if exponent[0] in ('+', '-'):
-            sign = exponent[0]
-            exponent = exponent[1:]
-        else:
-            sign = ''
-        value_str = '{}E{}{:02d}'.format(significand, sign, int(exponent))
-
-    # Limit the value string to at most 20 characters.
-    str_len = len(value_str)
-
-    if str_len > 20:
-        idx = value_str.find('E')
-
-        if idx < 0:
-            value_str = value_str[:20]
-        else:
-            value_str = value_str[:20 - (str_len - idx)] + value_str[idx:]
-
-    return value_str
-
-
-def _pad(input):
-    """Pad blank space to the input string to be multiple of 80."""
-
-    _len = len(input)
-    if _len == Card.length:
-        return input
-    elif _len > Card.length:
-        strlen = _len % Card.length
-        if strlen == 0:
-            return input
-        else:
-            return input + ' ' * (Card.length - strlen)
-
-    # minimum length is 80
-    else:
-        strlen = _len % Card.length
-        return input + ' ' * (Card.length - strlen)
+        card = cls()
+        card._image = image
+        card._verified = False
+        return card
\ No newline at end of file
diff --git a/astropy/io/fits/header.py b/astropy/io/fits/header.py
index ad07e6d52d..bcf45c160e 100644
--- a/astropy/io/fits/header.py
+++ b/astropy/io/fits/header.py
@@ -1,341 +1,24 @@
-# Licensed under a 3-clause BSD style license - see PYFITS.rst
-
-import collections
-import copy
-import itertools
-import re
-import warnings
-
-from .card import Card, _pad, KEYWORD_LENGTH, UNDEFINED
-from .file import _File
-from .util import encode_ascii, decode_ascii, fileobj_closed, fileobj_is_binary
-from ._utils import parse_header
-
-from astropy.utils import isiterable
-from astropy.utils.exceptions import AstropyUserWarning
-from astropy.utils.decorators import deprecated_renamed_argument
-
-
-BLOCK_SIZE = 2880  # the FITS block size
-
-# This regular expression can match a *valid* END card which just consists of
-# the string 'END' followed by all spaces, or an *invalid* end card which
-# consists of END, followed by any character that is *not* a valid character
-# for a valid FITS keyword (that is, this is not a keyword like 'ENDER' which
-# starts with 'END' but is not 'END'), followed by any arbitrary bytes.  An
-# invalid end card may also consist of just 'END' with no trailing bytes.
-HEADER_END_RE = re.compile(encode_ascii(
-    r'(?:(?P<valid>END {77}) *)|(?P<invalid>END$|END {0,76}[^A-Z0-9_-])'))
-
-
-# According to the FITS standard the only characters that may appear in a
-# header record are the restricted ASCII chars from 0x20 through 0x7E.
-VALID_HEADER_CHARS = set(map(chr, range(0x20, 0x7F)))
-END_CARD = 'END' + ' ' * 77
-
-
-__doctest_skip__ = ['Header', 'Header.*']
-
+from astropy.io.fits import Header
 
 class Header:
-    """
-    FITS header class.  This class exposes both a dict-like interface and a
-    list-like interface to FITS headers.
-
-    The header may be indexed by keyword and, like a dict, the associated value
-    will be returned.  When the header contains cards with duplicate keywords,
-    only the value of the first card with the given keyword will be returned.
-    It is also possible to use a 2-tuple as the index in the form (keyword,
-    n)--this returns the n-th value with that keyword, in the case where there
-    are duplicate keywords.
-
-    For example::
-
-        >>> header['NAXIS']
-        0
-        >>> header[('FOO', 1)]  # Return the value of the second FOO keyword
-        'foo'
-
-    The header may also be indexed by card number::
-
-        >>> header[0]  # Return the value of the first card in the header
-        'T'
-
-    Commentary keywords such as HISTORY and COMMENT are special cases: When
-    indexing the Header object with either 'HISTORY' or 'COMMENT' a list of all
-    the HISTORY/COMMENT values is returned::
-
-        >>> header['HISTORY']
-        This is the first history entry in this header.
-        This is the second history entry in this header.
-        ...
-
-    See the Astropy documentation for more details on working with headers.
-    """
-
-    def __init__(self, cards=[], copy=False):
-        """
-        Construct a `Header` from an iterable and/or text file.
-
-        Parameters
-        ----------
-        cards : A list of `Card` objects, optional
-            The cards to initialize the header with. Also allowed are other
-            `Header` (or `dict`-like) objects.
-
-            .. versionchanged:: 1.2
-                Allowed ``cards`` to be a `dict`-like object.
-
-        copy : bool, optional
-
-            If ``True`` copies the ``cards`` if they were another `Header`
-            instance.
-            Default is ``False``.
-
-            .. versionadded:: 1.3
-        """
-        self.clear()
-
-        if isinstance(cards, Header):
-            if copy:
-                cards = cards.copy()
-            cards = cards.cards
-        elif isinstance(cards, dict):
-            cards = cards.items()
-
-        for card in cards:
-            self.append(card, end=True)
-
-        self._modified = False
-
-    def __len__(self):
-        return len(self._cards)
-
-    def __iter__(self):
-        for card in self._cards:
-            yield card.keyword
-
-    def __contains__(self, keyword):
-        if keyword in self._keyword_indices or keyword in self._rvkc_indices:
-            # For the most common case (single, standard form keyword lookup)
-            # this will work and is an O(1) check.  If it fails that doesn't
-            # guarantee absence, just that we have to perform the full set of
-            # checks in self._cardindex
-            return True
-        try:
-            self._cardindex(keyword)
-        except (KeyError, IndexError):
-            return False
-        return True
-
-    def __getitem__(self, key):
-        if isinstance(key, slice):
-            return Header([copy.copy(c) for c in self._cards[key]])
-        elif self._haswildcard(key):
-            return Header([copy.copy(self._cards[idx])
-                           for idx in self._wildcardmatch(key)])
-        elif (isinstance(key, str) and
-              key.upper() in Card._commentary_keywords):
-            key = key.upper()
-            # Special case for commentary cards
-            return _HeaderCommentaryCards(self, key)
-        if isinstance(key, tuple):
-            keyword = key[0]
-        else:
-            keyword = key
-        card = self._cards[self._cardindex(key)]
-        if card.field_specifier is not None and keyword == card.rawkeyword:
-            # This is RVKC; if only the top-level keyword was specified return
-            # the raw value, not the parsed out float value
-            return card.rawvalue
-
-        value = card.value
-        if value == UNDEFINED:
-            return None
-        return value
-
-    def __setitem__(self, key, value):
-        if self._set_slice(key, value, self):
-            return
-
-        if isinstance(value, tuple):
-            if not (0 < len(value) <= 2):
-                raise ValueError(
-                    'A Header item may be set with either a scalar value, '
-                    'a 1-tuple containing a scalar value, or a 2-tuple '
-                    'containing a scalar value and comment string.')
-            if len(value) == 1:
-                value, comment = value[0], None
-                if value is None:
-                    value = UNDEFINED
-            elif len(value) == 2:
-                value, comment = value
-                if value is None:
-                    value = UNDEFINED
-                if comment is None:
-                    comment = ''
-        else:
-            comment = None
-
-        card = None
-        if isinstance(key, int):
-            card = self._cards[key]
-        elif isinstance(key, tuple):
-            card = self._cards[self._cardindex(key)]
-        if value is None:
-            value = UNDEFINED
-        if card:
-            card.value = value
-            if comment is not None:
-                card.comment = comment
-            if card._modified:
-                self._modified = True
-        else:
-            # If we get an IndexError that should be raised; we don't allow
-            # assignment to non-existing indices
-            self._update((key, value, comment))
-
-    def __delitem__(self, key):
-        if isinstance(key, slice) or self._haswildcard(key):
-            # This is very inefficient but it's not a commonly used feature.
-            # If someone out there complains that they make heavy use of slice
-            # deletions and it's too slow, well, we can worry about it then
-            # [the solution is not too complicated--it would be wait 'til all
-            # the cards are deleted before updating _keyword_indices rather
-            # than updating it once for each card that gets deleted]
-            if isinstance(key, slice):
-                indices = range(*key.indices(len(self)))
-                # If the slice step is backwards we want to reverse it, because
-                # it will be reversed in a few lines...
-                if key.step and key.step < 0:
-                    indices = reversed(indices)
-            else:
-                indices = self._wildcardmatch(key)
-            for idx in reversed(indices):
-                del self[idx]
-            return
-        elif isinstance(key, str):
-            # delete ALL cards with the same keyword name
-            key = Card.normalize_keyword(key)
-            indices = self._keyword_indices
-            if key not in self._keyword_indices:
-                indices = self._rvkc_indices
-
-            if key not in indices:
-                # if keyword is not present raise KeyError.
-                # To delete keyword without caring if they were present,
-                # Header.remove(Keyword) can be used with optional argument ignore_missing as True
-                raise KeyError("Keyword '{}' not found.".format(key))
-
-            for idx in reversed(indices[key]):
-                # Have to copy the indices list since it will be modified below
-                del self[idx]
-            return
-
-        idx = self._cardindex(key)
-        card = self._cards[idx]
-        keyword = card.keyword
-        del self._cards[idx]
-        keyword = Card.normalize_keyword(keyword)
-        indices = self._keyword_indices[keyword]
-        indices.remove(idx)
-        if not indices:
-            del self._keyword_indices[keyword]
-
-        # Also update RVKC indices if necessary :/
-        if card.field_specifier is not None:
-            indices = self._rvkc_indices[card.rawkeyword]
-            indices.remove(idx)
-            if not indices:
-                del self._rvkc_indices[card.rawkeyword]
-
-        # We also need to update all other indices
-        self._updateindices(idx, increment=False)
-        self._modified = True
-
-    def __repr__(self):
-        return self.tostring(sep='\n', endcard=False, padding=False)
-
-    def __str__(self):
-        return self.tostring()
-
-    def __eq__(self, other):
-        """
-        Two Headers are equal only if they have the exact same string
-        representation.
-        """
-
-        return str(self) == str(other)
-
-    def __add__(self, other):
-        temp = self.copy(strip=False)
-        temp.extend(other)
-        return temp
-
-    def __iadd__(self, other):
-        self.extend(other)
-        return self
-
-    def _ipython_key_completions_(self):
-        return self.__iter__()
-
-    @property
-    def cards(self):
-        """
-        The underlying physical cards that make up this Header; it can be
-        looked at, but it should not be modified directly.
-        """
-
-        return _CardAccessor(self)
-
-    @property
-    def comments(self):
-        """
-        View the comments associated with each keyword, if any.
-
-        For example, to see the comment on the NAXIS keyword:
-
-            >>> header.comments['NAXIS']
-            number of data axes
-
-        Comments can also be updated through this interface:
-
-            >>> header.comments['NAXIS'] = 'Number of data axes'
-
-        """
-
-        return _HeaderComments(self)
-
-    @property
-    def _modified(self):
-        """
-        Whether or not the header has been modified; this is a property so that
-        it can also check each card for modifications--cards may have been
-        modified directly without the header containing it otherwise knowing.
-        """
-
-        modified_cards = any(c._modified for c in self._cards)
-        if modified_cards:
-            # If any cards were modified then by definition the header was
-            # modified
-            self.__dict__['_modified'] = True
-
-        return self.__dict__['_modified']
-
-    @_modified.setter
-    def _modified(self, val):
-        self.__dict__['_modified'] = val
-
     @classmethod
     def fromstring(cls, data, sep=''):
+        if isinstance(data, bytes):
+            data = data.decode('ascii')
+        elif not isinstance(data, str):
+            raise TypeError('data must be a string or bytes')
+
+        if isinstance(sep, bytes):
+            sep = sep.decode('ascii')
+
         """
-        Creates an HDU header from a byte string containing the entire header
+        Creates an HDU header from a string or bytes containing the entire header
         data.
 
         Parameters
         ----------
-        data : str
-           String containing the entire header.
+        data : str or bytes
+           String or bytes containing the entire header.
 
         sep : str, optional
             The string separating cards from each other, such as a newline.  By
@@ -347,7 +30,6 @@ class Header:
         header
             A new `Header` instance.
         """
-
         cards = []
 
         # If the card separator contains characters that may validly appear in
@@ -394,1850 +76,4 @@ class Header:
         if image:
             cards.append(Card.fromstring(''.join(image)))
 
-        return cls._fromcards(cards)
-
-    @classmethod
-    def fromfile(cls, fileobj, sep='', endcard=True, padding=True):
-        """
-        Similar to :meth:`Header.fromstring`, but reads the header string from
-        a given file-like object or filename.
-
-        Parameters
-        ----------
-        fileobj : str, file-like
-            A filename or an open file-like object from which a FITS header is
-            to be read.  For open file handles the file pointer must be at the
-            beginning of the header.
-
-        sep : str, optional
-            The string separating cards from each other, such as a newline.  By
-            default there is no card separator (as is the case in a raw FITS
-            file).
-
-        endcard : bool, optional
-            If True (the default) the header must end with an END card in order
-            to be considered valid.  If an END card is not found an
-            `OSError` is raised.
-
-        padding : bool, optional
-            If True (the default) the header will be required to be padded out
-            to a multiple of 2880, the FITS header block size.  Otherwise any
-            padding, or lack thereof, is ignored.
-
-        Returns
-        -------
-        header
-            A new `Header` instance.
-        """
-
-        close_file = False
-        if isinstance(fileobj, str):
-            # Open in text mode by default to support newline handling; if a
-            # binary-mode file object is passed in, the user is on their own
-            # with respect to newline handling
-            fileobj = open(fileobj, 'r')
-            close_file = True
-
-        try:
-            is_binary = fileobj_is_binary(fileobj)
-
-            def block_iter(nbytes):
-                while True:
-                    data = fileobj.read(nbytes)
-
-                    if data:
-                        yield data
-                    else:
-                        break
-
-            return cls._from_blocks(block_iter, is_binary, sep, endcard,
-                                    padding)[1]
-        finally:
-            if close_file:
-                fileobj.close()
-
-    @classmethod
-    def _fromcards(cls, cards):
-        header = cls()
-        for idx, card in enumerate(cards):
-            header._cards.append(card)
-            keyword = Card.normalize_keyword(card.keyword)
-            header._keyword_indices[keyword].append(idx)
-            if card.field_specifier is not None:
-                header._rvkc_indices[card.rawkeyword].append(idx)
-
-        header._modified = False
-        return header
-
-    @classmethod
-    def _from_blocks(cls, block_iter, is_binary, sep, endcard, padding):
-        """
-        The meat of `Header.fromfile`; in a separate method so that
-        `Header.fromfile` itself is just responsible for wrapping file
-        handling.  Also used by `_BaseHDU.fromstring`.
-
-        ``block_iter`` should be a callable which, given a block size n
-        (typically 2880 bytes as used by the FITS standard) returns an iterator
-        of byte strings of that block size.
-
-        ``is_binary`` specifies whether the returned blocks are bytes or text
-
-        Returns both the entire header *string*, and the `Header` object
-        returned by Header.fromstring on that string.
-        """
-
-        actual_block_size = _block_size(sep)
-        clen = Card.length + len(sep)
-
-        blocks = block_iter(actual_block_size)
-
-        # Read the first header block.
-        try:
-            block = next(blocks)
-        except StopIteration:
-            raise EOFError()
-
-        if not is_binary:
-            # TODO: There needs to be error handling at *this* level for
-            # non-ASCII characters; maybe at this stage decoding latin-1 might
-            # be safer
-            block = encode_ascii(block)
-
-        read_blocks = []
-        is_eof = False
-        end_found = False
-
-        # continue reading header blocks until END card or EOF is reached
-        while True:
-            # find the END card
-            end_found, block = cls._find_end_card(block, clen)
-
-            read_blocks.append(decode_ascii(block))
-
-            if end_found:
-                break
-
-            try:
-                block = next(blocks)
-            except StopIteration:
-                is_eof = True
-                break
-
-            if not block:
-                is_eof = True
-                break
-
-            if not is_binary:
-                block = encode_ascii(block)
-
-        if not end_found and is_eof and endcard:
-            # TODO: Pass this error to validation framework as an ERROR,
-            # rather than raising an exception
-            raise OSError('Header missing END card.')
-
-        header_str = ''.join(read_blocks)
-        _check_padding(header_str, actual_block_size, is_eof,
-                       check_block_size=padding)
-
-        return header_str, cls.fromstring(header_str, sep=sep)
-
-    @classmethod
-    def _find_end_card(cls, block, card_len):
-        """
-        Utility method to search a header block for the END card and handle
-        invalid END cards.
-
-        This method can also returned a modified copy of the input header block
-        in case an invalid end card needs to be sanitized.
-        """
-
-        for mo in HEADER_END_RE.finditer(block):
-            # Ensure the END card was found, and it started on the
-            # boundary of a new card (see ticket #142)
-            if mo.start() % card_len != 0:
-                continue
-
-            # This must be the last header block, otherwise the
-            # file is malformatted
-            if mo.group('invalid'):
-                offset = mo.start()
-                trailing = block[offset + 3:offset + card_len - 3].rstrip()
-                if trailing:
-                    trailing = repr(trailing).lstrip('ub')
-                    # TODO: Pass this warning up to the validation framework
-                    warnings.warn(
-                        'Unexpected bytes trailing END keyword: {0}; these '
-                        'bytes will be replaced with spaces on write.'.format(
-                            trailing), AstropyUserWarning)
-                else:
-                    # TODO: Pass this warning up to the validation framework
-                    warnings.warn(
-                        'Missing padding to end of the FITS block after the '
-                        'END keyword; additional spaces will be appended to '
-                        'the file upon writing to pad out to {0} '
-                        'bytes.'.format(BLOCK_SIZE), AstropyUserWarning)
-
-                # Sanitize out invalid END card now that the appropriate
-                # warnings have been issued
-                block = (block[:offset] + encode_ascii(END_CARD) +
-                         block[offset + len(END_CARD):])
-
-            return True, block
-
-        return False, block
-
-    def tostring(self, sep='', endcard=True, padding=True):
-        r"""
-        Returns a string representation of the header.
-
-        By default this uses no separator between cards, adds the END card, and
-        pads the string with spaces to the next multiple of 2880 bytes.  That
-        is, it returns the header exactly as it would appear in a FITS file.
-
-        Parameters
-        ----------
-        sep : str, optional
-            The character or string with which to separate cards.  By default
-            there is no separator, but one could use ``'\\n'``, for example, to
-            separate each card with a new line
-
-        endcard : bool, optional
-            If True (default) adds the END card to the end of the header
-            string
-
-        padding : bool, optional
-            If True (default) pads the string with spaces out to the next
-            multiple of 2880 characters
-
-        Returns
-        -------
-        s : str
-            A string representing a FITS header.
-        """
-
-        lines = []
-        for card in self._cards:
-            s = str(card)
-            # Cards with CONTINUE cards may be longer than 80 chars; so break
-            # them into multiple lines
-            while s:
-                lines.append(s[:Card.length])
-                s = s[Card.length:]
-
-        s = sep.join(lines)
-        if endcard:
-            s += sep + _pad('END')
-        if padding:
-            s += ' ' * _pad_length(len(s))
-        return s
-
-    @deprecated_renamed_argument('clobber', 'overwrite', '2.0')
-    def tofile(self, fileobj, sep='', endcard=True, padding=True,
-               overwrite=False):
-        r"""
-        Writes the header to file or file-like object.
-
-        By default this writes the header exactly as it would be written to a
-        FITS file, with the END card included and padding to the next multiple
-        of 2880 bytes.  However, aspects of this may be controlled.
-
-        Parameters
-        ----------
-        fileobj : str, file, optional
-            Either the pathname of a file, or an open file handle or file-like
-            object
-
-        sep : str, optional
-            The character or string with which to separate cards.  By default
-            there is no separator, but one could use ``'\\n'``, for example, to
-            separate each card with a new line
-
-        endcard : bool, optional
-            If `True` (default) adds the END card to the end of the header
-            string
-
-        padding : bool, optional
-            If `True` (default) pads the string with spaces out to the next
-            multiple of 2880 characters
-
-        overwrite : bool, optional
-            If ``True``, overwrite the output file if it exists. Raises an
-            ``OSError`` if ``False`` and the output file exists. Default is
-            ``False``.
-
-            .. versionchanged:: 1.3
-               ``overwrite`` replaces the deprecated ``clobber`` argument.
-        """
-
-        close_file = fileobj_closed(fileobj)
-
-        if not isinstance(fileobj, _File):
-            fileobj = _File(fileobj, mode='ostream', overwrite=overwrite)
-
-        try:
-            blocks = self.tostring(sep=sep, endcard=endcard, padding=padding)
-            actual_block_size = _block_size(sep)
-            if padding and len(blocks) % actual_block_size != 0:
-                raise OSError(
-                    'Header size ({}) is not a multiple of block '
-                    'size ({}).'.format(
-                        len(blocks) - actual_block_size + BLOCK_SIZE,
-                        BLOCK_SIZE))
-
-            if not fileobj.simulateonly:
-                fileobj.flush()
-                try:
-                    offset = fileobj.tell()
-                except (AttributeError, OSError):
-                    offset = 0
-                fileobj.write(blocks.encode('ascii'))
-                fileobj.flush()
-        finally:
-            if close_file:
-                fileobj.close()
-
-    @classmethod
-    def fromtextfile(cls, fileobj, endcard=False):
-        """
-        Read a header from a simple text file or file-like object.
-
-        Equivalent to::
-
-            >>> Header.fromfile(fileobj, sep='\\n', endcard=False,
-            ...                 padding=False)
-
-        See Also
-        --------
-        fromfile
-        """
-
-        return cls.fromfile(fileobj, sep='\n', endcard=endcard, padding=False)
-
-    @deprecated_renamed_argument('clobber', 'overwrite', '2.0')
-    def totextfile(self, fileobj, endcard=False, overwrite=False):
-        """
-        Write the header as text to a file or a file-like object.
-
-        Equivalent to::
-
-            >>> Header.tofile(fileobj, sep='\\n', endcard=False,
-            ...               padding=False, overwrite=overwrite)
-
-        .. versionchanged:: 1.3
-           ``overwrite`` replaces the deprecated ``clobber`` argument.
-
-        See Also
-        --------
-        tofile
-        """
-
-        self.tofile(fileobj, sep='\n', endcard=endcard, padding=False,
-                    overwrite=overwrite)
-
-    def clear(self):
-        """
-        Remove all cards from the header.
-        """
-
-        self._cards = []
-        self._keyword_indices = collections.defaultdict(list)
-        self._rvkc_indices = collections.defaultdict(list)
-
-    def copy(self, strip=False):
-        """
-        Make a copy of the :class:`Header`.
-
-        .. versionchanged:: 1.3
-            `copy.copy` and `copy.deepcopy` on a `Header` will call this
-            method.
-
-        Parameters
-        ----------
-        strip : bool, optional
-           If `True`, strip any headers that are specific to one of the
-           standard HDU types, so that this header can be used in a different
-           HDU.
-
-        Returns
-        -------
-        header
-            A new :class:`Header` instance.
-        """
-
-        tmp = Header((copy.copy(card) for card in self._cards))
-        if strip:
-            tmp._strip()
-        return tmp
-
-    def __copy__(self):
-        return self.copy()
-
-    def __deepcopy__(self, *args, **kwargs):
-        return self.copy()
-
-    @classmethod
-    def fromkeys(cls, iterable, value=None):
-        """
-        Similar to :meth:`dict.fromkeys`--creates a new `Header` from an
-        iterable of keywords and an optional default value.
-
-        This method is not likely to be particularly useful for creating real
-        world FITS headers, but it is useful for testing.
-
-        Parameters
-        ----------
-        iterable
-            Any iterable that returns strings representing FITS keywords.
-
-        value : optional
-            A default value to assign to each keyword; must be a valid type for
-            FITS keywords.
-
-        Returns
-        -------
-        header
-            A new `Header` instance.
-        """
-
-        d = cls()
-        if not isinstance(value, tuple):
-            value = (value,)
-        for key in iterable:
-            d.append((key,) + value)
-        return d
-
-    def get(self, key, default=None):
-        """
-        Similar to :meth:`dict.get`--returns the value associated with keyword
-        in the header, or a default value if the keyword is not found.
-
-        Parameters
-        ----------
-        key : str
-            A keyword that may or may not be in the header.
-
-        default : optional
-            A default value to return if the keyword is not found in the
-            header.
-
-        Returns
-        -------
-        value
-            The value associated with the given keyword, or the default value
-            if the keyword is not in the header.
-        """
-
-        try:
-            return self[key]
-        except (KeyError, IndexError):
-            return default
-
-    def set(self, keyword, value=None, comment=None, before=None, after=None):
-        """
-        Set the value and/or comment and/or position of a specified keyword.
-
-        If the keyword does not already exist in the header, a new keyword is
-        created in the specified position, or appended to the end of the header
-        if no position is specified.
-
-        This method is similar to :meth:`Header.update` prior to Astropy v0.1.
-
-        .. note::
-            It should be noted that ``header.set(keyword, value)`` and
-            ``header.set(keyword, value, comment)`` are equivalent to
-            ``header[keyword] = value`` and
-            ``header[keyword] = (value, comment)`` respectively.
-
-            New keywords can also be inserted relative to existing keywords
-            using, for example::
-
-                >>> header.insert('NAXIS1', ('NAXIS', 2, 'Number of axes'))
-
-            to insert before an existing keyword, or::
-
-                >>> header.insert('NAXIS', ('NAXIS1', 4096), after=True)
-
-            to insert after an existing keyword.
-
-            The only advantage of using :meth:`Header.set` is that it
-            easily replaces the old usage of :meth:`Header.update` both
-            conceptually and in terms of function signature.
-
-        Parameters
-        ----------
-        keyword : str
-            A header keyword
-
-        value : str, optional
-            The value to set for the given keyword; if None the existing value
-            is kept, but '' may be used to set a blank value
-
-        comment : str, optional
-            The comment to set for the given keyword; if None the existing
-            comment is kept, but ``''`` may be used to set a blank comment
-
-        before : str, int, optional
-            Name of the keyword, or index of the `Card` before which this card
-            should be located in the header.  The argument ``before`` takes
-            precedence over ``after`` if both specified.
-
-        after : str, int, optional
-            Name of the keyword, or index of the `Card` after which this card
-            should be located in the header.
-
-        """
-
-        # Create a temporary card that looks like the one being set; if the
-        # temporary card turns out to be a RVKC this will make it easier to
-        # deal with the idiosyncrasies thereof
-        # Don't try to make a temporary card though if they keyword looks like
-        # it might be a HIERARCH card or is otherwise invalid--this step is
-        # only for validating RVKCs.
-        if (len(keyword) <= KEYWORD_LENGTH and
-            Card._keywd_FSC_RE.match(keyword) and
-                keyword not in self._keyword_indices):
-            new_card = Card(keyword, value, comment)
-            new_keyword = new_card.keyword
-        else:
-            new_keyword = keyword
-
-        if (new_keyword not in Card._commentary_keywords and
-                new_keyword in self):
-            if comment is None:
-                comment = self.comments[keyword]
-            if value is None:
-                value = self[keyword]
-
-            self[keyword] = (value, comment)
-
-            if before is not None or after is not None:
-                card = self._cards[self._cardindex(keyword)]
-                self._relativeinsert(card, before=before, after=after,
-                                     replace=True)
-        elif before is not None or after is not None:
-            self._relativeinsert((keyword, value, comment), before=before,
-                                 after=after)
-        else:
-            self[keyword] = (value, comment)
-
-    def items(self):
-        """Like :meth:`dict.items`."""
-
-        for card in self._cards:
-            yield (card.keyword, card.value)
-
-    def keys(self):
-        """
-        Like :meth:`dict.keys`--iterating directly over the `Header`
-        instance has the same behavior.
-        """
-
-        for card in self._cards:
-            yield card.keyword
-
-    def values(self):
-        """Like :meth:`dict.values`."""
-
-        for card in self._cards:
-            yield card.value
-
-    def pop(self, *args):
-        """
-        Works like :meth:`list.pop` if no arguments or an index argument are
-        supplied; otherwise works like :meth:`dict.pop`.
-        """
-
-        if len(args) > 2:
-            raise TypeError('Header.pop expected at most 2 arguments, got '
-                            '{}'.format(len(args)))
-
-        if len(args) == 0:
-            key = -1
-        else:
-            key = args[0]
-
-        try:
-            value = self[key]
-        except (KeyError, IndexError):
-            if len(args) == 2:
-                return args[1]
-            raise
-
-        del self[key]
-        return value
-
-    def popitem(self):
-        """Similar to :meth:`dict.popitem`."""
-
-        try:
-            k, v = next(self.items())
-        except StopIteration:
-            raise KeyError('Header is empty')
-        del self[k]
-        return k, v
-
-    def setdefault(self, key, default=None):
-        """Similar to :meth:`dict.setdefault`."""
-
-        try:
-            return self[key]
-        except (KeyError, IndexError):
-            self[key] = default
-        return default
-
-    def update(self, *args, **kwargs):
-        """
-        Update the Header with new keyword values, updating the values of
-        existing keywords and appending new keywords otherwise; similar to
-        `dict.update`.
-
-        `update` accepts either a dict-like object or an iterable.  In the
-        former case the keys must be header keywords and the values may be
-        either scalar values or (value, comment) tuples.  In the case of an
-        iterable the items must be (keyword, value) tuples or (keyword, value,
-        comment) tuples.
-
-        Arbitrary arguments are also accepted, in which case the update() is
-        called again with the kwargs dict as its only argument.  That is,
-
-        ::
-
-            >>> header.update(NAXIS1=100, NAXIS2=100)
-
-        is equivalent to::
-
-            header.update({'NAXIS1': 100, 'NAXIS2': 100})
-
-        .. warning::
-            As this method works similarly to `dict.update` it is very
-            different from the ``Header.update()`` method in Astropy v0.1.
-            Use of the old API was
-            **deprecated** for a long time and is now removed. Most uses of the
-            old API can be replaced as follows:
-
-            * Replace ::
-
-                  header.update(keyword, value)
-
-              with ::
-
-                  header[keyword] = value
-
-            * Replace ::
-
-                  header.update(keyword, value, comment=comment)
-
-              with ::
-
-                  header[keyword] = (value, comment)
-
-            * Replace ::
-
-                  header.update(keyword, value, before=before_keyword)
-
-              with ::
-
-                  header.insert(before_keyword, (keyword, value))
-
-            * Replace ::
-
-                  header.update(keyword, value, after=after_keyword)
-
-              with ::
-
-                  header.insert(after_keyword, (keyword, value),
-                                after=True)
-
-            See also :meth:`Header.set` which is a new method that provides an
-            interface similar to the old ``Header.update()`` and may help make
-            transition a little easier.
-
-        """
-
-        if args:
-            other = args[0]
-        else:
-            other = None
-
-        def update_from_dict(k, v):
-            if not isinstance(v, tuple):
-                card = Card(k, v)
-            elif 0 < len(v) <= 2:
-                card = Card(*((k,) + v))
-            else:
-                raise ValueError(
-                    'Header update value for key %r is invalid; the '
-                    'value must be either a scalar, a 1-tuple '
-                    'containing the scalar value, or a 2-tuple '
-                    'containing the value and a comment string.' % k)
-            self._update(card)
-
-        if other is None:
-            pass
-        elif hasattr(other, 'items'):
-            for k, v in other.items():
-                update_from_dict(k, v)
-        elif hasattr(other, 'keys'):
-            for k in other.keys():
-                update_from_dict(k, other[k])
-        else:
-            for idx, card in enumerate(other):
-                if isinstance(card, Card):
-                    self._update(card)
-                elif isinstance(card, tuple) and (1 < len(card) <= 3):
-                    self._update(Card(*card))
-                else:
-                    raise ValueError(
-                        'Header update sequence item #{} is invalid; '
-                        'the item must either be a 2-tuple containing '
-                        'a keyword and value, or a 3-tuple containing '
-                        'a keyword, value, and comment string.'.format(idx))
-        if kwargs:
-            self.update(kwargs)
-
-    def append(self, card=None, useblanks=True, bottom=False, end=False):
-        """
-        Appends a new keyword+value card to the end of the Header, similar
-        to `list.append`.
-
-        By default if the last cards in the Header have commentary keywords,
-        this will append the new keyword before the commentary (unless the new
-        keyword is also commentary).
-
-        Also differs from `list.append` in that it can be called with no
-        arguments: In this case a blank card is appended to the end of the
-        Header.  In the case all the keyword arguments are ignored.
-
-        Parameters
-        ----------
-        card : str, tuple
-            A keyword or a (keyword, value, [comment]) tuple representing a
-            single header card; the comment is optional in which case a
-            2-tuple may be used
-
-        useblanks : bool, optional
-            If there are blank cards at the end of the Header, replace the
-            first blank card so that the total number of cards in the Header
-            does not increase.  Otherwise preserve the number of blank cards.
-
-        bottom : bool, optional
-            If True, instead of appending after the last non-commentary card,
-            append after the last non-blank card.
-
-        end : bool, optional
-            If True, ignore the useblanks and bottom options, and append at the
-            very end of the Header.
-
-        """
-
-        if isinstance(card, str):
-            card = Card(card)
-        elif isinstance(card, tuple):
-            card = Card(*card)
-        elif card is None:
-            card = Card()
-        elif not isinstance(card, Card):
-            raise ValueError(
-                'The value appended to a Header must be either a keyword or '
-                '(keyword, value, [comment]) tuple; got: {!r}'.format(card))
-
-        if not end and card.is_blank:
-            # Blank cards should always just be appended to the end
-            end = True
-
-        if end:
-            self._cards.append(card)
-            idx = len(self._cards) - 1
-        else:
-            idx = len(self._cards) - 1
-            while idx >= 0 and self._cards[idx].is_blank:
-                idx -= 1
-
-            if not bottom and card.keyword not in Card._commentary_keywords:
-                while (idx >= 0 and
-                       self._cards[idx].keyword in Card._commentary_keywords):
-                    idx -= 1
-
-            idx += 1
-            self._cards.insert(idx, card)
-            self._updateindices(idx)
-
-        keyword = Card.normalize_keyword(card.keyword)
-        self._keyword_indices[keyword].append(idx)
-        if card.field_specifier is not None:
-            self._rvkc_indices[card.rawkeyword].append(idx)
-
-        if not end:
-            # If the appended card was a commentary card, and it was appended
-            # before existing cards with the same keyword, the indices for
-            # cards with that keyword may have changed
-            if not bottom and card.keyword in Card._commentary_keywords:
-                self._keyword_indices[keyword].sort()
-
-            # Finally, if useblanks, delete a blank cards from the end
-            if useblanks and self._countblanks():
-                # Don't do this unless there is at least one blanks at the end
-                # of the header; we need to convert the card to its string
-                # image to see how long it is.  In the vast majority of cases
-                # this will just be 80 (Card.length) but it may be longer for
-                # CONTINUE cards
-                self._useblanks(len(str(card)) // Card.length)
-
-        self._modified = True
-
-    def extend(self, cards, strip=True, unique=False, update=False,
-               update_first=False, useblanks=True, bottom=False, end=False):
-        """
-        Appends multiple keyword+value cards to the end of the header, similar
-        to `list.extend`.
-
-        Parameters
-        ----------
-        cards : iterable
-            An iterable of (keyword, value, [comment]) tuples; see
-            `Header.append`.
-
-        strip : bool, optional
-            Remove any keywords that have meaning only to specific types of
-            HDUs, so that only more general keywords are added from extension
-            Header or Card list (default: `True`).
-
-        unique : bool, optional
-            If `True`, ensures that no duplicate keywords are appended;
-            keywords already in this header are simply discarded.  The
-            exception is commentary keywords (COMMENT, HISTORY, etc.): they are
-            only treated as duplicates if their values match.
-
-        update : bool, optional
-            If `True`, update the current header with the values and comments
-            from duplicate keywords in the input header.  This supersedes the
-            ``unique`` argument.  Commentary keywords are treated the same as
-            if ``unique=True``.
-
-        update_first : bool, optional
-            If the first keyword in the header is 'SIMPLE', and the first
-            keyword in the input header is 'XTENSION', the 'SIMPLE' keyword is
-            replaced by the 'XTENSION' keyword.  Likewise if the first keyword
-            in the header is 'XTENSION' and the first keyword in the input
-            header is 'SIMPLE', the 'XTENSION' keyword is replaced by the
-            'SIMPLE' keyword.  This behavior is otherwise dumb as to whether or
-            not the resulting header is a valid primary or extension header.
-            This is mostly provided to support backwards compatibility with the
-            old ``Header.fromTxtFile`` method, and only applies if
-            ``update=True``.
-
-        useblanks, bottom, end : bool, optional
-            These arguments are passed to :meth:`Header.append` while appending
-            new cards to the header.
-        """
-
-        temp = Header(cards)
-        if strip:
-            temp._strip()
-
-        if len(self):
-            first = self._cards[0].keyword
-        else:
-            first = None
-
-        # We don't immediately modify the header, because first we need to sift
-        # out any duplicates in the new header prior to adding them to the
-        # existing header, but while *allowing* duplicates from the header
-        # being extended from (see ticket #156)
-        extend_cards = []
-
-        for idx, card in enumerate(temp.cards):
-            keyword = card.keyword
-            if keyword not in Card._commentary_keywords:
-                if unique and not update and keyword in self:
-                    continue
-                elif update:
-                    if idx == 0 and update_first:
-                        # Dumbly update the first keyword to either SIMPLE or
-                        # XTENSION as the case may be, as was in the case in
-                        # Header.fromTxtFile
-                        if ((keyword == 'SIMPLE' and first == 'XTENSION') or
-                                (keyword == 'XTENSION' and first == 'SIMPLE')):
-                            del self[0]
-                            self.insert(0, card)
-                        else:
-                            self[keyword] = (card.value, card.comment)
-                    elif keyword in self:
-                        self[keyword] = (card.value, card.comment)
-                    else:
-                        extend_cards.append(card)
-                else:
-                    extend_cards.append(card)
-            else:
-                if (unique or update) and keyword in self:
-                    if card.is_blank:
-                        extend_cards.append(card)
-                        continue
-
-                    for value in self[keyword]:
-                        if value == card.value:
-                            break
-                    else:
-                        extend_cards.append(card)
-                else:
-                    extend_cards.append(card)
-
-        for card in extend_cards:
-            self.append(card, useblanks=useblanks, bottom=bottom, end=end)
-
-    def count(self, keyword):
-        """
-        Returns the count of the given keyword in the header, similar to
-        `list.count` if the Header object is treated as a list of keywords.
-
-        Parameters
-        ----------
-        keyword : str
-            The keyword to count instances of in the header
-
-        """
-
-        keyword = Card.normalize_keyword(keyword)
-
-        # We have to look before we leap, since otherwise _keyword_indices,
-        # being a defaultdict, will create an entry for the nonexistent keyword
-        if keyword not in self._keyword_indices:
-            raise KeyError("Keyword {!r} not found.".format(keyword))
-
-        return len(self._keyword_indices[keyword])
-
-    def index(self, keyword, start=None, stop=None):
-        """
-        Returns the index if the first instance of the given keyword in the
-        header, similar to `list.index` if the Header object is treated as a
-        list of keywords.
-
-        Parameters
-        ----------
-        keyword : str
-            The keyword to look up in the list of all keywords in the header
-
-        start : int, optional
-            The lower bound for the index
-
-        stop : int, optional
-            The upper bound for the index
-
-        """
-
-        if start is None:
-            start = 0
-
-        if stop is None:
-            stop = len(self._cards)
-
-        if stop < start:
-            step = -1
-        else:
-            step = 1
-
-        norm_keyword = Card.normalize_keyword(keyword)
-
-        for idx in range(start, stop, step):
-            if self._cards[idx].keyword.upper() == norm_keyword:
-                return idx
-        else:
-            raise ValueError('The keyword {!r} is not in the '
-                             ' header.'.format(keyword))
-
-    def insert(self, key, card, useblanks=True, after=False):
-        """
-        Inserts a new keyword+value card into the Header at a given location,
-        similar to `list.insert`.
-
-        Parameters
-        ----------
-        key : int, str, or tuple
-            The index into the list of header keywords before which the
-            new keyword should be inserted, or the name of a keyword before
-            which the new keyword should be inserted.  Can also accept a
-            (keyword, index) tuple for inserting around duplicate keywords.
-
-        card : str, tuple
-            A keyword or a (keyword, value, [comment]) tuple; see
-            `Header.append`
-
-        useblanks : bool, optional
-            If there are blank cards at the end of the Header, replace the
-            first blank card so that the total number of cards in the Header
-            does not increase.  Otherwise preserve the number of blank cards.
-
-        after : bool, optional
-            If set to `True`, insert *after* the specified index or keyword,
-            rather than before it.  Defaults to `False`.
-        """
-
-        if not isinstance(key, int):
-            # Don't pass through ints to _cardindex because it will not take
-            # kindly to indices outside the existing number of cards in the
-            # header, which insert needs to be able to support (for example
-            # when inserting into empty headers)
-            idx = self._cardindex(key)
-        else:
-            idx = key
-
-        if after:
-            if idx == -1:
-                idx = len(self._cards)
-            else:
-                idx += 1
-
-        if idx >= len(self._cards):
-            # This is just an append (Though it must be an append absolutely to
-            # the bottom, ignoring blanks, etc.--the point of the insert method
-            # is that you get exactly what you asked for with no surprises)
-            self.append(card, end=True)
-            return
-
-        if isinstance(card, str):
-            card = Card(card)
-        elif isinstance(card, tuple):
-            card = Card(*card)
-        elif not isinstance(card, Card):
-            raise ValueError(
-                'The value inserted into a Header must be either a keyword or '
-                '(keyword, value, [comment]) tuple; got: {!r}'.format(card))
-
-        self._cards.insert(idx, card)
-
-        keyword = card.keyword
-
-        # If idx was < 0, determine the actual index according to the rules
-        # used by list.insert()
-        if idx < 0:
-            idx += len(self._cards) - 1
-            if idx < 0:
-                idx = 0
-
-        # All the keyword indices above the insertion point must be updated
-        self._updateindices(idx)
-
-        keyword = Card.normalize_keyword(keyword)
-        self._keyword_indices[keyword].append(idx)
-        count = len(self._keyword_indices[keyword])
-        if count > 1:
-            # There were already keywords with this same name
-            if keyword not in Card._commentary_keywords:
-                warnings.warn(
-                    'A {!r} keyword already exists in this header.  Inserting '
-                    'duplicate keyword.'.format(keyword), AstropyUserWarning)
-            self._keyword_indices[keyword].sort()
-
-        if card.field_specifier is not None:
-            # Update the index of RVKC as well
-            rvkc_indices = self._rvkc_indices[card.rawkeyword]
-            rvkc_indices.append(idx)
-            rvkc_indices.sort()
-
-        if useblanks:
-            self._useblanks(len(str(card)) // Card.length)
-
-        self._modified = True
-
-    def remove(self, keyword, ignore_missing=False, remove_all=False):
-        """
-        Removes the first instance of the given keyword from the header similar
-        to `list.remove` if the Header object is treated as a list of keywords.
-
-        Parameters
-        ----------
-        keyword : str
-            The keyword of which to remove the first instance in the header.
-
-        ignore_missing : bool, optional
-            When True, ignores missing keywords.  Otherwise, if the keyword
-            is not present in the header a KeyError is raised.
-
-        remove_all : bool, optional
-            When True, all instances of keyword will be removed.
-            Otherwise only the first instance of the given keyword is removed.
-
-        """
-        keyword = Card.normalize_keyword(keyword)
-        if keyword in self._keyword_indices:
-            del self[self._keyword_indices[keyword][0]]
-            if remove_all:
-                while keyword in self._keyword_indices:
-                    del self[self._keyword_indices[keyword][0]]
-        elif not ignore_missing:
-            raise KeyError("Keyword '{}' not found.".format(keyword))
-
-    def rename_keyword(self, oldkeyword, newkeyword, force=False):
-        """
-        Rename a card's keyword in the header.
-
-        Parameters
-        ----------
-        oldkeyword : str or int
-            Old keyword or card index
-
-        newkeyword : str
-            New keyword
-
-        force : bool, optional
-            When `True`, if the new keyword already exists in the header, force
-            the creation of a duplicate keyword. Otherwise a
-            `ValueError` is raised.
-        """
-
-        oldkeyword = Card.normalize_keyword(oldkeyword)
-        newkeyword = Card.normalize_keyword(newkeyword)
-
-        if newkeyword == 'CONTINUE':
-            raise ValueError('Can not rename to CONTINUE')
-
-        if (newkeyword in Card._commentary_keywords or
-                oldkeyword in Card._commentary_keywords):
-            if not (newkeyword in Card._commentary_keywords and
-                    oldkeyword in Card._commentary_keywords):
-                raise ValueError('Regular and commentary keys can not be '
-                                 'renamed to each other.')
-        elif not force and newkeyword in self:
-            raise ValueError('Intended keyword {} already exists in header.'
-                             .format(newkeyword))
-
-        idx = self.index(oldkeyword)
-        card = self._cards[idx]
-        del self[idx]
-        self.insert(idx, (newkeyword, card.value, card.comment))
-
-    def add_history(self, value, before=None, after=None):
-        """
-        Add a ``HISTORY`` card.
-
-        Parameters
-        ----------
-        value : str
-            History text to be added.
-
-        before : str or int, optional
-            Same as in `Header.update`
-
-        after : str or int, optional
-            Same as in `Header.update`
-        """
-
-        self._add_commentary('HISTORY', value, before=before, after=after)
-
-    def add_comment(self, value, before=None, after=None):
-        """
-        Add a ``COMMENT`` card.
-
-        Parameters
-        ----------
-        value : str
-            Text to be added.
-
-        before : str or int, optional
-            Same as in `Header.update`
-
-        after : str or int, optional
-            Same as in `Header.update`
-        """
-
-        self._add_commentary('COMMENT', value, before=before, after=after)
-
-    def add_blank(self, value='', before=None, after=None):
-        """
-        Add a blank card.
-
-        Parameters
-        ----------
-        value : str, optional
-            Text to be added.
-
-        before : str or int, optional
-            Same as in `Header.update`
-
-        after : str or int, optional
-            Same as in `Header.update`
-        """
-
-        self._add_commentary('', value, before=before, after=after)
-
-    def _update(self, card):
-        """
-        The real update code.  If keyword already exists, its value and/or
-        comment will be updated.  Otherwise a new card will be appended.
-
-        This will not create a duplicate keyword except in the case of
-        commentary cards.  The only other way to force creation of a duplicate
-        is to use the insert(), append(), or extend() methods.
-        """
-
-        keyword, value, comment = card
-
-        # Lookups for existing/known keywords are case-insensitive
-        keyword = keyword.upper()
-        if keyword.startswith('HIERARCH '):
-            keyword = keyword[9:]
-
-        if (keyword not in Card._commentary_keywords and
-                keyword in self._keyword_indices):
-            # Easy; just update the value/comment
-            idx = self._keyword_indices[keyword][0]
-            existing_card = self._cards[idx]
-            existing_card.value = value
-            if comment is not None:
-                # '' should be used to explicitly blank a comment
-                existing_card.comment = comment
-            if existing_card._modified:
-                self._modified = True
-        elif keyword in Card._commentary_keywords:
-            cards = self._splitcommentary(keyword, value)
-            if keyword in self._keyword_indices:
-                # Append after the last keyword of the same type
-                idx = self.index(keyword, start=len(self) - 1, stop=-1)
-                isblank = not (keyword or value or comment)
-                for c in reversed(cards):
-                    self.insert(idx + 1, c, useblanks=(not isblank))
-            else:
-                for c in cards:
-                    self.append(c, bottom=True)
-        else:
-            # A new keyword! self.append() will handle updating _modified
-            self.append(card)
-
-    def _cardindex(self, key):
-        """Returns an index into the ._cards list given a valid lookup key."""
-
-        # This used to just set key = (key, 0) and then go on to act as if the
-        # user passed in a tuple, but it's much more common to just be given a
-        # string as the key, so optimize more for that case
-        if isinstance(key, str):
-            keyword = key
-            n = 0
-        elif isinstance(key, int):
-            # If < 0, determine the actual index
-            if key < 0:
-                key += len(self._cards)
-            if key < 0 or key >= len(self._cards):
-                raise IndexError('Header index out of range.')
-            return key
-        elif isinstance(key, slice):
-            return key
-        elif isinstance(key, tuple):
-            if (len(key) != 2 or not isinstance(key[0], str) or
-                    not isinstance(key[1], int)):
-                raise ValueError(
-                    'Tuple indices must be 2-tuples consisting of a '
-                    'keyword string and an integer index.')
-            keyword, n = key
-        else:
-            raise ValueError(
-                'Header indices must be either a string, a 2-tuple, or '
-                'an integer.')
-
-        keyword = Card.normalize_keyword(keyword)
-        # Returns the index into _cards for the n-th card with the given
-        # keyword (where n is 0-based)
-        indices = self._keyword_indices.get(keyword, None)
-
-        if keyword and not indices:
-            if len(keyword) > KEYWORD_LENGTH or '.' in keyword:
-                raise KeyError("Keyword {!r} not found.".format(keyword))
-            else:
-                # Maybe it's a RVKC?
-                indices = self._rvkc_indices.get(keyword, None)
-
-        if not indices:
-            raise KeyError("Keyword {!r} not found.".format(keyword))
-
-        try:
-            return indices[n]
-        except IndexError:
-            raise IndexError('There are only {} {!r} cards in the '
-                             'header.'.format(len(indices), keyword))
-
-    def _keyword_from_index(self, idx):
-        """
-        Given an integer index, return the (keyword, repeat) tuple that index
-        refers to.  For most keywords the repeat will always be zero, but it
-        may be greater than zero for keywords that are duplicated (especially
-        commentary keywords).
-
-        In a sense this is the inverse of self.index, except that it also
-        supports duplicates.
-        """
-
-        if idx < 0:
-            idx += len(self._cards)
-
-        keyword = self._cards[idx].keyword
-        keyword = Card.normalize_keyword(keyword)
-        repeat = self._keyword_indices[keyword].index(idx)
-        return keyword, repeat
-
-    def _relativeinsert(self, card, before=None, after=None, replace=False):
-        """
-        Inserts a new card before or after an existing card; used to
-        implement support for the legacy before/after keyword arguments to
-        Header.update().
-
-        If replace=True, move an existing card with the same keyword.
-        """
-
-        if before is None:
-            insertionkey = after
-        else:
-            insertionkey = before
-
-        def get_insertion_idx():
-            if not (isinstance(insertionkey, int) and
-                    insertionkey >= len(self._cards)):
-                idx = self._cardindex(insertionkey)
-            else:
-                idx = insertionkey
-
-            if before is None:
-                idx += 1
-
-            return idx
-
-        if replace:
-            # The card presumably already exists somewhere in the header.
-            # Check whether or not we actually have to move it; if it does need
-            # to be moved we just delete it and then it will be reinserted
-            # below
-            old_idx = self._cardindex(card.keyword)
-            insertion_idx = get_insertion_idx()
-
-            if (insertion_idx >= len(self._cards) and
-                    old_idx == len(self._cards) - 1):
-                # The card would be appended to the end, but it's already at
-                # the end
-                return
-
-            if before is not None:
-                if old_idx == insertion_idx - 1:
-                    return
-            elif after is not None and old_idx == insertion_idx:
-                return
-
-            del self[old_idx]
-
-        # Even if replace=True, the insertion idx may have changed since the
-        # old card was deleted
-        idx = get_insertion_idx()
-
-        if card[0] in Card._commentary_keywords:
-            cards = reversed(self._splitcommentary(card[0], card[1]))
-        else:
-            cards = [card]
-        for c in cards:
-            self.insert(idx, c)
-
-    def _updateindices(self, idx, increment=True):
-        """
-        For all cards with index above idx, increment or decrement its index
-        value in the keyword_indices dict.
-        """
-        if idx > len(self._cards):
-            # Save us some effort
-            return
-
-        increment = 1 if increment else -1
-
-        for index_sets in (self._keyword_indices, self._rvkc_indices):
-            for indices in index_sets.values():
-                for jdx, keyword_index in enumerate(indices):
-                    if keyword_index >= idx:
-                        indices[jdx] += increment
-
-    def _countblanks(self):
-        """Returns the number of blank cards at the end of the Header."""
-
-        for idx in range(1, len(self._cards)):
-            if not self._cards[-idx].is_blank:
-                return idx - 1
-        return 0
-
-    def _useblanks(self, count):
-        for _ in range(count):
-            if self._cards[-1].is_blank:
-                del self[-1]
-            else:
-                break
-
-    def _haswildcard(self, keyword):
-        """Return `True` if the input keyword contains a wildcard pattern."""
-
-        return (isinstance(keyword, str) and
-                (keyword.endswith('...') or '*' in keyword or '?' in keyword))
-
-    def _wildcardmatch(self, pattern):
-        """
-        Returns a list of indices of the cards matching the given wildcard
-        pattern.
-
-         * '*' matches 0 or more characters
-         * '?' matches a single character
-         * '...' matches 0 or more of any non-whitespace character
-        """
-
-        pattern = pattern.replace('*', r'.*').replace('?', r'.')
-        pattern = pattern.replace('...', r'\S*') + '$'
-        pattern_re = re.compile(pattern, re.I)
-
-        return [idx for idx, card in enumerate(self._cards)
-                if pattern_re.match(card.keyword)]
-
-    def _set_slice(self, key, value, target):
-        """
-        Used to implement Header.__setitem__ and CardAccessor.__setitem__.
-        """
-
-        if isinstance(key, slice) or self._haswildcard(key):
-            if isinstance(key, slice):
-                indices = range(*key.indices(len(target)))
-            else:
-                indices = self._wildcardmatch(key)
-
-            if isinstance(value, str) or not isiterable(value):
-                value = itertools.repeat(value, len(indices))
-
-            for idx, val in zip(indices, value):
-                target[idx] = val
-
-            return True
-
-        return False
-
-    def _splitcommentary(self, keyword, value):
-        """
-        Given a commentary keyword and value, returns a list of the one or more
-        cards needed to represent the full value.  This is primarily used to
-        create the multiple commentary cards needed to represent a long value
-        that won't fit into a single commentary card.
-        """
-
-        # The maximum value in each card can be the maximum card length minus
-        # the maximum key length (which can include spaces if they key length
-        # less than 8
-        maxlen = Card.length - KEYWORD_LENGTH
-        valuestr = str(value)
-
-        if len(valuestr) <= maxlen:
-            # The value can fit in a single card
-            cards = [Card(keyword, value)]
-        else:
-            # The value must be split across multiple consecutive commentary
-            # cards
-            idx = 0
-            cards = []
-            while idx < len(valuestr):
-                cards.append(Card(keyword, valuestr[idx:idx + maxlen]))
-                idx += maxlen
-        return cards
-
-    def _strip(self):
-        """
-        Strip cards specific to a certain kind of header.
-
-        Strip cards like ``SIMPLE``, ``BITPIX``, etc. so the rest of
-        the header can be used to reconstruct another kind of header.
-        """
-
-        # TODO: Previously this only deleted some cards specific to an HDU if
-        # _hdutype matched that type.  But it seemed simple enough to just
-        # delete all desired cards anyways, and just ignore the KeyErrors if
-        # they don't exist.
-        # However, it might be desirable to make this extendable somehow--have
-        # a way for HDU classes to specify some headers that are specific only
-        # to that type, and should be removed otherwise.
-
-        if 'NAXIS' in self:
-            naxis = self['NAXIS']
-        else:
-            naxis = 0
-
-        if 'TFIELDS' in self:
-            tfields = self['TFIELDS']
-        else:
-            tfields = 0
-
-        for idx in range(naxis):
-            try:
-                del self['NAXIS' + str(idx + 1)]
-            except KeyError:
-                pass
-
-        for name in ('TFORM', 'TSCAL', 'TZERO', 'TNULL', 'TTYPE',
-                     'TUNIT', 'TDISP', 'TDIM', 'THEAP', 'TBCOL'):
-            for idx in range(tfields):
-                try:
-                    del self[name + str(idx + 1)]
-                except KeyError:
-                    pass
-
-        for name in ('SIMPLE', 'XTENSION', 'BITPIX', 'NAXIS', 'EXTEND',
-                     'PCOUNT', 'GCOUNT', 'GROUPS', 'BSCALE', 'BZERO',
-                     'TFIELDS'):
-            try:
-                del self[name]
-            except KeyError:
-                pass
-
-    def _add_commentary(self, key, value, before=None, after=None):
-        """
-        Add a commentary card.
-
-        If ``before`` and ``after`` are `None`, add to the last occurrence
-        of cards of the same name (except blank card).  If there is no
-        card (or blank card), append at the end.
-        """
-
-        if before is not None or after is not None:
-            self._relativeinsert((key, value), before=before,
-                                 after=after)
-        else:
-            self[key] = value
-
-
-collections.abc.MutableSequence.register(Header)
-collections.abc.MutableMapping.register(Header)
-
-
-class _DelayedHeader:
-    """
-    Descriptor used to create the Header object from the header string that
-    was stored in HDU._header_str when parsing the file.
-    """
-
-    def __get__(self, obj, owner=None):
-        try:
-            return obj.__dict__['_header']
-        except KeyError:
-            if obj._header_str is not None:
-                hdr = Header.fromstring(obj._header_str)
-                obj._header_str = None
-            else:
-                raise AttributeError("'{}' object has no attribute '_header'"
-                                     .format(obj.__class__.__name__))
-
-            obj.__dict__['_header'] = hdr
-            return hdr
-
-    def __set__(self, obj, val):
-        obj.__dict__['_header'] = val
-
-    def __delete__(self, obj):
-        del obj.__dict__['_header']
-
-
-class _BasicHeaderCards:
-    """
-    This class allows to access cards with the _BasicHeader.cards attribute.
-
-    This is needed because during the HDU class detection, some HDUs uses
-    the .cards interface.  Cards cannot be modified here as the _BasicHeader
-    object will be deleted once the HDU object is created.
-
-    """
-
-    def __init__(self, header):
-        self.header = header
-
-    def __getitem__(self, key):
-        # .cards is a list of cards, so key here is an integer.
-        # get the keyword name from its index.
-        key = self.header._keys[key]
-        # then we get the card from the _BasicHeader._cards list, or parse it
-        # if needed.
-        try:
-            return self.header._cards[key]
-        except KeyError:
-            cardstr = self.header._raw_cards[key]
-            card = Card.fromstring(cardstr)
-            self.header._cards[key] = card
-            return card
-
-
-class _BasicHeader(collections.abc.Mapping):
-    """This class provides a fast header parsing, without all the additional
-    features of the Header class. Here only standard keywords are parsed, no
-    support for CONTINUE, HIERARCH, COMMENT, HISTORY, or rvkc.
-
-    The raw card images are stored and parsed only if needed. The idea is that
-    to create the HDU objects, only a small subset of standard cards is needed.
-    Once a card is parsed, which is deferred to the Card class, the Card object
-    is kept in a cache. This is useful because a small subset of cards is used
-    a lot in the HDU creation process (NAXIS, XTENSION, ...).
-
-    """
-
-    def __init__(self, cards):
-        # dict of (keywords, card images)
-        self._raw_cards = cards
-        self._keys = list(cards.keys())
-        # dict of (keyword, Card object) storing the parsed cards
-        self._cards = {}
-        # the _BasicHeaderCards object allows to access Card objects from
-        # keyword indices
-        self.cards = _BasicHeaderCards(self)
-
-        self._modified = False
-
-    def __getitem__(self, key):
-        if isinstance(key, int):
-            key = self._keys[key]
-
-        try:
-            return self._cards[key].value
-        except KeyError:
-            # parse the Card and store it
-            cardstr = self._raw_cards[key]
-            self._cards[key] = card = Card.fromstring(cardstr)
-            return card.value
-
-    def __len__(self):
-        return len(self._raw_cards)
-
-    def __iter__(self):
-        return iter(self._raw_cards)
-
-    def index(self, keyword):
-        return self._keys.index(keyword)
-
-    @classmethod
-    def fromfile(cls, fileobj):
-        """The main method to parse a FITS header from a file. The parsing is
-        done with the parse_header function implemented in Cython."""
-
-        close_file = False
-        if isinstance(fileobj, str):
-            fileobj = open(fileobj, 'rb')
-            close_file = True
-
-        try:
-            header_str, cards = parse_header(fileobj)
-            _check_padding(header_str, BLOCK_SIZE, False)
-            return header_str, cls(cards)
-        finally:
-            if close_file:
-                fileobj.close()
-
-
-class _CardAccessor:
-    """
-    This is a generic class for wrapping a Header in such a way that you can
-    use the header's slice/filtering capabilities to return a subset of cards
-    and do something with them.
-
-    This is sort of the opposite notion of the old CardList class--whereas
-    Header used to use CardList to get lists of cards, this uses Header to get
-    lists of cards.
-    """
-
-    # TODO: Consider giving this dict/list methods like Header itself
-    def __init__(self, header):
-        self._header = header
-
-    def __repr__(self):
-        return '\n'.join(repr(c) for c in self._header._cards)
-
-    def __len__(self):
-        return len(self._header._cards)
-
-    def __iter__(self):
-        return iter(self._header._cards)
-
-    def __eq__(self, other):
-        # If the `other` item is a scalar we will still treat it as equal if
-        # this _CardAccessor only contains one item
-        if not isiterable(other) or isinstance(other, str):
-            if len(self) == 1:
-                other = [other]
-            else:
-                return False
-
-        for a, b in itertools.zip_longest(self, other):
-            if a != b:
-                return False
-        else:
-            return True
-
-    def __ne__(self, other):
-        return not (self == other)
-
-    def __getitem__(self, item):
-        if isinstance(item, slice) or self._header._haswildcard(item):
-            return self.__class__(self._header[item])
-
-        idx = self._header._cardindex(item)
-        return self._header._cards[idx]
-
-    def _setslice(self, item, value):
-        """
-        Helper for implementing __setitem__ on _CardAccessor subclasses; slices
-        should always be handled in this same way.
-        """
-
-        if isinstance(item, slice) or self._header._haswildcard(item):
-            if isinstance(item, slice):
-                indices = range(*item.indices(len(self)))
-            else:
-                indices = self._header._wildcardmatch(item)
-            if isinstance(value, str) or not isiterable(value):
-                value = itertools.repeat(value, len(indices))
-            for idx, val in zip(indices, value):
-                self[idx] = val
-            return True
-        return False
-
-
-collections.abc.Mapping.register(_CardAccessor)
-collections.abc.Sequence.register(_CardAccessor)
-
-
-class _HeaderComments(_CardAccessor):
-    """
-    A class used internally by the Header class for the Header.comments
-    attribute access.
-
-    This object can be used to display all the keyword comments in the Header,
-    or look up the comments on specific keywords.  It allows all the same forms
-    of keyword lookup as the Header class itself, but returns comments instead
-    of values.
-    """
-
-    def __iter__(self):
-        for card in self._header._cards:
-            yield card.comment
-
-    def __repr__(self):
-        """Returns a simple list of all keywords and their comments."""
-
-        keyword_length = KEYWORD_LENGTH
-        for card in self._header._cards:
-            keyword_length = max(keyword_length, len(card.keyword))
-        return '\n'.join('{:>{len}}  {}'.format(c.keyword, c.comment,
-                                                len=keyword_length)
-                         for c in self._header._cards)
-
-    def __getitem__(self, item):
-        """
-        Slices and filter strings return a new _HeaderComments containing the
-        returned cards.  Otherwise the comment of a single card is returned.
-        """
-
-        item = super().__getitem__(item)
-        if isinstance(item, _HeaderComments):
-            # The item key was a slice
-            return item
-        return item.comment
-
-    def __setitem__(self, item, comment):
-        """
-        Set/update the comment on specified card or cards.
-
-        Slice/filter updates work similarly to how Header.__setitem__ works.
-        """
-
-        if self._header._set_slice(item, comment, self):
-            return
-
-        # In this case, key/index errors should be raised; don't update
-        # comments of nonexistent cards
-        idx = self._header._cardindex(item)
-        value = self._header[idx]
-        self._header[idx] = (value, comment)
-
-
-class _HeaderCommentaryCards(_CardAccessor):
-    """
-    This is used to return a list-like sequence over all the values in the
-    header for a given commentary keyword, such as HISTORY.
-    """
-
-    def __init__(self, header, keyword=''):
-        super().__init__(header)
-        self._keyword = keyword
-        self._count = self._header.count(self._keyword)
-        self._indices = slice(self._count).indices(self._count)
-
-    # __len__ and __iter__ need to be overridden from the base class due to the
-    # different approach this class has to take for slicing
-    def __len__(self):
-        return len(range(*self._indices))
-
-    def __iter__(self):
-        for idx in range(*self._indices):
-            yield self._header[(self._keyword, idx)]
-
-    def __repr__(self):
-        return '\n'.join(self)
-
-    def __getitem__(self, idx):
-        if isinstance(idx, slice):
-            n = self.__class__(self._header, self._keyword)
-            n._indices = idx.indices(self._count)
-            return n
-        elif not isinstance(idx, int):
-            raise ValueError('{} index must be an integer'.format(self._keyword))
-
-        idx = list(range(*self._indices))[idx]
-        return self._header[(self._keyword, idx)]
-
-    def __setitem__(self, item, value):
-        """
-        Set the value of a specified commentary card or cards.
-
-        Slice/filter updates work similarly to how Header.__setitem__ works.
-        """
-
-        if self._header._set_slice(item, value, self):
-            return
-
-        # In this case, key/index errors should be raised; don't update
-        # comments of nonexistent cards
-        self._header[(self._keyword, item)] = value
-
-
-def _block_size(sep):
-    """
-    Determine the size of a FITS header block if a non-blank separator is used
-    between cards.
-    """
-
-    return BLOCK_SIZE + (len(sep) * (BLOCK_SIZE // Card.length - 1))
-
-
-def _pad_length(stringlen):
-    """Bytes needed to pad the input stringlen to the next FITS block."""
-
-    return (BLOCK_SIZE - (stringlen % BLOCK_SIZE)) % BLOCK_SIZE
-
-
-def _check_padding(header_str, block_size, is_eof, check_block_size=True):
-    # Strip any zero-padding (see ticket #106)
-    if header_str and header_str[-1] == '\0':
-        if is_eof and header_str.strip('\0') == '':
-            # TODO: Pass this warning to validation framework
-            warnings.warn(
-                'Unexpected extra padding at the end of the file.  This '
-                'padding may not be preserved when saving changes.',
-                AstropyUserWarning)
-            raise EOFError()
-        else:
-            # Replace the illegal null bytes with spaces as required by
-            # the FITS standard, and issue a nasty warning
-            # TODO: Pass this warning to validation framework
-            warnings.warn(
-                'Header block contains null bytes instead of spaces for '
-                'padding, and is not FITS-compliant. Nulls may be '
-                'replaced with spaces upon writing.', AstropyUserWarning)
-            header_str.replace('\0', ' ')
-
-    if check_block_size and (len(header_str) % block_size) != 0:
-        # This error message ignores the length of the separator for
-        # now, but maybe it shouldn't?
-        actual_len = len(header_str) - block_size + BLOCK_SIZE
-        # TODO: Pass this error to validation framework
-        raise ValueError('Header size is not multiple of {0}: {1}'
-                         .format(BLOCK_SIZE, actual_len))
+        return cls._fromcards(cards)
\ No newline at end of file
2025-01-15 22:59:17,696 - INFO - Grading answer for astropy__astropy-8707...
2025-01-15 22:59:17,725 - INFO - report: {'astropy__astropy-8707': {'patch_is_None': False, 'patch_exists': True, 'patch_successfully_applied': True, 'resolved': False, 'tests_status': {'FAIL_TO_PASS': {'success': [], 'failure': ['astropy/io/fits/tests/test_header.py::TestHeaderFunctions::test_card_from_bytes']}, 'PASS_TO_PASS': {'success': [], 'failure': ['astropy/io/fits/tests/test_header.py::test_shallow_copy', 'astropy/io/fits/tests/test_header.py::test_init_with_header', 'astropy/io/fits/tests/test_header.py::test_init_with_dict', 'astropy/io/fits/tests/test_header.py::test_init_with_ordereddict', 'astropy/io/fits/tests/test_header.py::TestHeaderFunctions::test_rename_keyword', 'astropy/io/fits/tests/test_header.py::TestHeaderFunctions::test_card_constructor_default_args', 'astropy/io/fits/tests/test_header.py::TestHeaderFunctions::test_string_value_card', 'astropy/io/fits/tests/test_header.py::TestHeaderFunctions::test_boolean_value_card', 'astropy/io/fits/tests/test_header.py::TestHeaderFunctions::test_long_integer_value_card', 'astropy/io/fits/tests/test_header.py::TestHeaderFunctions::test_floating_point_value_card', 'astropy/io/fits/tests/test_header.py::TestHeaderFunctions::test_complex_value_card']}, 'FAIL_TO_FAIL': {'success': [], 'failure': []}, 'PASS_TO_FAIL': {'success': [], 'failure': []}}}}
Result for astropy__astropy-8707: resolved: False
2025-01-15 22:59:17,725 - INFO - Attempting to stop container sweb.eval.astropy__astropy-8707.20250115_225855...
2025-01-15 22:59:33,021 - INFO - Attempting to remove container sweb.eval.astropy__astropy-8707.20250115_225855...
2025-01-15 22:59:33,052 - INFO - Container sweb.eval.astropy__astropy-8707.20250115_225855 removed.

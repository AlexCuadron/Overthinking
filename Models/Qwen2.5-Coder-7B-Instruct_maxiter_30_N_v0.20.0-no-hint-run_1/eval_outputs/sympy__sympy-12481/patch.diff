diff --git a/reproduce_error.py b/reproduce_error.py
new file mode 100644
index 0000000000..1448baccea
--- /dev/null
+++ b/reproduce_error.py
@@ -0,0 +1,11 @@
+from sympy.combinatorics.permutations import Permutation
+
+def main():
+    try:
+        perm = Permutation([[0, 1], [0, 1]])
+        print(perm)
+    except Exception as e:
+        print(f"Error: {e}")
+
+if __name__ == '__main__':
+    main()
\ No newline at end of file
diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py
index 136ed5a478..736ef4232c 100644
--- a/sympy/combinatorics/permutations.py
+++ b/sympy/combinatorics/permutations.py
@@ -799,6 +799,17 @@ class Permutation(Basic):
     _rank = None

     def __new__(cls, *args, **kwargs):
+    # Flatten the list of cycles and remove duplicates
+    cycles = []\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)\n        for cycle in args:\n            if isinstance(cycle, list):\n                cycles.extend(cycle)\n            else:\n                cycles.append(cycle)\n        cycles = list(set(cycles))\n\n        # Create the permutation from the flattened list of cycles\n        return super().__new__(cls, cycles, **kwargs)
+    for cycle in args:
+        if isinstance(cycle, list):
+            cycles.extend(cycle)
+        else:
+            cycles.append(cycle)
+    cycles = list(set(cycles))
+
+    # Create the permutation from the flattened list of cycles
+    return super().__new__(cls, cycles, **kwargs)
         """
         Constructor for the Permutation object from a list or a
         list of lists in which all elements of the permutation may

2025-01-15 13:25:42,677 - INFO - Building image: ghcr.io/all-hands-ai/runtime:oh_v0.20.0_nppclchhw2a9goag_qroup3d3os79ipoo
2025-01-15 13:25:42,682 - INFO - [runtime f81e9c30-4636-459a-97df-cb7c4cea8153-87298272573d6e51] Starting runtime with image: ghcr.io/all-hands-ai/runtime:oh_v0.20.0_nppclchhw2a9goag_qroup3d3os79ipoo
2025-01-15 13:25:43,813 - INFO - [runtime f81e9c30-4636-459a-97df-cb7c4cea8153-87298272573d6e51] Container started: openhands-runtime-f81e9c30-4636-459a-97df-cb7c4cea8153-87298272573d6e51. VSCode URL: None
2025-01-15 13:25:43,813 - INFO - [runtime f81e9c30-4636-459a-97df-cb7c4cea8153-87298272573d6e51] Waiting for client to become ready at http://localhost:34554...
2025-01-15 13:26:13,919 - INFO - [runtime f81e9c30-4636-459a-97df-cb7c4cea8153-87298272573d6e51] Runtime is ready.
2025-01-15 13:26:14,566 - INFO - ------------------------------
2025-01-15 13:26:14,566 - INFO - BEGIN Runtime Initialization Fn
2025-01-15 13:26:14,566 - INFO - ------------------------------
2025-01-15 13:26:14,566 - INFO - **CmdRunAction (source=None)**
COMMAND:
echo 'export SWE_INSTANCE_ID=sphinx-doc__sphinx-7748' >> ~/.bashrc && echo 'export PIP_CACHE_DIR=~/.cache/pip' >> ~/.bashrc && echo "alias git='git --no-pager'" >> ~/.bashrc
2025-01-15 13:26:15,198 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "99dfa09da8d8",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-15 13:26:15,198 - INFO - **CmdRunAction (source=None)**
COMMAND:
export USER=$(whoami); echo USER=${USER} 
2025-01-15 13:26:15,828 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "99dfa09da8d8",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
USER=root
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-15 13:26:15,828 - INFO - **CmdRunAction (source=None)**
COMMAND:
mkdir -p /swe_util/eval_data/instances
2025-01-15 13:26:16,459 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "99dfa09da8d8",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-15 13:26:16,472 - INFO - **CmdRunAction (source=None)**
COMMAND:
cat ~/.bashrc
2025-01-15 13:26:17,102 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "99dfa09da8d8",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
source /opt/miniconda3/etc/profile.d/conda.sh && conda activate testbed
export SWE_INSTANCE_ID=sphinx-doc__sphinx-7748
export PIP_CACHE_DIR=~/.cache/pip
alias git='git --no-pager'
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-15 13:26:17,102 - INFO - **CmdRunAction (source=None)**
COMMAND:
source ~/.bashrc
2025-01-15 13:26:17,733 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "99dfa09da8d8",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-15 13:26:17,734 - WARNING - Timeout greater than 600 seconds may not be supported by the runtime. Consider setting a lower timeout.
2025-01-15 13:26:17,734 - INFO - **CmdRunAction (source=None)**
COMMAND:
source /swe_util/instance_swe_entry.sh
2025-01-15 13:26:19,382 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "99dfa09da8d8",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
WORKSPACE_NAME: sphinx-doc__sphinx__3.1
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-15 13:26:19,382 - INFO - **CmdRunAction (source=None)**
COMMAND:
cd /workspace/sphinx-doc__sphinx__3.1
2025-01-15 13:26:19,535 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "99dfa09da8d8",
  "working_dir": "/workspace/sphinx-doc__sphinx__3.1",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/sphinx-doc__sphinx__3.1]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-15 13:26:19,535 - INFO - **CmdRunAction (source=None)**
COMMAND:
git reset --hard
2025-01-15 13:26:20,168 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "99dfa09da8d8",
  "working_dir": "/workspace/sphinx-doc__sphinx__3.1",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
HEAD is now at 9988d5ce2 Update CHANGES for PR #7746
[The command completed with exit code 0.]
[Current working directory: /workspace/sphinx-doc__sphinx__3.1]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-15 13:26:20,169 - INFO - **CmdRunAction (source=None)**
COMMAND:
for remote_name in $(git remote); do git remote remove "${remote_name}"; done
2025-01-15 13:26:20,801 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "99dfa09da8d8",
  "working_dir": "/workspace/sphinx-doc__sphinx__3.1",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/sphinx-doc__sphinx__3.1]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-15 13:26:20,802 - INFO - **CmdRunAction (source=None)**
COMMAND:
which python
2025-01-15 13:26:21,433 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "99dfa09da8d8",
  "working_dir": "/workspace/sphinx-doc__sphinx__3.1",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
/opt/miniconda3/envs/testbed/bin/python
[The command completed with exit code 0.]
[Current working directory: /workspace/sphinx-doc__sphinx__3.1]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-15 13:26:21,434 - INFO - ------------------------------
2025-01-15 13:26:21,434 - INFO - END Runtime Initialization Fn
2025-01-15 13:26:21,434 - INFO - ------------------------------
2025-01-15 13:26:21,469 - INFO - [runtime f81e9c30-4636-459a-97df-cb7c4cea8153-87298272573d6e51] Found 0 local microagents.
2025-01-15 13:26:21,471 - INFO - [Agent Controller default] Setting agent(CodeActAgent) state from AgentState.LOADING to AgentState.RUNNING
2025-01-15 13:26:21,472 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 0 GLOBAL STEP 0
2025-01-15 13:26:27,708 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 1 GLOBAL STEP 1
2025-01-15 13:26:35,436 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 2 GLOBAL STEP 2
2025-01-15 13:26:42,721 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 3 GLOBAL STEP 3
2025-01-15 13:26:50,185 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 4 GLOBAL STEP 4
2025-01-15 13:26:58,010 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 5 GLOBAL STEP 5
2025-01-15 13:27:12,156 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 6 GLOBAL STEP 6
2025-01-15 13:27:19,488 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 7 GLOBAL STEP 7
2025-01-15 13:27:28,849 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 8 GLOBAL STEP 8
2025-01-15 13:27:37,503 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 9 GLOBAL STEP 9
2025-01-15 13:27:51,041 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 10 GLOBAL STEP 10
2025-01-15 13:27:59,466 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 11 GLOBAL STEP 11
2025-01-15 13:28:08,350 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 12 GLOBAL STEP 12
2025-01-15 13:28:16,020 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 13 GLOBAL STEP 13
2025-01-15 13:28:23,916 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 14 GLOBAL STEP 14
2025-01-15 13:28:39,074 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 15 GLOBAL STEP 15
2025-01-15 13:28:55,531 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 16 GLOBAL STEP 16
2025-01-15 13:29:15,142 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 17 GLOBAL STEP 17
2025-01-15 13:29:30,023 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 18 GLOBAL STEP 18
2025-01-15 13:29:44,584 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 19 GLOBAL STEP 19
2025-01-15 13:29:51,610 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 20 GLOBAL STEP 20
2025-01-15 13:30:04,056 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 21 GLOBAL STEP 21
2025-01-15 13:30:11,176 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 22 GLOBAL STEP 22
2025-01-15 13:30:26,627 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 23 GLOBAL STEP 23
2025-01-15 13:30:34,181 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 24 GLOBAL STEP 24
2025-01-15 13:30:48,134 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 25 GLOBAL STEP 25
2025-01-15 13:30:56,513 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 26 GLOBAL STEP 26
2025-01-15 13:31:08,142 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 27 GLOBAL STEP 27
2025-01-15 13:31:15,300 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 28 GLOBAL STEP 28
2025-01-15 13:31:27,064 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 29 GLOBAL STEP 29
2025-01-15 13:31:41,773 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 30 GLOBAL STEP 30
2025-01-15 13:31:41,773 - INFO - [Agent Controller default] Setting agent(CodeActAgent) state from AgentState.RUNNING to AgentState.ERROR
2025-01-15 13:31:41,774 - ERROR - RuntimeError: Agent reached maximum iteration in headless mode. Current iteration: 30, max iteration: 30
2025-01-15 13:31:41,775 - WARNING - Stopping agent due to traffic control
2025-01-15 13:31:41,775 - INFO - [Agent Controller default] Setting agent(CodeActAgent) state from AgentState.ERROR to AgentState.ERROR
2025-01-15 13:31:41,794 - INFO - ------------------------------
2025-01-15 13:31:41,794 - INFO - BEGIN Runtime Completion Fn
2025-01-15 13:31:41,794 - INFO - ------------------------------
2025-01-15 13:31:41,794 - INFO - **CmdRunAction (source=None)**
COMMAND:
cd /workspace/sphinx-doc__sphinx__3.1
2025-01-15 13:31:42,428 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "99dfa09da8d8",
  "working_dir": "/workspace/sphinx-doc__sphinx__3.1",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/sphinx-doc__sphinx__3.1]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-15 13:31:42,429 - INFO - **CmdRunAction (source=None)**
COMMAND:
git config --global core.pager ""
2025-01-15 13:31:43,061 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "99dfa09da8d8",
  "working_dir": "/workspace/sphinx-doc__sphinx__3.1",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/sphinx-doc__sphinx__3.1]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-15 13:31:43,061 - INFO - **CmdRunAction (source=None)**
COMMAND:
git add -A
2025-01-15 13:31:43,695 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "99dfa09da8d8",
  "working_dir": "/workspace/sphinx-doc__sphinx__3.1",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/sphinx-doc__sphinx__3.1]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-15 13:31:43,696 - INFO - **CmdRunAction (source=None)**
COMMAND:
git diff --no-color --cached 9988d5ce267bf0df4791770b469431b1fb00dcdd
2025-01-15 13:31:44,335 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "99dfa09da8d8",
  "working_dir": "/workspace/sphinx-doc__sphinx__3.1",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py
index f8e4be999..122207d32 100644
--- a/sphinx/ext/autodoc/__init__.py
+++ b/sphinx/ext/autodoc/__init__.py
@@ -1037,39 +1037,67 @@ class DocstringSignatureMixin:
     feature of reading the signature from the docstring.
     """

-    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
-        if encoding is not None:
-            warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
-                          "deprecated." % self.__class__.__name__,
-                          RemovedInSphinx40Warning, stacklevel=2)
+    def _find_all_signatures(self) -> List[Tuple[str, str]]:
+        """Find all signatures in the docstring.
+
+        Returns:
+            List of tuples (args, retann) for each signature found.
+        """
         docstrings = self.get_doc()
         self._new_docstrings = docstrings[:]
-        result = None
-        for i, doclines in enumerate(docstrings):
-            # no lines in docstring, no match
-            if not doclines:
-                continue
-            # match first line of docstring against signature RE
-            match = py_ext_sig_re.match(doclines[0])
+        signatures = []
+
+        # No docstring, no signatures
+        if not docstrings or not docstrings[0]:
+            return signatures
+
+        # Get valid names for matching
+        valid_names = [self.objpath[-1]]  # type: ignore
+        if hasattr(self, 'object') and hasattr(self.object, '__mro__'):
+            valid_names.extend(cls.__name__ for cls in self.object.__mro__)
+
+        # Look for signatures in each line of the first docstring block
+        for line in docstrings[0]:
+            match = py_ext_sig_re.match(line)
             if not match:
                 continue
+
             exmod, path, base, args, retann = match.groups()
-            # the base name must match ours
-            valid_names = [self.objpath[-1]]  # type: ignore
-            if isinstance(self, ClassDocumenter):
-                valid_names.append('__init__')
-                if hasattr(self.object, '__mro__'):
-                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)
             if base not in valid_names:
                 continue
-            # re-prepare docstring to ignore more leading indentation
+
+            signatures.append((args, retann))
+
+        # If we found signatures, update docstring to remove them
+        if signatures:
+            # Find the first non-signature line
+            first_content = 0
+            for i, line in enumerate(docstrings[0]):
+                if not py_ext_sig_re.match(line):
+                    first_content = i
+                    break
+
+            # Re-prepare docstring without signatures
             tab_width = self.directive.state.document.settings.tab_width  # type: ignore
-            self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[1:]),
-                                                        tabsize=tab_width)
-            result = args, retann
-            # don't look any further
-            break
-        return result
+            self._new_docstrings[0] = prepare_docstring(
+                '\n'.join(docstrings[0][first_content:]),
+                tabsize=tab_width
+            )
+
+        return signatures
+
+    def _find_signature(self, encoding: str = None) -> Optional[Tuple[str, str]]:
+        """Find signatures in the docstring.
+
+        Returns the first signature found, but processes all signatures to properly
+        clean up the docstring.
+        """
+        if encoding is not None:
+            warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
+                          "deprecated." % self.__class__.__name__,
+                          RemovedInSphinx40Warning, stacklevel=2)
+        signatures = self._find_all_signatures()
+        return signatures[0] if signatures else None

     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
         if encoding is not None:
@@ -1085,9 +1113,28 @@ class DocstringSignatureMixin:
         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
             # only act if a signature is not explicitly given already, and if
             # the feature is enabled
-            result = self._find_signature()
-            if result is not None:
-                self.args, self.retann = result
+            signatures = self._find_all_signatures()
+            if signatures:
+                # Use the first signature for the main signature
+                self.args, self.retann = signatures[0]
+
+                # Add additional signatures as overloaded methods
+                if len(signatures) > 1:
+                    # Add a note about overloaded signatures
+                    self.doc_comment = "Overloaded method with %d signatures." % len(signatures)
+
+                    # Add each additional signature as a separate line in the docstring
+                    if self._new_docstrings and self._new_docstrings[0]:
+                        overload_lines = []
+                        for args, retann in signatures[1:]:
+                            sig = "(%s)" % args if args else "()"
+                            if retann:
+                                sig += " -> %s" % retann
+                            overload_lines.append("Also available as: %s" % sig)
+                        if overload_lines:
+                            self._new_docstrings[0] = (
+                                [""] + overload_lines + [""] + self._new_docstrings[0]
+                            )
         return super().format_signature(**kwargs)  # type: ignore


diff --git a/sphinx/ext/autodoc/overload.py b/sphinx/ext/autodoc/overload.py
new file mode 100644
index 000000000..d0dbd245f
--- /dev/null
+++ b/sphinx/ext/autodoc/overload.py
@@ -0,0 +1,68 @@
+"""Support for overloaded method signatures in docstrings."""
+
+from typing import List, Optional, Tuple
+
+from sphinx.ext.autodoc import DocstringSignatureMixin, py_ext_sig_re
+from sphinx.util.docstrings import prepare_docstring
+
+
+class OverloadedDocstringSignatureMixin(DocstringSignatureMixin):
+    """Mixin for handling overloaded method signatures in docstrings."""
+
+    def _find_all_signatures(self) -> List[Tuple[str, str]]:
+        """Find all signatures in the docstring.
+
+        Returns:
+            List of tuples (args, retann) for each signature found.
+        """
+        docstrings = self.get_doc()
+        self._new_docstrings = docstrings[:]
+        signatures = []
+
+        # No docstring, no signatures
+        if not docstrings or not docstrings[0]:
+            return signatures
+
+        # Get valid names for matching
+        valid_names = [self.objpath[-1]]  # type: ignore
+        if hasattr(self, 'object') and hasattr(self.object, '__mro__'):
+            valid_names.extend(cls.__name__ for cls in self.object.__mro__)
+
+        # Look for signatures in each line of the first docstring block
+        for line in docstrings[0]:
+            match = py_ext_sig_re.match(line)
+            if not match:
+                continue
+
+            exmod, path, base, args, retann = match.groups()
+            if base not in valid_names:
+                continue
+
+            signatures.append((args, retann))
+
+        # If we found signatures, update docstring to remove them
+        if signatures:
+            # Find the first non-signature line
+            first_content = 0
+            for i, line in enumerate(docstrings[0]):
+                if not py_ext_sig_re.match(line):
+                    first_content = i
+                    break
+
+            # Re-prepare docstring without signatures
+            tab_width = self.directive.state.document.settings.tab_width  # type: ignore
+            self._new_docstrings[0] = prepare_docstring(
+                '\n'.join(docstrings[0][first_content:]),
+                tabsize=tab_width
+            )
+
+        return signatures
+
+    def _find_signature(self) -> Optional[Tuple[str, str]]:
+        """Override to handle multiple signatures.
+
+        Returns the first signature found, but processes all signatures to properly
+        clean up the docstring.
+        """
+        signatures = self._find_all_signatures()
+        return signatures[0] if signatures else None
\ No newline at end of file
diff --git a/tests/reproduce_overload.py b/tests/reproduce_overload.py
new file mode 100644
index 000000000..3b2a85bad
--- /dev/null
+++ b/tests/reproduce_overload.py
@@ -0,0 +1,59 @@
+"""Test script to reproduce issue with autodoc_docstring_signature and overloaded methods."""
+
+class OverloadedMethods:
+    """A class with overloaded methods to test autodoc_docstring_signature.
+
+    This simulates a SWIG-wrapped C++ class with overloaded methods.
+    """
+    def overloaded(self):
+        """overloaded(self)
+        overloaded(self, x: int)
+        overloaded(self, x: str, y: int)
+
+        A method with multiple signatures in its docstring.
+        This simulates how SWIG documents overloaded C++ methods.
+        """
+        pass
+
+if __name__ == '__main__':
+    import os
+    import sys
+    import tempfile
+    from sphinx.application import Sphinx
+
+    # Create a temporary directory for Sphinx output
+    with tempfile.TemporaryDirectory() as outdir:
+        # Create source directory
+        srcdir = os.path.join(outdir, 'source')
+        os.makedirs(srcdir)
+
+        # Create conf.py
+        with open(os.path.join(srcdir, 'conf.py'), 'w') as f:
+            f.write('''
+import os
+import sys
+sys.path.insert(0, os.path.abspath('..'))
+extensions = ['sphinx.ext.autodoc']
+autodoc_docstring_signature = True
+''')
+
+        # Create index.rst
+        with open(os.path.join(srcdir, 'index.rst'), 'w') as f:
+            f.write('''
+Test
+====
+
+.. autoclass:: reproduce_overload.OverloadedMethods
+   :members:
+''')
+
+        # Run Sphinx
+        app = Sphinx(
+            srcdir=srcdir,
+            confdir=srcdir,
+            outdir=os.path.join(outdir, 'build'),
+            doctreedir=os.path.join(outdir, 'doctree'),
+            buildername='text',
+            warningiserror=True
+        )
+        app.build()
\ No newline at end of file
diff --git a/tests/test_ext_autodoc_overload.py b/tests/test_ext_autodoc_overload.py
new file mode 100644
index 000000000..0cc6ae759
--- /dev/null
+++ b/tests/test_ext_autodoc_overload.py
@@ -0,0 +1,59 @@
+"""Test overloaded method signatures in autodoc."""
+
+import pytest
+
+from test_ext_autodoc import do_autodoc
+
+
+@pytest.mark.sphinx('html', testroot='ext-autodoc')
+def test_autodoc_overloaded_signatures(app):
+    # Test with autodoc_docstring_signature enabled (default)
+    options = {"members": None}
+    actual = do_autodoc(app, 'class', 'target.OverloadedMethods', options)
+    assert list(actual) == [
+        '',
+        '.. py:class:: OverloadedMethods()',
+        '   :module: target',
+        '',
+        '   A class with overloaded methods to test autodoc_docstring_signature.',
+        '',
+        '   This simulates a SWIG-wrapped C++ class with overloaded methods.',
+        '',
+        '',
+        '   .. py:method:: OverloadedMethods.overloaded()',
+        '      :module: target',
+        '',
+        '      Overloaded method with 3 signatures.',
+        '',
+        '      Also available as: (x: int)',
+        '      Also available as: (x: str, y: int)',
+        '',
+        '      A method with multiple signatures in its docstring.',
+        '      This simulates how SWIG documents overloaded C++ methods.',
+        '',
+    ]
+
+    # Test with autodoc_docstring_signature disabled
+    app.config.autodoc_docstring_signature = False
+    actual = do_autodoc(app, 'class', 'target.OverloadedMethods', options)
+    assert list(actual) == [
+        '',
+        '.. py:class:: OverloadedMethods()',
+        '   :module: target',
+        '',
+        '   A class with overloaded methods to test autodoc_docstring_signature.',
+        '',
+        '   This simulates a SWIG-wrapped C++ class with overloaded methods.',
+        '',
+        '',
+        '   .. py:method:: OverloadedMethods.overloaded()',
+        '      :module: target',
+        '',
+        '      overloaded(self)',
+        '      overloaded(self, x: int)',
+        '      overloaded(self, x: str, y: int)',
+        '',
+        '      A method with multiple signatures in its docstring.',
+        '      This simulates how SWIG documents overloaded C++ methods.',
+        '',
+    ]
\ No newline at end of file
diff --git a/tests/test_overloaded.py b/tests/test_overloaded.py
new file mode 100644
index 000000000..168ff2e6a
--- /dev/null
+++ b/tests/test_overloaded.py
@@ -0,0 +1,61 @@
+"""Test script for overloaded method signatures."""
+
+import os
+import sys
+import tempfile
+from sphinx.testing.util import SphinxTestApp
+from sphinx.testing.path import path
+
+class OverloadedMethods:
+    """A class with overloaded methods to test autodoc_docstring_signature.
+
+    This simulates a SWIG-wrapped C++ class with overloaded methods.
+    """
+    def overloaded(self):
+        """overloaded(self)
+        overloaded(self, x: int)
+        overloaded(self, x: str, y: int)
+
+        A method with multiple signatures in its docstring.
+        This simulates how SWIG documents overloaded C++ methods.
+        """
+        pass
+
+if __name__ == '__main__':
+    # Create a temporary directory for Sphinx output
+    with tempfile.TemporaryDirectory() as outdir:
+        srcdir = path(outdir) / 'source'
+        srcdir.makedirs()
+
+        # Create conf.py
+        with (srcdir / 'conf.py').open('w') as f:
+            f.write('''
+import os
+import sys
+sys.path.insert(0, os.path.abspath('..'))
+extensions = ['sphinx.ext.autodoc']
+autodoc_docstring_signature = True
+''')
+
+        # Create index.rst
+        with (srcdir / 'index.rst').open('w') as f:
+            f.write('''
+Test
+====
+
+.. autoclass:: test_overloaded.OverloadedMethods
+   :members:
+''')
+
+        # Create a copy of our test file in the source directory
+        with (srcdir / 'test_overloaded.py').open('w') as f:
+            with open(__file__, 'r') as src:
+                f.write(src.read())
+
+        # Run Sphinx
+        app = SphinxTestApp(srcdir=srcdir)
+        app.build()
+
+        # Print the output
+        with (path(outdir) / 'source' / '_build' / 'text' / 'index.txt').open('r') as f:
+            print(f.read())
\ No newline at end of file
[The command completed with exit code 0.]
[Current working directory: /workspace/sphinx-doc__sphinx__3.1]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-15 13:31:44,335 - INFO - ------------------------------
2025-01-15 13:31:44,335 - INFO - END Runtime Completion Fn
2025-01-15 13:31:44,335 - INFO - ------------------------------
2025-01-15 13:31:44,336 - INFO - Got git diff for instance sphinx-doc__sphinx-7748:
--------
diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py
index f8e4be999..122207d32 100644
--- a/sphinx/ext/autodoc/__init__.py
+++ b/sphinx/ext/autodoc/__init__.py
@@ -1037,39 +1037,67 @@ class DocstringSignatureMixin:
     feature of reading the signature from the docstring.
     """

-    def _find_signature(self, encoding: str = None) -> Tuple[str, str]:
-        if encoding is not None:
-            warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
-                          "deprecated." % self.__class__.__name__,
-                          RemovedInSphinx40Warning, stacklevel=2)
+    def _find_all_signatures(self) -> List[Tuple[str, str]]:
+        """Find all signatures in the docstring.
+
+        Returns:
+            List of tuples (args, retann) for each signature found.
+        """
         docstrings = self.get_doc()
         self._new_docstrings = docstrings[:]
-        result = None
-        for i, doclines in enumerate(docstrings):
-            # no lines in docstring, no match
-            if not doclines:
-                continue
-            # match first line of docstring against signature RE
-            match = py_ext_sig_re.match(doclines[0])
+        signatures = []
+
+        # No docstring, no signatures
+        if not docstrings or not docstrings[0]:
+            return signatures
+
+        # Get valid names for matching
+        valid_names = [self.objpath[-1]]  # type: ignore
+        if hasattr(self, 'object') and hasattr(self.object, '__mro__'):
+            valid_names.extend(cls.__name__ for cls in self.object.__mro__)
+
+        # Look for signatures in each line of the first docstring block
+        for line in docstrings[0]:
+            match = py_ext_sig_re.match(line)
             if not match:
                 continue
+
             exmod, path, base, args, retann = match.groups()
-            # the base name must match ours
-            valid_names = [self.objpath[-1]]  # type: ignore
-            if isinstance(self, ClassDocumenter):
-                valid_names.append('__init__')
-                if hasattr(self.object, '__mro__'):
-                    valid_names.extend(cls.__name__ for cls in self.object.__mro__)
             if base not in valid_names:
                 continue
-            # re-prepare docstring to ignore more leading indentation
+
+            signatures.append((args, retann))
+
+        # If we found signatures, update docstring to remove them
+        if signatures:
+            # Find the first non-signature line
+            first_content = 0
+            for i, line in enumerate(docstrings[0]):
+                if not py_ext_sig_re.match(line):
+                    first_content = i
+                    break
+
+            # Re-prepare docstring without signatures
             tab_width = self.directive.state.document.settings.tab_width  # type: ignore
-            self._new_docstrings[i] = prepare_docstring('\n'.join(doclines[1:]),
-                                                        tabsize=tab_width)
-            result = args, retann
-            # don't look any further
-            break
-        return result
+            self._new_docstrings[0] = prepare_docstring(
+                '\n'.join(docstrings[0][first_content:]),
+                tabsize=tab_width
+            )
+
+        return signatures
+
+    def _find_signature(self, encoding: str = None) -> Optional[Tuple[str, str]]:
+        """Find signatures in the docstring.
+
+        Returns the first signature found, but processes all signatures to properly
+        clean up the docstring.
+        """
+        if encoding is not None:
+            warnings.warn("The 'encoding' argument to autodoc.%s._find_signature() is "
+                          "deprecated." % self.__class__.__name__,
+                          RemovedInSphinx40Warning, stacklevel=2)
+        signatures = self._find_all_signatures()
+        return signatures[0] if signatures else None

     def get_doc(self, encoding: str = None, ignore: int = None) -> List[List[str]]:
         if encoding is not None:
@@ -1085,9 +1113,28 @@ class DocstringSignatureMixin:
         if self.args is None and self.env.config.autodoc_docstring_signature:  # type: ignore
             # only act if a signature is not explicitly given already, and if
             # the feature is enabled
-            result = self._find_signature()
-            if result is not None:
-                self.args, self.retann = result
+            signatures = self._find_all_signatures()
+            if signatures:
+                # Use the first signature for the main signature
+                self.args, self.retann = signatures[0]
+
+                # Add additional signatures as overloaded methods
+                if len(signatures) > 1:
+                    # Add a note about overloaded signatures
+                    self.doc_comment = "Overloaded method with %d signatures." % len(signatures)
+
+                    # Add each additional signature as a separate line in the docstring
+                    if self._new_docstrings and self._new_docstrings[0]:
+                        overload_lines = []
+                        for args, retann in signatures[1:]:
+                            sig = "(%s)" % args if args else "()"
+                            if retann:
+                                sig += " -> %s" % retann
+                            overload_lines.append("Also available as: %s" % sig)
+                        if overload_lines:
+                            self._new_docstrings[0] = (
+                                [""] + overload_lines + [""] + self._new_docstrings[0]
+                            )
         return super().format_signature(**kwargs)  # type: ignore


diff --git a/sphinx/ext/autodoc/overload.py b/sphinx/ext/autodoc/overload.py
new file mode 100644
index 000000000..d0dbd245f
--- /dev/null
+++ b/sphinx/ext/autodoc/overload.py
@@ -0,0 +1,68 @@
+"""Support for overloaded method signatures in docstrings."""
+
+from typing import List, Optional, Tuple
+
+from sphinx.ext.autodoc import DocstringSignatureMixin, py_ext_sig_re
+from sphinx.util.docstrings import prepare_docstring
+
+
+class OverloadedDocstringSignatureMixin(DocstringSignatureMixin):
+    """Mixin for handling overloaded method signatures in docstrings."""
+
+    def _find_all_signatures(self) -> List[Tuple[str, str]]:
+        """Find all signatures in the docstring.
+
+        Returns:
+            List of tuples (args, retann) for each signature found.
+        """
+        docstrings = self.get_doc()
+        self._new_docstrings = docstrings[:]
+        signatures = []
+
+        # No docstring, no signatures
+        if not docstrings or not docstrings[0]:
+            return signatures
+
+        # Get valid names for matching
+        valid_names = [self.objpath[-1]]  # type: ignore
+        if hasattr(self, 'object') and hasattr(self.object, '__mro__'):
+            valid_names.extend(cls.__name__ for cls in self.object.__mro__)
+
+        # Look for signatures in each line of the first docstring block
+        for line in docstrings[0]:
+            match = py_ext_sig_re.match(line)
+            if not match:
+                continue
+
+            exmod, path, base, args, retann = match.groups()
+            if base not in valid_names:
+                continue
+
+            signatures.append((args, retann))
+
+        # If we found signatures, update docstring to remove them
+        if signatures:
+            # Find the first non-signature line
+            first_content = 0
+            for i, line in enumerate(docstrings[0]):
+                if not py_ext_sig_re.match(line):
+                    first_content = i
+                    break
+
+            # Re-prepare docstring without signatures
+            tab_width = self.directive.state.document.settings.tab_width  # type: ignore
+            self._new_docstrings[0] = prepare_docstring(
+                '\n'.join(docstrings[0][first_content:]),
+                tabsize=tab_width
+            )
+
+        return signatures
+
+    def _find_signature(self) -> Optional[Tuple[str, str]]:
+        """Override to handle multiple signatures.
+
+        Returns the first signature found, but processes all signatures to properly
+        clean up the docstring.
+        """
+        signatures = self._find_all_signatures()
+        return signatures[0] if signatures else None
\ No newline at end of file
diff --git a/tests/reproduce_overload.py b/tests/reproduce_overload.py
new file mode 100644
index 000000000..3b2a85bad
--- /dev/null
+++ b/tests/reproduce_overload.py
@@ -0,0 +1,59 @@
+"""Test script to reproduce issue with autodoc_docstring_signature and overloaded methods."""
+
+class OverloadedMethods:
+    """A class with overloaded methods to test autodoc_docstring_signature.
+
+    This simulates a SWIG-wrapped C++ class with overloaded methods.
+    """
+    def overloaded(self):
+        """overloaded(self)
+        overloaded(self, x: int)
+        overloaded(self, x: str, y: int)
+
+        A method with multiple signatures in its docstring.
+        This simulates how SWIG documents overloaded C++ methods.
+        """
+        pass
+
+if __name__ == '__main__':
+    import os
+    import sys
+    import tempfile
+    from sphinx.application import Sphinx
+
+    # Create a temporary directory for Sphinx output
+    with tempfile.TemporaryDirectory() as outdir:
+        # Create source directory
+        srcdir = os.path.join(outdir, 'source')
+        os.makedirs(srcdir)
+
+        # Create conf.py
+        with open(os.path.join(srcdir, 'conf.py'), 'w') as f:
+            f.write('''
+import os
+import sys
+sys.path.insert(0, os.path.abspath('..'))
+extensions = ['sphinx.ext.autodoc']
+autodoc_docstring_signature = True
+''')
+
+        # Create index.rst
+        with open(os.path.join(srcdir, 'index.rst'), 'w') as f:
+            f.write('''
+Test
+====
+
+.. autoclass:: reproduce_overload.OverloadedMethods
+   :members:
+''')
+
+        # Run Sphinx
+        app = Sphinx(
+            srcdir=srcdir,
+            confdir=srcdir,
+            outdir=os.path.join(outdir, 'build'),
+            doctreedir=os.path.join(outdir, 'doctree'),
+            buildername='text',
+            warningiserror=True
+        )
+        app.build()
\ No newline at end of file
diff --git a/tests/test_ext_autodoc_overload.py b/tests/test_ext_autodoc_overload.py
new file mode 100644
index 000000000..0cc6ae759
--- /dev/null
+++ b/tests/test_ext_autodoc_overload.py
@@ -0,0 +1,59 @@
+"""Test overloaded method signatures in autodoc."""
+
+import pytest
+
+from test_ext_autodoc import do_autodoc
+
+
+@pytest.mark.sphinx('html', testroot='ext-autodoc')
+def test_autodoc_overloaded_signatures(app):
+    # Test with autodoc_docstring_signature enabled (default)
+    options = {"members": None}
+    actual = do_autodoc(app, 'class', 'target.OverloadedMethods', options)
+    assert list(actual) == [
+        '',
+        '.. py:class:: OverloadedMethods()',
+        '   :module: target',
+        '',
+        '   A class with overloaded methods to test autodoc_docstring_signature.',
+        '',
+        '   This simulates a SWIG-wrapped C++ class with overloaded methods.',
+        '',
+        '',
+        '   .. py:method:: OverloadedMethods.overloaded()',
+        '      :module: target',
+        '',
+        '      Overloaded method with 3 signatures.',
+        '',
+        '      Also available as: (x: int)',
+        '      Also available as: (x: str, y: int)',
+        '',
+        '      A method with multiple signatures in its docstring.',
+        '      This simulates how SWIG documents overloaded C++ methods.',
+        '',
+    ]
+
+    # Test with autodoc_docstring_signature disabled
+    app.config.autodoc_docstring_signature = False
+    actual = do_autodoc(app, 'class', 'target.OverloadedMethods', options)
+    assert list(actual) == [
+        '',
+        '.. py:class:: OverloadedMethods()',
+        '   :module: target',
+        '',
+        '   A class with overloaded methods to test autodoc_docstring_signature.',
+        '',
+        '   This simulates a SWIG-wrapped C++ class with overloaded methods.',
+        '',
+        '',
+        '   .. py:method:: OverloadedMethods.overloaded()',
+        '      :module: target',
+        '',
+        '      overloaded(self)',
+        '      overloaded(self, x: int)',
+        '      overloaded(self, x: str, y: int)',
+        '',
+        '      A method with multiple signatures in its docstring.',
+        '      This simulates how SWIG documents overloaded C++ methods.',
+        '',
+    ]
\ No newline at end of file
diff --git a/tests/test_overloaded.py b/tests/test_overloaded.py
new file mode 100644
index 000000000..168ff2e6a
--- /dev/null
+++ b/tests/test_overloaded.py
@@ -0,0 +1,61 @@
+"""Test script for overloaded method signatures."""
+
+import os
+import sys
+import tempfile
+from sphinx.testing.util import SphinxTestApp
+from sphinx.testing.path import path
+
+class OverloadedMethods:
+    """A class with overloaded methods to test autodoc_docstring_signature.
+
+    This simulates a SWIG-wrapped C++ class with overloaded methods.
+    """
+    def overloaded(self):
+        """overloaded(self)
+        overloaded(self, x: int)
+        overloaded(self, x: str, y: int)
+
+        A method with multiple signatures in its docstring.
+        This simulates how SWIG documents overloaded C++ methods.
+        """
+        pass
+
+if __name__ == '__main__':
+    # Create a temporary directory for Sphinx output
+    with tempfile.TemporaryDirectory() as outdir:
+        srcdir = path(outdir) / 'source'
+        srcdir.makedirs()
+
+        # Create conf.py
+        with (srcdir / 'conf.py').open('w') as f:
+            f.write('''
+import os
+import sys
+sys.path.insert(0, os.path.abspath('..'))
+extensions = ['sphinx.ext.autodoc']
+autodoc_docstring_signature = True
+''')
+
+        # Create index.rst
+        with (srcdir / 'index.rst').open('w') as f:
+            f.write('''
+Test
+====
+
+.. autoclass:: test_overloaded.OverloadedMethods
+   :members:
+''')
+
+        # Create a copy of our test file in the source directory
+        with (srcdir / 'test_overloaded.py').open('w') as f:
+            with open(__file__, 'r') as src:
+                f.write(src.read())
+
+        # Run Sphinx
+        app = SphinxTestApp(srcdir=srcdir)
+        app.build()
+
+        # Print the output
+        with (path(outdir) / 'source' / '_build' / 'text' / 'index.txt').open('r') as f:
+            print(f.read())
\ No newline at end of file
--------
2025-01-15 13:31:45,357 - INFO - Using instance container image: docker.io/xingyaoww/sweb.eval.x86_64.sympy_s_sympy-14531. Please make sure this image exists. Submit an issue on https://github.com/All-Hands-AI/OpenHands if you run into any issues.
2025-01-15 13:31:45,358 - INFO - Logging LLM completions for instance sympy__sympy-14531 to evaluation/evaluation_outputs/outputs/princeton-nlp__SWE-bench_Verified-test/CodeActAgent/claude-3-5-sonnet-20241022_maxiter_30_N_v0.20.0-no-hint-run_1/llm_completions/sympy__sympy-14531

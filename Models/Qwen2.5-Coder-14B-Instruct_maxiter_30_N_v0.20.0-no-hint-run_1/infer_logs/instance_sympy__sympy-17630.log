2025-01-25 12:05:35,496 - INFO - Building image: ghcr.io/all-hands-ai/runtime:oh_v0.20.0_ogqsw0hn12ekysue_1nhip1b65cn5t1ze
2025-01-25 12:05:35,502 - INFO - [runtime 9d0c06d2-2940-4f18-b0dc-04d43c9e688c-15deeda854b609d5] Starting runtime with image: ghcr.io/all-hands-ai/runtime:oh_v0.20.0_ogqsw0hn12ekysue_1nhip1b65cn5t1ze
2025-01-25 12:05:36,712 - INFO - [runtime 9d0c06d2-2940-4f18-b0dc-04d43c9e688c-15deeda854b609d5] Container started: openhands-runtime-9d0c06d2-2940-4f18-b0dc-04d43c9e688c-15deeda854b609d5. VSCode URL: None
2025-01-25 12:05:36,712 - INFO - [runtime 9d0c06d2-2940-4f18-b0dc-04d43c9e688c-15deeda854b609d5] Waiting for client to become ready at http://localhost:39937...
2025-01-25 12:06:06,809 - INFO - [runtime 9d0c06d2-2940-4f18-b0dc-04d43c9e688c-15deeda854b609d5] Runtime is ready.
2025-01-25 12:06:07,449 - INFO - ------------------------------
2025-01-25 12:06:07,449 - INFO - BEGIN Runtime Initialization Fn
2025-01-25 12:06:07,449 - INFO - ------------------------------
2025-01-25 12:06:07,450 - INFO - **CmdRunAction (source=None)**
COMMAND:
echo 'export SWE_INSTANCE_ID=sympy__sympy-17630' >> ~/.bashrc && echo 'export PIP_CACHE_DIR=~/.cache/pip' >> ~/.bashrc && echo "alias git='git --no-pager'" >> ~/.bashrc
2025-01-25 12:06:08,076 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5d3badacd182",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-25 12:06:08,076 - INFO - **CmdRunAction (source=None)**
COMMAND:
export USER=$(whoami); echo USER=${USER} 
2025-01-25 12:06:08,703 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5d3badacd182",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
USER=root
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-25 12:06:08,703 - INFO - **CmdRunAction (source=None)**
COMMAND:
mkdir -p /swe_util/eval_data/instances
2025-01-25 12:06:09,330 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5d3badacd182",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-25 12:06:09,340 - INFO - **CmdRunAction (source=None)**
COMMAND:
cat ~/.bashrc
2025-01-25 12:06:09,967 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5d3badacd182",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
source /opt/miniconda3/etc/profile.d/conda.sh && conda activate testbed
export SWE_INSTANCE_ID=sympy__sympy-17630
export PIP_CACHE_DIR=~/.cache/pip
alias git='git --no-pager'
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-25 12:06:09,967 - INFO - **CmdRunAction (source=None)**
COMMAND:
source ~/.bashrc
2025-01-25 12:06:10,593 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5d3badacd182",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-25 12:06:10,594 - INFO - **CmdRunAction (source=None)**
COMMAND:
source /swe_util/instance_swe_entry.sh
2025-01-25 12:06:12,731 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5d3badacd182",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
WORKSPACE_NAME: sympy__sympy__1.5
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-25 12:06:12,731 - INFO - **CmdRunAction (source=None)**
COMMAND:
cd /workspace/sympy__sympy__1.5
2025-01-25 12:06:13,358 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5d3badacd182",
  "working_dir": "/workspace/sympy__sympy__1.5",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/sympy__sympy__1.5]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-25 12:06:13,358 - INFO - **CmdRunAction (source=None)**
COMMAND:
git reset --hard
2025-01-25 12:06:13,987 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5d3badacd182",
  "working_dir": "/workspace/sympy__sympy__1.5",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
HEAD is now at 58e78209c8 Merge pull request #17623 from cbm755/dollars_stirling
[The command completed with exit code 0.]
[Current working directory: /workspace/sympy__sympy__1.5]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-25 12:06:13,987 - INFO - **CmdRunAction (source=None)**
COMMAND:
for remote_name in $(git remote); do git remote remove "${remote_name}"; done
2025-01-25 12:06:14,613 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5d3badacd182",
  "working_dir": "/workspace/sympy__sympy__1.5",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/sympy__sympy__1.5]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-25 12:06:14,614 - INFO - **CmdRunAction (source=None)**
COMMAND:
which python
2025-01-25 12:06:15,240 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5d3badacd182",
  "working_dir": "/workspace/sympy__sympy__1.5",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
/opt/miniconda3/envs/testbed/bin/python
[The command completed with exit code 0.]
[Current working directory: /workspace/sympy__sympy__1.5]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-25 12:06:15,240 - INFO - ------------------------------
2025-01-25 12:06:15,240 - INFO - END Runtime Initialization Fn
2025-01-25 12:06:15,240 - INFO - ------------------------------
2025-01-25 12:06:15,242 - INFO - Function calling not enabled for model hosted_vllm/Qwen/Qwen2.5-Coder-14B-Instruct. Mocking function calling via prompting.
2025-01-25 12:06:15,246 - INFO - [runtime 9d0c06d2-2940-4f18-b0dc-04d43c9e688c-15deeda854b609d5] Selected repo: None, loading microagents from /workspace/.openhands/microagents (inside runtime)
2025-01-25 12:06:15,265 - INFO - [Agent Controller default] Setting agent(CodeActAgent) state from AgentState.LOADING to AgentState.RUNNING
2025-01-25 12:06:15,266 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 0 GLOBAL STEP 0
2025-01-25 12:06:26,595 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 1 GLOBAL STEP 1
2025-01-25 12:07:11,419 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 2 GLOBAL STEP 2
2025-01-25 12:07:23,893 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 3 GLOBAL STEP 3
2025-01-25 12:07:44,093 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 4 GLOBAL STEP 4
2025-01-25 12:08:36,247 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 5 GLOBAL STEP 5
2025-01-25 12:09:32,007 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 6 GLOBAL STEP 6
2025-01-25 12:09:53,491 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 7 GLOBAL STEP 7
2025-01-25 12:10:43,138 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 8 GLOBAL STEP 8
2025-01-25 12:11:13,868 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 9 GLOBAL STEP 9
2025-01-25 12:12:10,213 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 10 GLOBAL STEP 10
2025-01-25 12:12:38,127 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 11 GLOBAL STEP 11
2025-01-25 12:13:39,120 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 12 GLOBAL STEP 12
2025-01-25 12:14:03,179 - INFO - [Agent Controller default] LEVEL 0 LOCAL STEP 13 GLOBAL STEP 13
2025-01-25 12:14:03,179 - WARNING - Action, Observation pattern detected
2025-01-25 12:14:03,179 - INFO - [Agent Controller default] Setting agent(CodeActAgent) state from AgentState.RUNNING to AgentState.ERROR
2025-01-25 12:14:03,180 - ERROR - AgentStuckInLoopError: Agent got stuck in a loop
2025-01-25 12:14:03,181 - INFO - [Agent Controller default] Setting agent(CodeActAgent) state from AgentState.ERROR to AgentState.ERROR
2025-01-25 12:14:03,704 - INFO - ------------------------------
2025-01-25 12:14:03,704 - INFO - BEGIN Runtime Completion Fn
2025-01-25 12:14:03,704 - INFO - ------------------------------
2025-01-25 12:14:03,705 - INFO - **CmdRunAction (source=None)**
COMMAND:
cd /workspace/sympy__sympy__1.5
2025-01-25 12:14:04,333 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5d3badacd182",
  "working_dir": "/workspace/sympy__sympy__1.5",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/sympy__sympy__1.5]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-25 12:14:04,333 - INFO - **CmdRunAction (source=None)**
COMMAND:
git config --global core.pager ""
2025-01-25 12:14:04,959 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5d3badacd182",
  "working_dir": "/workspace/sympy__sympy__1.5",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/sympy__sympy__1.5]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-25 12:14:04,960 - INFO - **CmdRunAction (source=None)**
COMMAND:
git add -A
2025-01-25 12:14:05,587 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5d3badacd182",
  "working_dir": "/workspace/sympy__sympy__1.5",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/sympy__sympy__1.5]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-25 12:14:05,587 - INFO - **CmdRunAction (source=None)**
COMMAND:
git diff --no-color --cached 58e78209c8577b9890e957b624466e5beed7eb08
2025-01-25 12:14:06,219 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5d3badacd182",
  "working_dir": "/workspace/sympy__sympy__1.5",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
diff --git a/reproduce_error.py b/reproduce_error.py
new file mode 100644
index 0000000000..048a31751d
--- /dev/null
+++ b/reproduce_error.py
@@ -0,0 +1,10 @@
+from sympy import *
+a = MatrixSymbol("a", 2, 2)
+z = ZeroMatrix(2, 2)
+b = BlockMatrix([[a, z], [z, z]])
+
+print("First block multiplication:")
+print(block_collapse(b * b))
+
+print("Second block multiplication:")
+print(block_collapse(b * b * b))
\ No newline at end of file
diff --git a/sympy/matrices/expressions/blockmatrix.py.bak b/sympy/matrices/expressions/blockmatrix.py.bak
new file mode 100644
index 0000000000..95302a05ca
--- /dev/null
+++ b/sympy/matrices/expressions/blockmatrix.py.bak
@@ -0,0 +1,572 @@
+from __future__ import print_function, division
+
+from sympy import ask, Q
+from sympy.core import Basic, Add
+from sympy.core.compatibility import range
+from sympy.strategies import typed, exhaust, condition, do_one, unpack
+from sympy.strategies.traverse import bottom_up
+from sympy.utilities import sift
+from sympy.utilities.misc import filldedent
+
+from sympy.matrices.expressions.matexpr import MatrixExpr, ZeroMatrix, Identity
+from sympy.matrices.expressions.matmul import MatMul
+from sympy.matrices.expressions.matadd import MatAdd
+from sympy.matrices.expressions.matpow import MatPow
+from sympy.matrices.expressions.transpose import Transpose, transpose
+from sympy.matrices.expressions.trace import Trace
+from sympy.matrices.expressions.determinant import det, Determinant
+from sympy.matrices.expressions.slice import MatrixSlice
+from sympy.matrices.expressions.inverse import Inverse
+from sympy.matrices import Matrix, ShapeError
+from sympy.functions.elementary.complexes import re, im
+
+class BlockMatrix(MatrixExpr):
+    """A BlockMatrix is a Matrix comprised of other matrices.
+
+    The submatrices are stored in a SymPy Matrix object but accessed as part of
+    a Matrix Expression
+
+    >>> from sympy import (MatrixSymbol, BlockMatrix, symbols,
+    ...     Identity, ZeroMatrix, block_collapse)
+    >>> n,m,l = symbols('n m l')
+    >>> X = MatrixSymbol('X', n, n)
+    >>> Y = MatrixSymbol('Y', m ,m)
+    >>> Z = MatrixSymbol('Z', n, m)
+    >>> B = BlockMatrix([[X, Z], [ZeroMatrix(m,n), Y]])
+    >>> print(B)
+    Matrix([
+    [X, Z],
+    [0, Y]])
+
+    >>> C = BlockMatrix([[Identity(n), Z]])
+    >>> print(C)
+    Matrix([[I, Z]])
+
+    >>> print(block_collapse(C*B))
+    Matrix([[X, Z + Z*Y]])
+
+    Some matrices might be comprised of rows of blocks with
+    the matrices in each row having the same height and the
+    rows all having the same total number of columns but
+    not having the same number of columns for each matrix
+    in each row. In this case, the matrix is not a block
+    matrix and should be instantiated by Matrix.
+
+    >>> from sympy import ones, Matrix
+    >>> dat = [
+    ... [ones(3,2), ones(3,3)*2],
+    ... [ones(2,3)*3, ones(2,2)*4]]
+    ...
+    >>> BlockMatrix(dat)
+    Traceback (most recent call last):
+    ...
+    ValueError:
+    Although this matrix is comprised of blocks, the blocks do not fill
+    the matrix in a size-symmetric fashion. To create a full matrix from
+    these arguments, pass them directly to Matrix.
+    >>> Matrix(dat)
+    Matrix([
+    [1, 1, 2, 2, 2],
+    [1, 1, 2, 2, 2],
+    [1, 1, 2, 2, 2],
+    [3, 3, 3, 4, 4],
+    [3, 3, 3, 4, 4]])
+
+    See Also
+    ========
+    sympy.matrices.matrices.MatrixBase.irregular
+    """
+    def __new__(cls, *args, **kwargs):
+        from sympy.matrices.immutable import ImmutableDenseMatrix
+        from sympy.utilities.iterables import is_sequence
+        isMat = lambda i: getattr(i, 'is_Matrix', False)
+        if len(args) != 1 or \
+                not is_sequence(args[0]) or \
+                len(set([isMat(r) for r in args[0]])) != 1:
+            raise ValueError(filldedent('''
+                expecting a sequence of 1 or more rows
+                containing Matrices.'''))
+        rows = args[0] if args else []
+        if not isMat(rows):
+            if rows and isMat(rows[0]):
+                rows = [rows]  # rows is not list of lists or []
+            # regularity check
+            # same number of matrices in each row
+            blocky = ok = len(set([len(r) for r in rows])) == 1
+            if ok:
+                # same number of rows for each matrix in a row
+                for r in rows:
+                    ok = len(set([i.rows for i in r])) == 1
+                    if not ok:
+                        break
+                blocky = ok
+                # same number of cols for each matrix in each col
+                for c in range(len(rows[0])):
+                    ok = len(set([rows[i][c].cols
+                        for i in range(len(rows))])) == 1
+                    if not ok:
+                        break
+            if not ok:
+                # same total cols in each row
+                ok = len(set([
+                    sum([i.cols for i in r]) for r in rows])) == 1
+                if blocky and ok:
+                    raise ValueError(filldedent('''
+                        Although this matrix is comprised of blocks,
+                        the blocks do not fill the matrix in a
+                        size-symmetric fashion. To create a full matrix
+                        from these arguments, pass them directly to
+                        Matrix.'''))
+                raise ValueError(filldedent('''
+                    When there are not the same number of rows in each
+                    row's matrices or there are not the same number of
+                    total columns in each row, the matrix is not a
+                    block matrix. If this matrix is known to consist of
+                    blocks fully filling a 2-D space then see
+                    Matrix.irregular.'''))
+        mat = ImmutableDenseMatrix(rows, evaluate=False)
+        obj = Basic.__new__(cls, mat)
+        return obj
+
+    @property
+    def shape(self):
+        numrows = numcols = 0
+        M = self.blocks
+        for i in range(M.shape[0]):
+            numrows += M[i, 0].shape[0]
+        for i in range(M.shape[1]):
+            numcols += M[0, i].shape[1]
+        return (numrows, numcols)
+
+    @property
+    def blockshape(self):
+        return self.blocks.shape
+
+    @property
+    def blocks(self):
+        return self.args[0]
+
+    @property
+    def rowblocksizes(self):
+        return [self.blocks[i, 0].rows for i in range(self.blockshape[0])]
+
+    @property
+    def colblocksizes(self):
+        return [self.blocks[0, i].cols for i in range(self.blockshape[1])]
+
+    def structurally_equal(self, other):
+        return (isinstance(other, BlockMatrix)
+            and self.shape == other.shape
+            and self.blockshape == other.blockshape
+            and self.rowblocksizes == other.rowblocksizes
+            and self.colblocksizes == other.colblocksizes)
+
+    def _blockmul(self, other):
+        if (isinstance(other, BlockMatrix) and
+                self.colblocksizes == other.rowblocksizes):
+            return BlockMatrix(self.blocks*other.blocks)
+
+        return self * other
+
+    def _blockadd(self, other):
+        if (isinstance(other, BlockMatrix)
+                and self.structurally_equal(other)):
+            return BlockMatrix(self.blocks + other.blocks)
+
+        return self + other
+
+    def _eval_transpose(self):
+        # Flip all the individual matrices
+        matrices = [transpose(matrix) for matrix in self.blocks]
+        # Make a copy
+        M = Matrix(self.blockshape[0], self.blockshape[1], matrices)
+        # Transpose the block structure
+        M = M.transpose()
+        return BlockMatrix(M)
+
+    def _eval_trace(self):
+        if self.rowblocksizes == self.colblocksizes:
+            return Add(*[Trace(self.blocks[i, i])
+                        for i in range(self.blockshape[0])])
+        raise NotImplementedError(
+            "Can't perform trace of irregular blockshape")
+
+    def _eval_determinant(self):
+        if self.blockshape == (2, 2):
+            [[A, B],
+             [C, D]] = self.blocks.tolist()
+            if ask(Q.invertible(A)):
+                return det(A)*det(D - C*A.I*B)
+            elif ask(Q.invertible(D)):
+                return det(D)*det(A - B*D.I*C)
+        return Determinant(self)
+
+    def as_real_imag(self):
+        real_matrices = [re(matrix) for matrix in self.blocks]
+        real_matrices = Matrix(self.blockshape[0], self.blockshape[1], real_matrices)
+
+        im_matrices = [im(matrix) for matrix in self.blocks]
+        im_matrices = Matrix(self.blockshape[0], self.blockshape[1], im_matrices)
+
+        return (real_matrices, im_matrices)
+
+    def transpose(self):
+        """Return transpose of matrix.
+
+        Examples
+        ========
+
+        >>> from sympy import MatrixSymbol, BlockMatrix, ZeroMatrix
+        >>> from sympy.abc import l, m, n
+        >>> X = MatrixSymbol('X', n, n)
+        >>> Y = MatrixSymbol('Y', m ,m)
+        >>> Z = MatrixSymbol('Z', n, m)
+        >>> B = BlockMatrix([[X, Z], [ZeroMatrix(m,n), Y]])
+        >>> B.transpose()
+        Matrix([
+        [X.T,  0],
+        [Z.T, Y.T]])
+        >>> _.transpose()
+        Matrix([
+        [X, Z],
+        [0, Y]])
+        """
+        return self._eval_transpose()
+
+    def _entry(self, i, j, **kwargs):
+        # Find row entry
+        for row_block, numrows in enumerate(self.rowblocksizes):
+            if (i < numrows) != False:
+                break
+            else:
+                i -= numrows
+        for col_block, numcols in enumerate(self.colblocksizes):
+            if (j < numcols) != False:
+                break
+            else:
+                j -= numcols
+        return self.blocks[row_block, col_block][i, j]
+
+    @property
+    def is_Identity(self):
+        if self.blockshape[0] != self.blockshape[1]:
+            return False
+        for i in range(self.blockshape[0]):
+            for j in range(self.blockshape[1]):
+                if i==j and not self.blocks[i, j].is_Identity:
+                    return False
+                if i!=j and not self.blocks[i, j].is_ZeroMatrix:
+                    return False
+        return True
+
+    @property
+    def is_structurally_symmetric(self):
+        return self.rowblocksizes == self.colblocksizes
+
+    def equals(self, other):
+        if self == other:
+            return True
+        if (isinstance(other, BlockMatrix) and self.blocks == other.blocks):
+            return True
+        return super(BlockMatrix, self).equals(other)
+
+
+class BlockDiagMatrix(BlockMatrix):
+    """
+    A BlockDiagMatrix is a BlockMatrix with matrices only along the diagonal
+
+    >>> from sympy import MatrixSymbol, BlockDiagMatrix, symbols, Identity
+    >>> n, m, l = symbols('n m l')
+    >>> X = MatrixSymbol('X', n, n)
+    >>> Y = MatrixSymbol('Y', m ,m)
+    >>> BlockDiagMatrix(X, Y)
+    Matrix([
+    [X, 0],
+    [0, Y]])
+
+    See Also
+    ========
+    sympy.matrices.common.diag
+    """
+    def __new__(cls, *mats):
+        return Basic.__new__(BlockDiagMatrix, *mats)
+
+    @property
+    def diag(self):
+        return self.args
+
+    @property
+    def blocks(self):
+        from sympy.matrices.immutable import ImmutableDenseMatrix
+        mats = self.args
+        data = [[mats[i] if i == j else ZeroMatrix(mats[i].rows, mats[j].cols)
+                        for j in range(len(mats))]
+                        for i in range(len(mats))]
+        return ImmutableDenseMatrix(data)
+
+    @property
+    def shape(self):
+        return (sum(block.rows for block in self.args),
+                sum(block.cols for block in self.args))
+
+    @property
+    def blockshape(self):
+        n = len(self.args)
+        return (n, n)
+
+    @property
+    def rowblocksizes(self):
+        return [block.rows for block in self.args]
+
+    @property
+    def colblocksizes(self):
+        return [block.cols for block in self.args]
+
+    def _eval_inverse(self, expand='ignored'):
+        return BlockDiagMatrix(*[mat.inverse() for mat in self.args])
+
+    def _eval_transpose(self):
+        return BlockDiagMatrix(*[mat.transpose() for mat in self.args])
+
+    def _blockmul(self, other):
+        if (isinstance(other, BlockDiagMatrix) and
+                self.colblocksizes == other.rowblocksizes):
+            return BlockDiagMatrix(*[a*b for a, b in zip(self.args, other.args)])
+        else:
+            return BlockMatrix._blockmul(self, other)
+
+    def _blockadd(self, other):
+        if (isinstance(other, BlockDiagMatrix) and
+                self.blockshape == other.blockshape and
+                self.rowblocksizes == other.rowblocksizes and
+                self.colblocksizes == other.colblocksizes):
+            return BlockDiagMatrix(*[a + b for a, b in zip(self.args, other.args)])
+        else:
+            return BlockMatrix._blockadd(self, other)
+
+
+def block_collapse(expr):
+    """Evaluates a block matrix expression
+
+    >>> from sympy import MatrixSymbol, BlockMatrix, symbols, \
+                          Identity, Matrix, ZeroMatrix, block_collapse
+    >>> n,m,l = symbols('n m l')
+    >>> X = MatrixSymbol('X', n, n)
+    >>> Y = MatrixSymbol('Y', m ,m)
+    >>> Z = MatrixSymbol('Z', n, m)
+    >>> B = BlockMatrix([[X, Z], [ZeroMatrix(m, n), Y]])
+    >>> print(B)
+    Matrix([
+    [X, Z],
+    [0, Y]])
+
+    >>> C = BlockMatrix([[Identity(n), Z]])
+    >>> print(C)
+    Matrix([[I, Z]])
+
+    >>> print(block_collapse(C*B))
+    Matrix([[X, Z + Z*Y]])
+    """
+    from sympy.strategies.util import expr_fns
+
+    hasbm = lambda expr: isinstance(expr, MatrixExpr) and expr.has(BlockMatrix)
+
+    conditioned_rl = condition(
+        hasbm,
+        typed(
+            {MatAdd: do_one(bc_matadd, bc_block_plus_ident),
+             MatMul: do_one(bc_matmul, bc_dist),
+             MatPow: bc_matmul,
+             Transpose: bc_transpose,
+             Inverse: bc_inverse,
+             BlockMatrix: do_one(bc_unpack, deblock)}
+        )
+    )
+
+    rule = exhaust(
+        bottom_up(
+            exhaust(conditioned_rl),
+            fns=expr_fns
+        )
+    )
+
+    result = rule(expr)
+    doit = getattr(result, 'doit', None)
+    if doit is not None:
+        return doit()
+    else:
+        return result
+
+def bc_unpack(expr):
+    if expr.blockshape == (1, 1):
+        return expr.blocks[0, 0]
+    return expr
+
+def bc_matadd(expr):
+    args = sift(expr.args, lambda M: isinstance(M, BlockMatrix))
+    blocks = args[True]
+    if not blocks:
+        return expr
+
+    nonblocks = args[False]
+    block = blocks[0]
+    for b in blocks[1:]:
+        block = block._blockadd(b)
+    if nonblocks:
+        return MatAdd(*nonblocks) + block
+    else:
+        return block
+
+def bc_block_plus_ident(expr):
+    idents = [arg for arg in expr.args if arg.is_Identity]
+    if not idents:
+        return expr
+
+    blocks = [arg for arg in expr.args if isinstance(arg, BlockMatrix)]
+    if (blocks and all(b.structurally_equal(blocks[0]) for b in blocks)
+               and blocks[0].is_structurally_symmetric):
+        block_id = BlockDiagMatrix(*[Identity(k)
+                                        for k in blocks[0].rowblocksizes])
+        return MatAdd(block_id * len(idents), *blocks).doit()
+
+    return expr
+
+def bc_dist(expr):
+    """ Turn  a*[X, Y] into [a*X, a*Y] """
+    factor, mat = expr.as_coeff_mmul()
+    if factor == 1:
+        return expr
+
+    unpacked = unpack(mat)
+
+    if isinstance(unpacked, BlockDiagMatrix):
+        B = unpacked.diag
+        new_B = [factor * mat for mat in B]
+        return BlockDiagMatrix(*new_B)
+    elif isinstance(unpacked, BlockMatrix):
+        B = unpacked.blocks
+        new_B = [
+            [factor * B[i, j] for j in range(B.cols)] for i in range(B.rows)]
+        return BlockMatrix(new_B)
+    return unpacked
+
+
+def bc_matmul(expr):
+    if isinstance(expr, MatPow):
+        if expr.args[1].is_Integer:
+            factor, matrices = (1, [expr.args[0]]*expr.args[1])
+        else:
+            return expr
+    else:
+        factor, matrices = expr.as_coeff_matrices()
+
+    i = 0
+    while (i+1 < len(matrices)):
+        A, B = matrices[i:i+2]
+        if isinstance(A, BlockMatrix) and isinstance(B, BlockMatrix):
+            matrices[i] = A._blockmul(B)
+            matrices.pop(i+1)
+        elif isinstance(A, BlockMatrix):
+            matrices[i] = A._blockmul(BlockMatrix([[B]]))
+            matrices.pop(i+1)
+        elif isinstance(B, BlockMatrix):
+            matrices[i] = BlockMatrix([[A]])._blockmul(B)
+            matrices.pop(i+1)
+        else:
+            i+=1
+    return MatMul(factor, *matrices).doit()
+
+def bc_transpose(expr):
+    collapse = block_collapse(expr.arg)
+    return collapse._eval_transpose()
+
+
+def bc_inverse(expr):
+    if isinstance(expr.arg, BlockDiagMatrix):
+        return expr._eval_inverse()
+
+    expr2 = blockinverse_1x1(expr)
+    if expr != expr2:
+        return expr2
+    return blockinverse_2x2(Inverse(reblock_2x2(expr.arg)))
+
+def blockinverse_1x1(expr):
+    if isinstance(expr.arg, BlockMatrix) and expr.arg.blockshape == (1, 1):
+        mat = Matrix([[expr.arg.blocks[0].inverse()]])
+        return BlockMatrix(mat)
+    return expr
+
+def blockinverse_2x2(expr):
+    if isinstance(expr.arg, BlockMatrix) and expr.arg.blockshape == (2, 2):
+        # Cite: The Matrix Cookbook Section 9.1.3
+        [[A, B],
+         [C, D]] = expr.arg.blocks.tolist()
+
+        return BlockMatrix([[ (A - B*D.I*C).I,  (-A).I*B*(D - C*A.I*B).I],
+                            [-(D - C*A.I*B).I*C*A.I,     (D - C*A.I*B).I]])
+    else:
+        return expr
+
+def deblock(B):
+    """ Flatten a BlockMatrix of BlockMatrices """
+    if not isinstance(B, BlockMatrix) or not B.blocks.has(BlockMatrix):
+        return B
+    wrap = lambda x: x if isinstance(x, BlockMatrix) else BlockMatrix([[x]])
+    bb = B.blocks.applyfunc(wrap)  # everything is a block
+
+    from sympy import Matrix
+    try:
+        MM = Matrix(0, sum(bb[0, i].blocks.shape[1] for i in range(bb.shape[1])), [])
+        for row in range(0, bb.shape[0]):
+            M = Matrix(bb[row, 0].blocks)
+            for col in range(1, bb.shape[1]):
+                M = M.row_join(bb[row, col].blocks)
+            MM = MM.col_join(M)
+
+        return BlockMatrix(MM)
+    except ShapeError:
+        return B
+
+
+
+def reblock_2x2(B):
+    """ Reblock a BlockMatrix so that it has 2x2 blocks of block matrices """
+    if not isinstance(B, BlockMatrix) or not all(d > 2 for d in B.blocks.shape):
+        return B
+
+    BM = BlockMatrix  # for brevity's sake
+    return BM([[   B.blocks[0,  0],  BM(B.blocks[0,  1:])],
+               [BM(B.blocks[1:, 0]), BM(B.blocks[1:, 1:])]])
+
+
+def bounds(sizes):
+    """ Convert sequence of numbers into pairs of low-high pairs
+
+    >>> from sympy.matrices.expressions.blockmatrix import bounds
+    >>> bounds((1, 10, 50))
+    [(0, 1), (1, 11), (11, 61)]
+    """
+    low = 0
+    rv = []
+    for size in sizes:
+        rv.append((low, low + size))
+        low += size
+    return rv
+
+def blockcut(expr, rowsizes, colsizes):
+    """ Cut a matrix expression into Blocks
+
+    >>> from sympy import ImmutableMatrix, blockcut
+    >>> M = ImmutableMatrix(4, 4, range(16))
+    >>> B = blockcut(M, (1, 3), (1, 3))
+    >>> type(B).__name__
+    'BlockMatrix'
+    >>> ImmutableMatrix(B.blocks[0, 1])
+    Matrix([[1, 2, 3]])
+    """
+
+    rowbounds = bounds(rowsizes)
+    colbounds = bounds(colsizes)
+    return BlockMatrix([[MatrixSlice(expr, rowbound, colbound)
+                         for colbound in colbounds]
+                         for rowbound in rowbounds])
[The command completed with exit code 0.]
[Current working directory: /workspace/sympy__sympy__1.5]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
--END AGENT OBSERVATION--
2025-01-25 12:14:06,219 - INFO - ------------------------------
2025-01-25 12:14:06,219 - INFO - END Runtime Completion Fn
2025-01-25 12:14:06,219 - INFO - ------------------------------
2025-01-25 12:14:06,220 - INFO - Got git diff for instance sympy__sympy-17630:
--------
diff --git a/reproduce_error.py b/reproduce_error.py
new file mode 100644
index 0000000000..048a31751d
--- /dev/null
+++ b/reproduce_error.py
@@ -0,0 +1,10 @@
+from sympy import *
+a = MatrixSymbol("a", 2, 2)
+z = ZeroMatrix(2, 2)
+b = BlockMatrix([[a, z], [z, z]])
+
+print("First block multiplication:")
+print(block_collapse(b * b))
+
+print("Second block multiplication:")
+print(block_collapse(b * b * b))
\ No newline at end of file
diff --git a/sympy/matrices/expressions/blockmatrix.py.bak b/sympy/matrices/expressions/blockmatrix.py.bak
new file mode 100644
index 0000000000..95302a05ca
--- /dev/null
+++ b/sympy/matrices/expressions/blockmatrix.py.bak
@@ -0,0 +1,572 @@
+from __future__ import print_function, division
+
+from sympy import ask, Q
+from sympy.core import Basic, Add
+from sympy.core.compatibility import range
+from sympy.strategies import typed, exhaust, condition, do_one, unpack
+from sympy.strategies.traverse import bottom_up
+from sympy.utilities import sift
+from sympy.utilities.misc import filldedent
+
+from sympy.matrices.expressions.matexpr import MatrixExpr, ZeroMatrix, Identity
+from sympy.matrices.expressions.matmul import MatMul
+from sympy.matrices.expressions.matadd import MatAdd
+from sympy.matrices.expressions.matpow import MatPow
+from sympy.matrices.expressions.transpose import Transpose, transpose
+from sympy.matrices.expressions.trace import Trace
+from sympy.matrices.expressions.determinant import det, Determinant
+from sympy.matrices.expressions.slice import MatrixSlice
+from sympy.matrices.expressions.inverse import Inverse
+from sympy.matrices import Matrix, ShapeError
+from sympy.functions.elementary.complexes import re, im
+
+class BlockMatrix(MatrixExpr):
+    """A BlockMatrix is a Matrix comprised of other matrices.
+
+    The submatrices are stored in a SymPy Matrix object but accessed as part of
+    a Matrix Expression
+
+    >>> from sympy import (MatrixSymbol, BlockMatrix, symbols,
+    ...     Identity, ZeroMatrix, block_collapse)
+    >>> n,m,l = symbols('n m l')
+    >>> X = MatrixSymbol('X', n, n)
+    >>> Y = MatrixSymbol('Y', m ,m)
+    >>> Z = MatrixSymbol('Z', n, m)
+    >>> B = BlockMatrix([[X, Z], [ZeroMatrix(m,n), Y]])
+    >>> print(B)
+    Matrix([
+    [X, Z],
+    [0, Y]])
+
+    >>> C = BlockMatrix([[Identity(n), Z]])
+    >>> print(C)
+    Matrix([[I, Z]])
+
+    >>> print(block_collapse(C*B))
+    Matrix([[X, Z + Z*Y]])
+
+    Some matrices might be comprised of rows of blocks with
+    the matrices in each row having the same height and the
+    rows all having the same total number of columns but
+    not having the same number of columns for each matrix
+    in each row. In this case, the matrix is not a block
+    matrix and should be instantiated by Matrix.
+
+    >>> from sympy import ones, Matrix
+    >>> dat = [
+    ... [ones(3,2), ones(3,3)*2],
+    ... [ones(2,3)*3, ones(2,2)*4]]
+    ...
+    >>> BlockMatrix(dat)
+    Traceback (most recent call last):
+    ...
+    ValueError:
+    Although this matrix is comprised of blocks, the blocks do not fill
+    the matrix in a size-symmetric fashion. To create a full matrix from
+    these arguments, pass them directly to Matrix.
+    >>> Matrix(dat)
+    Matrix([
+    [1, 1, 2, 2, 2],
+    [1, 1, 2, 2, 2],
+    [1, 1, 2, 2, 2],
+    [3, 3, 3, 4, 4],
+    [3, 3, 3, 4, 4]])
+
+    See Also
+    ========
+    sympy.matrices.matrices.MatrixBase.irregular
+    """
+    def __new__(cls, *args, **kwargs):
+        from sympy.matrices.immutable import ImmutableDenseMatrix
+        from sympy.utilities.iterables import is_sequence
+        isMat = lambda i: getattr(i, 'is_Matrix', False)
+        if len(args) != 1 or \
+                not is_sequence(args[0]) or \
+                len(set([isMat(r) for r in args[0]])) != 1:
+            raise ValueError(filldedent('''
+                expecting a sequence of 1 or more rows
+                containing Matrices.'''))
+        rows = args[0] if args else []
+        if not isMat(rows):
+            if rows and isMat(rows[0]):
+                rows = [rows]  # rows is not list of lists or []
+            # regularity check
+            # same number of matrices in each row
+            blocky = ok = len(set([len(r) for r in rows])) == 1
+            if ok:
+                # same number of rows for each matrix in a row
+                for r in rows:
+                    ok = len(set([i.rows for i in r])) == 1
+                    if not ok:
+                        break
+                blocky = ok
+                # same number of cols for each matrix in each col
+                for c in range(len(rows[0])):
+                    ok = len(set([rows[i][c].cols
+                        for i in range(len(rows))])) == 1
+                    if not ok:
+                        break
+            if not ok:
+                # same total cols in each row
+                ok = len(set([
+                    sum([i.cols for i in r]) for r in rows])) == 1
+                if blocky and ok:
+                    raise ValueError(filldedent('''
+                        Although this matrix is comprised of blocks,
+                        the blocks do not fill the matrix in a
+                        size-symmetric fashion. To create a full matrix
+                        from these arguments, pass them directly to
+                        Matrix.'''))
+                raise ValueError(filldedent('''
+                    When there are not the same number of rows in each
+                    row's matrices or there are not the same number of
+                    total columns in each row, the matrix is not a
+                    block matrix. If this matrix is known to consist of
+                    blocks fully filling a 2-D space then see
+                    Matrix.irregular.'''))
+        mat = ImmutableDenseMatrix(rows, evaluate=False)
+        obj = Basic.__new__(cls, mat)
+        return obj
+
+    @property
+    def shape(self):
+        numrows = numcols = 0
+        M = self.blocks
+        for i in range(M.shape[0]):
+            numrows += M[i, 0].shape[0]
+        for i in range(M.shape[1]):
+            numcols += M[0, i].shape[1]
+        return (numrows, numcols)
+
+    @property
+    def blockshape(self):
+        return self.blocks.shape
+
+    @property
+    def blocks(self):
+        return self.args[0]
+
+    @property
+    def rowblocksizes(self):
+        return [self.blocks[i, 0].rows for i in range(self.blockshape[0])]
+
+    @property
+    def colblocksizes(self):
+        return [self.blocks[0, i].cols for i in range(self.blockshape[1])]
+
+    def structurally_equal(self, other):
+        return (isinstance(other, BlockMatrix)
+            and self.shape == other.shape
+            and self.blockshape == other.blockshape
+            and self.rowblocksizes == other.rowblocksizes
+            and self.colblocksizes == other.colblocksizes)
+
+    def _blockmul(self, other):
+        if (isinstance(other, BlockMatrix) and
+                self.colblocksizes == other.rowblocksizes):
+            return BlockMatrix(self.blocks*other.blocks)
+
+        return self * other
+
+    def _blockadd(self, other):
+        if (isinstance(other, BlockMatrix)
+                and self.structurally_equal(other)):
+            return BlockMatrix(self.blocks + other.blocks)
+
+        return self + other
+
+    def _eval_transpose(self):
+        # Flip all the individual matrices
+        matrices = [transpose(matrix) for matrix in self.blocks]
+        # Make a copy
+        M = Matrix(self.blockshape[0], self.blockshape[1], matrices)
+        # Transpose the block structure
+        M = M.transpose()
+        return BlockMatrix(M)
+
+    def _eval_trace(self):
+        if self.rowblocksizes == self.colblocksizes:
+            return Add(*[Trace(self.blocks[i, i])
+                        for i in range(self.blockshape[0])])
+        raise NotImplementedError(
+            "Can't perform trace of irregular blockshape")
+
+    def _eval_determinant(self):
+        if self.blockshape == (2, 2):
+            [[A, B],
+             [C, D]] = self.blocks.tolist()
+            if ask(Q.invertible(A)):
+                return det(A)*det(D - C*A.I*B)
+            elif ask(Q.invertible(D)):
+                return det(D)*det(A - B*D.I*C)
+        return Determinant(self)
+
+    def as_real_imag(self):
+        real_matrices = [re(matrix) for matrix in self.blocks]
+        real_matrices = Matrix(self.blockshape[0], self.blockshape[1], real_matrices)
+
+        im_matrices = [im(matrix) for matrix in self.blocks]
+        im_matrices = Matrix(self.blockshape[0], self.blockshape[1], im_matrices)
+
+        return (real_matrices, im_matrices)
+
+    def transpose(self):
+        """Return transpose of matrix.
+
+        Examples
+        ========
+
+        >>> from sympy import MatrixSymbol, BlockMatrix, ZeroMatrix
+        >>> from sympy.abc import l, m, n
+        >>> X = MatrixSymbol('X', n, n)
+        >>> Y = MatrixSymbol('Y', m ,m)
+        >>> Z = MatrixSymbol('Z', n, m)
+        >>> B = BlockMatrix([[X, Z], [ZeroMatrix(m,n), Y]])
+        >>> B.transpose()
+        Matrix([
+        [X.T,  0],
+        [Z.T, Y.T]])
+        >>> _.transpose()
+        Matrix([
+        [X, Z],
+        [0, Y]])
+        """
+        return self._eval_transpose()
+
+    def _entry(self, i, j, **kwargs):
+        # Find row entry
+        for row_block, numrows in enumerate(self.rowblocksizes):
+            if (i < numrows) != False:
+                break
+            else:
+                i -= numrows
+        for col_block, numcols in enumerate(self.colblocksizes):
+            if (j < numcols) != False:
+                break
+            else:
+                j -= numcols
+        return self.blocks[row_block, col_block][i, j]
+
+    @property
+    def is_Identity(self):
+        if self.blockshape[0] != self.blockshape[1]:
+            return False
+        for i in range(self.blockshape[0]):
+            for j in range(self.blockshape[1]):
+                if i==j and not self.blocks[i, j].is_Identity:
+                    return False
+                if i!=j and not self.blocks[i, j].is_ZeroMatrix:
+                    return False
+        return True
+
+    @property
+    def is_structurally_symmetric(self):
+        return self.rowblocksizes == self.colblocksizes
+
+    def equals(self, other):
+        if self == other:
+            return True
+        if (isinstance(other, BlockMatrix) and self.blocks == other.blocks):
+            return True
+        return super(BlockMatrix, self).equals(other)
+
+
+class BlockDiagMatrix(BlockMatrix):
+    """
+    A BlockDiagMatrix is a BlockMatrix with matrices only along the diagonal
+
+    >>> from sympy import MatrixSymbol, BlockDiagMatrix, symbols, Identity
+    >>> n, m, l = symbols('n m l')
+    >>> X = MatrixSymbol('X', n, n)
+    >>> Y = MatrixSymbol('Y', m ,m)
+    >>> BlockDiagMatrix(X, Y)
+    Matrix([
+    [X, 0],
+    [0, Y]])
+
+    See Also
+    ========
+    sympy.matrices.common.diag
+    """
+    def __new__(cls, *mats):
+        return Basic.__new__(BlockDiagMatrix, *mats)
+
+    @property
+    def diag(self):
+        return self.args
+
+    @property
+    def blocks(self):
+        from sympy.matrices.immutable import ImmutableDenseMatrix
+        mats = self.args
+        data = [[mats[i] if i == j else ZeroMatrix(mats[i].rows, mats[j].cols)
+                        for j in range(len(mats))]
+                        for i in range(len(mats))]
+        return ImmutableDenseMatrix(data)
+
+    @property
+    def shape(self):
+        return (sum(block.rows for block in self.args),
+                sum(block.cols for block in self.args))
+
+    @property
+    def blockshape(self):
+        n = len(self.args)
+        return (n, n)
+
+    @property
+    def rowblocksizes(self):
+        return [block.rows for block in self.args]
+
+    @property
+    def colblocksizes(self):
+        return [block.cols for block in self.args]
+
+    def _eval_inverse(self, expand='ignored'):
+        return BlockDiagMatrix(*[mat.inverse() for mat in self.args])
+
+    def _eval_transpose(self):
+        return BlockDiagMatrix(*[mat.transpose() for mat in self.args])
+
+    def _blockmul(self, other):
+        if (isinstance(other, BlockDiagMatrix) and
+                self.colblocksizes == other.rowblocksizes):
+            return BlockDiagMatrix(*[a*b for a, b in zip(self.args, other.args)])
+        else:
+            return BlockMatrix._blockmul(self, other)
+
+    def _blockadd(self, other):
+        if (isinstance(other, BlockDiagMatrix) and
+                self.blockshape == other.blockshape and
+                self.rowblocksizes == other.rowblocksizes and
+                self.colblocksizes == other.colblocksizes):
+            return BlockDiagMatrix(*[a + b for a, b in zip(self.args, other.args)])
+        else:
+            return BlockMatrix._blockadd(self, other)
+
+
+def block_collapse(expr):
+    """Evaluates a block matrix expression
+
+    >>> from sympy import MatrixSymbol, BlockMatrix, symbols, \
+                          Identity, Matrix, ZeroMatrix, block_collapse
+    >>> n,m,l = symbols('n m l')
+    >>> X = MatrixSymbol('X', n, n)
+    >>> Y = MatrixSymbol('Y', m ,m)
+    >>> Z = MatrixSymbol('Z', n, m)
+    >>> B = BlockMatrix([[X, Z], [ZeroMatrix(m, n), Y]])
+    >>> print(B)
+    Matrix([
+    [X, Z],
+    [0, Y]])
+
+    >>> C = BlockMatrix([[Identity(n), Z]])
+    >>> print(C)
+    Matrix([[I, Z]])
+
+    >>> print(block_collapse(C*B))
+    Matrix([[X, Z + Z*Y]])
+    """
+    from sympy.strategies.util import expr_fns
+
+    hasbm = lambda expr: isinstance(expr, MatrixExpr) and expr.has(BlockMatrix)
+
+    conditioned_rl = condition(
+        hasbm,
+        typed(
+            {MatAdd: do_one(bc_matadd, bc_block_plus_ident),
+             MatMul: do_one(bc_matmul, bc_dist),
+             MatPow: bc_matmul,
+             Transpose: bc_transpose,
+             Inverse: bc_inverse,
+             BlockMatrix: do_one(bc_unpack, deblock)}
+        )
+    )
+
+    rule = exhaust(
+        bottom_up(
+            exhaust(conditioned_rl),
+            fns=expr_fns
+        )
+    )
+
+    result = rule(expr)
+    doit = getattr(result, 'doit', None)
+    if doit is not None:
+        return doit()
+    else:
+        return result
+
+def bc_unpack(expr):
+    if expr.blockshape == (1, 1):
+        return expr.blocks[0, 0]
+    return expr
+
+def bc_matadd(expr):
+    args = sift(expr.args, lambda M: isinstance(M, BlockMatrix))
+    blocks = args[True]
+    if not blocks:
+        return expr
+
+    nonblocks = args[False]
+    block = blocks[0]
+    for b in blocks[1:]:
+        block = block._blockadd(b)
+    if nonblocks:
+        return MatAdd(*nonblocks) + block
+    else:
+        return block
+
+def bc_block_plus_ident(expr):
+    idents = [arg for arg in expr.args if arg.is_Identity]
+    if not idents:
+        return expr
+
+    blocks = [arg for arg in expr.args if isinstance(arg, BlockMatrix)]
+    if (blocks and all(b.structurally_equal(blocks[0]) for b in blocks)
+               and blocks[0].is_structurally_symmetric):
+        block_id = BlockDiagMatrix(*[Identity(k)
+                                        for k in blocks[0].rowblocksizes])
+        return MatAdd(block_id * len(idents), *blocks).doit()
+
+    return expr
+
+def bc_dist(expr):
+    """ Turn  a*[X, Y] into [a*X, a*Y] """
+    factor, mat = expr.as_coeff_mmul()
+    if factor == 1:
+        return expr
+
+    unpacked = unpack(mat)
+
+    if isinstance(unpacked, BlockDiagMatrix):
+        B = unpacked.diag
+        new_B = [factor * mat for mat in B]
+        return BlockDiagMatrix(*new_B)
+    elif isinstance(unpacked, BlockMatrix):
+        B = unpacked.blocks
+        new_B = [
+            [factor * B[i, j] for j in range(B.cols)] for i in range(B.rows)]
+        return BlockMatrix(new_B)
+    return unpacked
+
+
+def bc_matmul(expr):
+    if isinstance(expr, MatPow):
+        if expr.args[1].is_Integer:
+            factor, matrices = (1, [expr.args[0]]*expr.args[1])
+        else:
+            return expr
+    else:
+        factor, matrices = expr.as_coeff_matrices()
+
+    i = 0
+    while (i+1 < len(matrices)):
+        A, B = matrices[i:i+2]
+        if isinstance(A, BlockMatrix) and isinstance(B, BlockMatrix):
+            matrices[i] = A._blockmul(B)
+            matrices.pop(i+1)
+        elif isinstance(A, BlockMatrix):
+            matrices[i] = A._blockmul(BlockMatrix([[B]]))
+            matrices.pop(i+1)
+        elif isinstance(B, BlockMatrix):
+            matrices[i] = BlockMatrix([[A]])._blockmul(B)
+            matrices.pop(i+1)
+        else:
+            i+=1
+    return MatMul(factor, *matrices).doit()
+
+def bc_transpose(expr):
+    collapse = block_collapse(expr.arg)
+    return collapse._eval_transpose()
+
+
+def bc_inverse(expr):
+    if isinstance(expr.arg, BlockDiagMatrix):
+        return expr._eval_inverse()
+
+    expr2 = blockinverse_1x1(expr)
+    if expr != expr2:
+        return expr2
+    return blockinverse_2x2(Inverse(reblock_2x2(expr.arg)))
+
+def blockinverse_1x1(expr):
+    if isinstance(expr.arg, BlockMatrix) and expr.arg.blockshape == (1, 1):
+        mat = Matrix([[expr.arg.blocks[0].inverse()]])
+        return BlockMatrix(mat)
+    return expr
+
+def blockinverse_2x2(expr):
+    if isinstance(expr.arg, BlockMatrix) and expr.arg.blockshape == (2, 2):
+        # Cite: The Matrix Cookbook Section 9.1.3
+        [[A, B],
+         [C, D]] = expr.arg.blocks.tolist()
+
+        return BlockMatrix([[ (A - B*D.I*C).I,  (-A).I*B*(D - C*A.I*B).I],
+                            [-(D - C*A.I*B).I*C*A.I,     (D - C*A.I*B).I]])
+    else:
+        return expr
+
+def deblock(B):
+    """ Flatten a BlockMatrix of BlockMatrices """
+    if not isinstance(B, BlockMatrix) or not B.blocks.has(BlockMatrix):
+        return B
+    wrap = lambda x: x if isinstance(x, BlockMatrix) else BlockMatrix([[x]])
+    bb = B.blocks.applyfunc(wrap)  # everything is a block
+
+    from sympy import Matrix
+    try:
+        MM = Matrix(0, sum(bb[0, i].blocks.shape[1] for i in range(bb.shape[1])), [])
+        for row in range(0, bb.shape[0]):
+            M = Matrix(bb[row, 0].blocks)
+            for col in range(1, bb.shape[1]):
+                M = M.row_join(bb[row, col].blocks)
+            MM = MM.col_join(M)
+
+        return BlockMatrix(MM)
+    except ShapeError:
+        return B
+
+
+
+def reblock_2x2(B):
+    """ Reblock a BlockMatrix so that it has 2x2 blocks of block matrices """
+    if not isinstance(B, BlockMatrix) or not all(d > 2 for d in B.blocks.shape):
+        return B
+
+    BM = BlockMatrix  # for brevity's sake
+    return BM([[   B.blocks[0,  0],  BM(B.blocks[0,  1:])],
+               [BM(B.blocks[1:, 0]), BM(B.blocks[1:, 1:])]])
+
+
+def bounds(sizes):
+    """ Convert sequence of numbers into pairs of low-high pairs
+
+    >>> from sympy.matrices.expressions.blockmatrix import bounds
+    >>> bounds((1, 10, 50))
+    [(0, 1), (1, 11), (11, 61)]
+    """
+    low = 0
+    rv = []
+    for size in sizes:
+        rv.append((low, low + size))
+        low += size
+    return rv
+
+def blockcut(expr, rowsizes, colsizes):
+    """ Cut a matrix expression into Blocks
+
+    >>> from sympy import ImmutableMatrix, blockcut
+    >>> M = ImmutableMatrix(4, 4, range(16))
+    >>> B = blockcut(M, (1, 3), (1, 3))
+    >>> type(B).__name__
+    'BlockMatrix'
+    >>> ImmutableMatrix(B.blocks[0, 1])
+    Matrix([[1, 2, 3]])
+    """
+
+    rowbounds = bounds(rowsizes)
+    colbounds = bounds(colsizes)
+    return BlockMatrix([[MatrixSlice(expr, rowbound, colbound)
+                         for colbound in colbounds]
+                         for rowbound in rowbounds])
--------
